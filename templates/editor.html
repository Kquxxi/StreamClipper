<!DOCTYPE html>

<html lang="pl">
<head>
  <meta charset="utf-8">
  <title>StreamClipper ‚Äì Edytor klip√≥w</title>
  <link rel="stylesheet" href="/static/style.css?v={{ cache_buster }}">
  <style>
    :root {
      --bg-dark: var(--bg);
      --border-color: var(--border);
      --text-primary: var(--text);
      --text-secondary: #8a9099;
      --accent-red: #e74c3c;
    }

    body {
      background-color: var(--bg);
      color: var(--text);
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    }

    .editor-grid {
      display: grid;
      grid-template-columns: 280px 1fr 360px;
      grid-template-rows: 1fr auto;
      grid-template-areas:
        "sidebar main inspector"
        "timeline timeline timeline";
      min-height: 100vh;
      gap: 1rem;
      padding: 1rem;
      box-sizing: border-box;
    }

    .panel {
      background-color: var(--panel-bg);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .nice-checkbox { display:flex; align-items:center; gap:8px; margin-top:8px; }
    .nice-checkbox input[type="checkbox"] { width:18px; height:18px; accent-color: var(--accent-blue); }
    .hint { color: var(--text-secondary); font-size: 0.9em; }
    
    .header { grid-area: header; }
    .sidebar { grid-area: sidebar; }
    .main-content { grid-area: main; }
    .inspector { grid-area: inspector; }
    /* Ensure inspector panel can scroll vertically and not clip content */
    .inspector.panel { overflow-y: visible; }
    /* Timeline popup: hidden by default, fixed in bottom-right */
    .timeline-container { display:none; position: fixed; right: 16px; bottom: 72px; width: 360px; max-height: 70vh; overflow:auto; z-index: 9999; background-color: var(--panel-bg) !important; border: 1px solid var(--border); border-radius: var(--radius); box-shadow: 0 14px 30px rgba(0,0,0,0.40); }
    .timeline-container.open { display:block; }
    /* Enforce solid background and opacity for the popup */
    .timeline-container { background: var(--panel-bg) !important; opacity: 1 !important; backdrop-filter: none !important; }
    .timeline-container .panel-header, .timeline-container #timeline-content { background-color: var(--panel-bg); }
    .timeline-container.panel { background-color: var(--panel-bg) !important; }

    /* Timeline buttons ‚Äî nowoczesny wyglƒÖd */
    .timeline-container .panel-header .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      font-weight: 600;
      letter-spacing: 0.02em;
      border-radius: 10px;
      border: 1px solid var(--border);
      color: #e9eef6;
      background: linear-gradient(180deg, #2d323a 0%, #23272e 100%);
      box-shadow: 0 1px 0 rgba(255,255,255,0.06) inset, 0 10px 18px rgba(0,0,0,0.35);
      transition: transform 0.08s ease, box-shadow 0.2s ease, background 0.2s ease, border-color 0.2s ease;
    }
    .timeline-container .panel-header .btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 1px 0 rgba(255,255,255,0.06) inset, 0 14px 24px rgba(0,0,0,0.45);
      background: linear-gradient(180deg, #343943 0%, #262a31 100%);
    }
    .timeline-container .panel-header .btn:active {
      transform: translateY(0);
      box-shadow: none;
      background: linear-gradient(180deg, #22262c 0%, #1d2026 100%);
    }
    .timeline-container .panel-header .btn.btn-secondary {
      color: #dfe6ef;
      background: linear-gradient(180deg, #2a2f36 0%, #22262d 100%);
      border-color: #3a3f47;
    }
    .timeline-container .panel-header .btn.btn-small {
      height: 32px;
      min-width: 32px;
      padding: 0 10px;
      font-size: 12px;
    }

    /* Timeline filters ‚Äî styl checkbox√≥w i selektora */
    .timeline-filters label {
      display:inline-flex; align-items:center; gap:8px;
      padding:6px 10px; border:1px solid var(--border); border-radius:10px;
      background: var(--panel-bg); color: var(--text);
      transition: background 0.2s ease, border-color 0.2s ease;
    }
    .timeline-filters label:hover { background:#2f333d; border-color:#4b5565; }
    .timeline-filters input[type="checkbox"] { width:16px; height:16px; accent-color: var(--accent-blue); }
    .timeline-filters select { height:32px; padding:4px 8px; border-radius:8px; background: var(--panel-bg); border:1px solid var(--border); color: var(--text); }

    /* Timeline list ‚Äî nowoczesny wyglƒÖd pozycji */
    .timeline-list { display:flex; flex-direction:column; gap:8px; }
    .timeline-item {
      border:1px solid var(--border-color); border-radius:10px; padding:10px;
      background: linear-gradient(180deg, #2b2f37 0%, #242830 100%);
      box-shadow: 0 6px 16px rgba(0,0,0,0.35);
      cursor:pointer; display:flex; flex-direction:column; gap:6px;
      transition: transform 0.08s ease, box-shadow 0.2s ease, background 0.2s ease;
    }
    .timeline-item:hover { transform: translateY(-1px); box-shadow: 0 10px 20px rgba(0,0,0,0.45); background: linear-gradient(180deg, #303641 0%, #272c35 100%); }
    .timeline-item:active { transform: translateY(0); box-shadow: 0 6px 16px rgba(0,0,0,0.35); }
    .timeline-item-title { font-weight:600; color: var(--text-primary); }
    .timeline-item-meta { font-size:12px; color: var(--text-secondary); }
    .timeline-item-status { font-size:12px; font-weight:600; }
    .timeline-item-status.status-pending { color:#f39c12; }
    .timeline-item-status.status-published { color:#27ae60; }
    .timeline-item-status.status-failed { color:#e74c3c; }

    .panel-header {
      font-size: 1.1em;
      font-weight: 600;
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 1px solid var(--border-color);
    }
    
    .clip-list-container {
      overflow-y: auto;
      flex-grow: 1;
      max-height: 70vh;
      padding-right: 4px;
    }
    #clip-list { list-style: none; padding: 0; margin: 0; }
    .clip-item { 
      cursor: pointer; 
      padding: 8px 12px;
      border-radius: 6px; 
      margin-bottom: 4px;
      transition: background-color 0.2s;
    }
    .clip-item:hover { background-color: #2f333d; }
    .clip-item.active { background-color: #39404c; font-weight: 600; }

    .player { flex:1; display:flex; flex-direction:column; }
    .canvas-wrap {
      position: relative;
      width: 100%;
      flex-grow: 1;
      background-color: #000;
      border-radius: 6px;
      overflow: hidden;
    }
    #video { width: 100%; height: 100%; object-fit: contain; }

    .overlay { position:absolute; left:0; top:0; right:0; bottom:0; z-index:2; }
    .overlay.inactive { pointer-events:none; cursor:default; }
    .overlay:not(.inactive) { pointer-events:auto; cursor:crosshair; }
    
    .crop-rect { position:absolute; border:2px dashed; pointer-events:auto; background:transparent; cursor:move; z-index:2; }
    .crop-game { border-color: var(--accent-blue); color: var(--accent-blue); }
    .crop-camera { border-color: var(--accent-red); color: var(--accent-red); }

    .crop-rect .handle { position:absolute; width:14px; height:14px; background: var(--accent-amber); border:2px solid #111; border-radius:50%; box-sizing:border-box; box-shadow: 0 0 0 2px #fff, 0 2px 6px rgba(0,0,0,0.4); z-index:3; }
    .crop-rect .handle.nw { left:-6px; top:-6px; cursor:nwse-resize; }
    .crop-rect .handle.n  { left:50%; top:-6px; transform:translateX(-50%); cursor:ns-resize; }
    .crop-rect .handle.ne { right:-6px; top:-6px; cursor:nesw-resize; }
    .crop-rect .handle.e  { right:-6px; top:50%; transform:translateY(-50%); cursor:ew-resize; }
    .crop-rect .handle.se { right:-6px; bottom:-6px; cursor:nwse-resize; }
    .crop-rect .handle.s  { left:50%; bottom:-6px; transform:translateX(-50%); cursor:ns-resize; }
    .crop-rect .handle.sw { left:-6px; bottom:-6px; cursor:nesw-resize; }
    .crop-rect .handle.w  { left:-6px; top:50%; transform:translateY(-50%); cursor:ew-resize; }

    .toolbar { display:flex; gap: 8px; margin-bottom: 12px; flex-wrap: wrap; }
    .btn {
      background-color: var(--panel-bg);
      color: var(--text);
      border: 1px solid var(--border);
      padding: 8px 12px;
      border-radius: var(--radius);
      cursor: pointer;
      transition: background-color 0.2s, border-color 0.2s, filter 0.1s;
    }
    .btn:hover { filter: brightness(1.06); border-color: #4b5565; }
    .btn.btn-primary {
      background-color: var(--accent-green);
      border-color: var(--accent-green);
      color: #101216;
    }
    .btn.btn-primary:hover { background-color: #2dbb7a; }
    /* Subtelny przycisk typu ghost do nag≈Ç√≥wk√≥w paneli */
    .btn.btn-ghost { background: transparent; border-color: var(--border); color: var(--text-secondary); }
    .btn.btn-ghost:hover { background: var(--panel-bg); border-color: #4b5565; color: var(--text); }
    .btn.btn-small { padding: 6px 10px; font-size: 0.9em; border-radius: 6px; }
    /* Floating Timeline button (FAB) ‚Äì solidne t≈Ço i stany */
    .fab-proceed {
      height: 44px;
      padding: 0 14px;
      border-radius: 12px;
      border: 1px solid var(--border);
      color: #ecf1f9 !important;
      background: linear-gradient(180deg, #3a4150 0%, #2b313c 100%) !important;
      box-shadow: 0 12px 28px rgba(0,0,0,0.45);
      transition: transform 0.08s ease, box-shadow 0.2s ease, background 0.2s ease;
    }
    .fab-proceed:hover { transform: translateY(-1px); background: linear-gradient(180deg, #404759 0%, #2f3542 100%) !important; box-shadow: 0 16px 32px rgba(0,0,0,0.5); }
    .fab-proceed:active { transform: translateY(0); background: linear-gradient(180deg, #2f3542 0%, #262b35 100%) !important; box-shadow: 0 10px 20px rgba(0,0,0,0.4); }
    .fab-proceed:focus { outline: none; box-shadow: 0 0 0 3px rgba(157,125,255,0.28), 0 12px 28px rgba(0,0,0,0.45); }


    .control-group { margin-bottom: 1rem; }
    .control-group label { font-size: 0.9em; color: var(--text-secondary); }
    
    input[type="range"] { -webkit-appearance: none; appearance: none; -moz-appearance: none; width: 100%; background: transparent; height: 24px; }
    input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; height: 20px; width: 20px; border-radius: 50%; background: radial-gradient(circle at 30% 30%, #6bb8ff, var(--accent-blue)); border: 2px solid #0f141c; box-shadow: 0 0 0 2px rgba(255,255,255,0.9), 0 2px 6px rgba(0,0,0,0.35), 0 0 0 4px rgba(73,130,255,0.15); cursor: pointer; margin-top: -8px; }
    input[type="range"]:hover::-webkit-slider-thumb { box-shadow: 0 0 0 2px rgba(255,255,255,0.95), 0 2px 6px rgba(0,0,0,0.45), 0 0 0 5px rgba(73,130,255,0.25); }
    input[type="range"]:active::-webkit-slider-thumb { transform: scale(1.06); }
    input[type="range"]::-moz-range-thumb { height: 20px; width: 20px; border-radius: 50%; background: radial-gradient(circle at 30% 30%, #6bb8ff, var(--accent-blue)); border: 2px solid #0f141c; box-shadow: 0 0 0 2px rgba(255,255,255,0.9), 0 2px 6px rgba(0,0,0,0.35), 0 0 0 4px rgba(73,130,255,0.15); cursor: pointer; }
    input[type="range"]::-webkit-slider-runnable-track { width: 100%; height: 4px; cursor: pointer; background: linear-gradient(90deg, #596273, #4b5565); border-radius: 2px; }
    input[type="range"]::-moz-range-track { width: 100%; height: 4px; background: #4b5565; border-radius: 2px; }
     /* Explicit selectors for key sliders to ensure styling sticks */
     #ratio-slider::-webkit-slider-thumb, #time-slider::-webkit-slider-thumb { background: radial-gradient(circle at 30% 30%, #6bb8ff, var(--accent-blue)); border: 2px solid #0f141c; box-shadow: 0 0 0 2px rgba(255,255,255,0.9), 0 2px 6px rgba(0,0,0,0.35), 0 0 0 4px rgba(73,130,255,0.15); }
     #ratio-slider::-moz-range-thumb, #time-slider::-moz-range-thumb { background: radial-gradient(circle at 30% 30%, #6bb8ff, var(--accent-blue)); border: 2px solid #0f141c; box-shadow: 0 0 0 2px rgba(255,255,255,0.9), 0 2px 6px rgba(0,0,0,0.35), 0 0 0 4px rgba(73,130,255,0.15); }
     /* Slightly brighter track for better contrast */
     #ratio-slider::-webkit-slider-runnable-track, #time-slider::-webkit-slider-runnable-track { background: linear-gradient(90deg, #606a7b, #4b5565); }
     #ratio-slider::-moz-range-track, #time-slider::-moz-range-track { background: #606a7b; }

    #timeline-content { margin-top:12px; overflow-y:auto; }

    /* Trim UI */
    .trim-controls { display:flex; flex-direction:column; gap:6px; }
    .trim-row { display:flex; gap:8px; align-items:center; flex-wrap:nowrap; }
    .trim-label { width:68px; flex:0 0 68px; text-align:right; color: var(--text-secondary); }
    .trim-input { width:90px; padding:6px 8px; border:1px solid var(--border); border-radius:6px; background: var(--panel-bg); color: var(--text); }
    .btn.btn-small { padding:6px 10px; border-radius:6px; font-size:0.9em; }

    /* Publish card styles */
    .card-header { display:flex; justify-content:space-between; align-items:center; margin-bottom:12px; padding-bottom:10px; border-bottom:1px solid var(--border-color); }
    .card-title { font-weight:600; }
    .card-body { padding-top:8px; display:flex; flex-direction:column; gap:12px; align-items:stretch; }
    .field { display:flex; flex-direction:column; gap:6px; }
    .field-label { font-size:0.9em; color: var(--text-secondary); }
    .input { padding:8px 10px; border:1px solid var(--border); border-radius:6px; background: var(--panel-bg); color: var(--text); }
    .segmented { display:flex; gap:8px; flex-wrap:wrap; }
    .segment { display:flex; align-items:center; gap:8px; padding:8px 12px; border:1px solid var(--border); border-radius:8px; background: var(--panel-bg); cursor:pointer; }
    .segment:has(input:checked) { border-color: var(--accent-blue); box-shadow: 0 0 0 3px rgba(73,130,255,0.18); }
    .segment input { width:18px; height:18px; accent-color: var(--accent-blue); }
    .accounts-grid { display:flex; flex-wrap:wrap; gap:8px; align-items:center; }
    #pub-accounts label { padding:6px 10px; border:1px solid var(--border); border-radius:8px; background: var(--panel-bg); }
    .time-container { display:flex; gap:8px; align-items:center; }
    .tag-controls { display:flex; flex-direction:column; gap:8px; align-items:flex-start; position:relative; }
    .tag-list { display:flex; gap:6px; flex-wrap:wrap; }
    .tag { display:inline-flex; align-items:center; gap:8px; padding:4px 10px; border:1px solid var(--border); border-radius:999px; background:#2f333d; color: var(--text); }
    .tag .remove { background:transparent; border:none; color: var(--text-secondary); cursor:pointer; }
    .tag .remove:hover { color: var(--accent-red); }
    .suggest-box { position:absolute; top:100%; left:0; margin-top:4px; background: var(--panel-bg); border: 1px solid var(--border); border-radius: 8px; box-shadow: 0 10px 20px rgba(0,0,0,0.35); z-index: 1000; min-width: 220px; }
    .suggest-item { display:flex; justify-content:space-between; gap:10px; padding:8px 10px; cursor:pointer; }
    .suggest-item:hover { background:#2f333d; }
    .suggest-item .platform { color: var(--text-secondary); }
    .card-actions { display:flex; gap:8px; align-items:center; margin-top:6px; }
    .btn.btn-secondary { background-color:#3a3a3e; border-color:#666; color:#f0f0f0; }

    /* Pasek postƒôpu dla renderu/transkrypcji w Canvasie */
    .progress-bar { background: var(--border-color); height: 8px; border-radius: 4px; overflow: hidden; }
    .progress-fill { background: var(--accent-blue); width: 0%; height: 100%; transition: width 0.2s ease; }
    @keyframes progress-indeterminate {
      0%   { width: 0%; }
      50%  { width: 60%; }
      100% { width: 100%; }
    }
    .progress-fill.indeterminate { animation: progress-indeterminate 1.2s ease-in-out infinite; }

  </style>
</head>
<body>
  <div class="editor-grid">
    
    <!-- Nag≈Ç√≥wek usuniƒôty; przycisk Wr√≥ƒá i status przeniesione do panelu Inspektora -->

    <aside class="sidebar panel">
      <div class="panel-header" style="display:flex; justify-content:space-between; align-items:center;">
        <span>Biblioteka klip√≥w</span>
        <button id="btn-back" class="btn btn-small btn-ghost" type="button" title="Wr√≥ƒá do raportu">‚Ü©Ô∏è Powr√≥t</button>
      </div>
      <div style="margin-bottom:12px; display:flex; gap:6px;">
        <input id="add-url-input" type="url" placeholder="Wklej link do klipu..." style="flex:1;">
        <button id="btn-add-url" class="btn" type="button">‚ûï</button>
      </div>
      <div class="hint">Obs≈Çugiwane: Twitch, Kick</div>
      <div class="clip-list-container">
        <ul id="clip-list"></ul>
      </div>
    </aside>

    <main class="main-content panel">
      <div class="panel-header">Canvas edycji</div>
      <div class="player">
      <div class="toolbar">
          <button id="btn-load-preview" class="btn">Prewka 540p</button>
          <button id="btn-load-source" class="btn">Orygina≈Ç</button>
          <button id="btn-toggle-crop" class="btn">‚úÇÔ∏è Zaznacz</button>
          <button id="btn-save-crop" class="btn">üíæ Zapisz</button>
        </div>
        <!-- publish-card przeniesiony pod klip w canvas-wrap -->
        <div id="dl-wrap" class="panel" hidden style="margin:8px 0; padding:8px;">
          <div id="dl-text" style="margin-bottom:6px; color: var(--text-secondary);">Przygotowywanie...</div>
          <div style="background: var(--panel-border); height: 8px; border-radius: 4px; overflow: hidden;">
            <div id="dl-bar" style="background: var(--accent-blue); width: 0%; height: 100%;"></div>
          </div>
          <div id="dl-count" style="margin-top:6px; font-size: 0.9em; color: var(--text-secondary);">0/0</div>
        </div>
      <div id="canvas-status-wrap" class="panel" style="margin:8px 0; padding:8px;">
        <div id="info" class="status" style="margin-bottom:6px;">Inicjalizacja...</div>
        <div id="render-progress-bar" class="progress-bar" style="display:none;">
          <div id="render-progress-fill" class="progress-fill"></div>
        </div>
        <a id="render-link" href="#" target="_blank" style="display:none; margin-top:8px;">Pobierz wynik</a>
      </div>
         <div class="canvas-wrap">
           <video id="video" controls></video>
           <div id="overlay" class="overlay inactive">
            <div id="crop-game" class="crop-rect crop-game" hidden>
              <div class="handle nw"></div>
              <div class="handle n"></div>
              <div class="handle ne"></div>
              <div class="handle e"></div>
              <div class="handle se"></div>
              <div class="handle s"></div>
              <div class="handle sw"></div>
              <div class="handle w"></div>
            </div>
            <div id="crop-camera" class="crop-rect crop-camera" hidden>
              <div class="handle nw"></div>
              <div class="handle n"></div>
              <div class="handle ne"></div>
              <div class="handle e"></div>
              <div class="handle se"></div>
              <div class="handle s"></div>
              <div class="handle sw"></div>
              <div class="handle w"></div>
            </div>
           </div>
         </div>
         <div id="publish-card" class="card panel" style="margin:12px 0;">
           <div class="card-header">
             <div class="card-title">Publikacja</div>
             <button id="btn-publish" class="btn btn-primary" type="button" disabled>üì£ Opublikuj‚Ä¶</button>
           </div>
           <div id="publish-panel" class="card-body" style="display:none;">
             <div class="field">
               <div class="field-label">Tryb publikacji</div>
               <div class="segmented">
                 <label class="segment">
                   <input type="radio" name="publish_mode" id="pub-now" value="now">
                   <span>Teraz</span>
                 </label>
                 <label class="segment">
                   <input type="radio" name="publish_mode" id="pub-internal" value="internal" checked>
                   <span>Wewnƒôtrznie</span>
                 </label>
                 <label class="segment">
                   <input type="radio" name="publish_mode" id="pub-sched" value="schedule">
                   <span>Publer</span>
                 </label>
               </div>
             </div>

             <div class="field">
               <div class="field-label">Konta</div>
               <div id="pub-accounts" class="accounts-grid">
                 <span id="pub-accounts-loading" class="hint">≈Åadowanie kont‚Ä¶</span>
               </div>
             </div>

             <div class="field">
               <div class="field-label">Czas publikacji</div>
               <div id="pub-time-container" class="time-container" style="display:none;">
                 <input type="date" id="pub-date" class="input" />
                 <select id="pub-time-slot" class="input">
                   <option value="">Wybierz godzinƒô...</option>
                 </select>
               </div>
             </div>

             <div class="field">
               <div class="field-label">Podpis</div>
               <input type="text" id="pub-caption" class="input" placeholder="Podpis posta (opcjonalny)" />
             </div>

             <div class="field">
               <div class="field-label">Tagi</div>
               <div class="tag-controls">
                 <input type="text" id="pub-tag-groups" class="input" placeholder="Grupy tag√≥w (np. twitch, merghani)" />
                 <div id="pub-tag-groups-suggest" class="suggest-box" style="display:none;"></div>
                 <div id="pub-tag-groups-selected" class="tag-list"></div>
               </div>
             </div>

             <div class="card-actions">
               <button id="btn-publish-confirm" class="btn btn-primary" type="button">Wy≈õlij</button>
               <span id="publish-status" class="hint"></span>
             </div>
           </div>
         </div>
      </div>
    </main>

    <aside class="inspector panel">
      <div class="panel-header" style="display:flex; align-items:center; gap:8px;">
        <span>Inspektor & PodglƒÖd</span>
      </div>
      
      <div class="control-group">
        <div style="font-weight:600; margin-bottom:6px;">PodglƒÖd 9:16</div>
        <canvas id="final-preview" width="270" height="480" style="background:#000; border:1px solid #555; border-radius:6px; display:block; width:100%;"></canvas>
      </div>

      <div class="control-group">
        <div style="font-weight:600; margin-top:16px; margin-bottom:6px;">Ustawienia kadrowania</div>
        <div class="ratio-control">
          <label for="ratio-slider">Podzia≈Ç V:</label>
          <input type="range" id="ratio-slider" class="ratio-slider" min="20" max="80" value="70" step="5">
          <span id="ratio-display">70%</span>
        </div>
        <div class="snap-control"><label><input type="checkbox" id="auto-split-toggle"> Auto podzia≈Ç</label></div>
        <div class="snap-control"><label><input type="checkbox" id="single-frame-toggle"> Tryb 1 kadru</label></div>
        <div id="single-frame-controls" style="display:none;">
          <label for="single-height-slider">Wysoko≈õƒá:</label> <input type="range" id="single-height-slider" min="10" max="100" value="40" step="5"> <span id="single-height-display">40%</span>
        </div>
      </div>

       <div class="control-group">
        <div style="font-weight:600; margin-top:16px; margin-bottom:6px;">Trim</div>
        <div class="timebar"><span class="time-label" id="time-label">0:00 / 0:00</span><input id="time-slider" type="range" min="0" value="0" step="0.01"></div>
        <div class="trim-controls">
          <div class="trim-row">
            <span class="trim-label">Start</span>
            <input id="trim-start" type="number" step="0.01" min="0" class="trim-input">
            <button id="btn-set-start" class="btn btn-small" type="button">Ustaw</button>
          </div>
          <div class="trim-row">
            <span class="trim-label">Koniec</span>
            <input id="trim-end" type="number" step="0.01" min="0" class="trim-input">
            <button id="btn-set-end" class="btn btn-small" type="button">Ustaw</button>
          </div>
        </div>
      </div>
      
      <div class="control-group" style="margin-top:auto; padding-top:16px; border-top: 1px solid var(--border-color);">
        <div style="display:flex; gap:8px; align-items:center; margin-bottom:8px;">
          <button id="btn-transcribe" class="btn" type="button" style="flex:1">üìù Transkrybuj</button>
          <span id="srt-status" class="hint"></span>
          <a id="srt-link" href="#" target="_blank" style="display:none;">SRT</a>
        </div>
        <label class="nice-checkbox">
          <input type="checkbox" id="include-subtitles" disabled>
          <span>Do≈ÇƒÖcz napisy (po transkrypcji)</span>
        </label>
        <button id="btn-render" class="btn btn-primary" type="button" style="width:100%; margin-top:8px;">üé¨ Renderuj</button>
        <button id="btn-remove-rendered" class="btn" type="button" style="display:none; margin-top:6px; background:#e74c3c; color:white;">üóëÔ∏è Usu≈Ñ wyrenderowany</button>
      </div>
    </aside>

    <script>
      (function(){
        try{
          if (typeof window.selectClip !== 'function'){
            window.selectClip = function(){ console.warn('selectClip placeholder: not ready yet'); };
          }
        }catch{}
        const trimStart = document.getElementById('trim-start');
        const trimEnd = document.getElementById('trim-end');
        const timeSlider = document.getElementById('time-slider');
        const timeLabel = document.getElementById('time-label');
        const btnSetStart = document.getElementById('btn-set-start');
        const btnSetEnd = document.getElementById('btn-set-end');
        const btnRender = document.getElementById('btn-render');
        const btnTranscribe = document.getElementById('btn-transcribe');
        const includeSubtitlesEl = document.getElementById('include-subtitles');
        const srtStatus = document.getElementById('srt-status');
        const srtLink = document.getElementById('srt-link');
        const renderLink = document.getElementById('render-link');
        const btnRemoveRendered = document.getElementById('btn-remove-rendered');

        let shouldIncludeSubtitles = false; // domy≈õlnie bez napis√≥w; po transkrypcji w≈ÇƒÖczamy
        includeSubtitlesEl.disabled = true;
        includeSubtitlesEl.checked = false;
        includeSubtitlesEl.addEventListener('change', ()=>{ shouldIncludeSubtitles = !!includeSubtitlesEl.checked; });

        function fmt(t){ const m = Math.floor((t||0)/60); const s = Math.floor((t||0)%60).toString().padStart(2,'0'); return `${m}:${s}`; }
        function updateTimeUi(){ if (!video) return; if (timeSlider){ timeSlider.max = video.duration||0; timeSlider.value = video.currentTime||0; } if (timeLabel){ timeLabel.textContent = `${fmt(video.currentTime||0)} / ${fmt(video.duration||0)}`; } }
        if (video){
          video.addEventListener('loadedmetadata', updateTimeUi);
          video.addEventListener('timeupdate', updateTimeUi);
        }
        if (timeSlider){ timeSlider.addEventListener('input', ()=>{ if (video) video.currentTime = parseFloat(timeSlider.value||'0')||0; }); }
        if (btnSetStart){ btnSetStart.addEventListener('click', ()=>{ if (video && trimStart) trimStart.value = (video.currentTime||0).toFixed(2); }); }
        if (btnSetEnd){ btnSetEnd.addEventListener('click', ()=>{ if (video && trimEnd) trimEnd.value = (video.currentTime||0).toFixed(2); }); }

        function resetSrtUi(){ if (srtStatus) srtStatus.textContent=''; if (srtLink){ srtLink.style.display='none'; srtLink.href='#'; } includeSubtitlesEl.disabled = true; includeSubtitlesEl.checked = false; shouldIncludeSubtitles = false; }
        async function pollTranscribe(clip_id){
          try{
            const r = await fetch(`/api/transcribe/status?clip_id=${encodeURIComponent(clip_id)}`, { cache:'no-store' });
            if (!r.ok) throw new Error('status failed');
            const j = await r.json();
            if (j.state==='done' && j.url){ if (srtStatus) srtStatus.textContent='Gotowe'; if (srtLink){ srtLink.href=j.url; srtLink.style.display='inline-block'; } includeSubtitlesEl.disabled=false; includeSubtitlesEl.checked=true; shouldIncludeSubtitles=true; return true; }
            if (j.state==='error'){ if (srtStatus) srtStatus.textContent='B≈ÇƒÖd: ' + (j.error||''); return true; }
            if (j.state==='running'){ if (srtStatus) srtStatus.textContent='Trwa transkrypcja...'; return false; }
          }catch(e){ /* ignore transient */ }
          return false;
        }
        async function startTranscribe(){
          if (!window.active){ alert('Najpierw wybierz klip.'); return; }
          resetSrtUi(); if (srtStatus) srtStatus.textContent='Uruchamianie...';
          try{
            const r = await fetch('/api/transcribe', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ clip_id: window.active.clip_id }) });
            const j = await r.json();
            if (!r.ok || j.ok===false){ if (srtStatus) srtStatus.textContent = 'B≈ÇƒÖd: ' + (j.error||''); return; }
            if (j.state==='done' && j.url){ if (srtStatus) srtStatus.textContent='Gotowe'; if (srtLink){ srtLink.href=j.url; srtLink.style.display='inline-block'; } includeSubtitlesEl.disabled=false; includeSubtitlesEl.checked=true; shouldIncludeSubtitles=true; return; }
            if (srtStatus) srtStatus.textContent='Trwa transkrypcja...';
            let done=false; while(!done){ done = await pollTranscribe(window.active.clip_id); if (!done) await new Promise(res=>setTimeout(res,1500)); }
          }catch(e){ if (srtStatus) srtStatus.textContent='B≈ÇƒÖd: ' + e.message; }
        }
        if (btnTranscribe) btnTranscribe.addEventListener('click', startTranscribe);
        // Usuniƒôto wrapper selectClip (reset SRT wykonujemy w obs≈Çudze selectClip poni≈ºej)


        function makeRenderPayload(){
          if (!window.active) return null;
          let start = parseFloat(trimStart?.value||'');
          let end = parseFloat(trimEnd?.value||'');
          const startNum = isFinite(start) ? start : null;
          const endNum = isFinite(end) ? end : null;
          return {
            clip_id: window.active.clip_id,
            start: startNum,
            end: endNum,
            include_subtitles: shouldIncludeSubtitles,
            game: state.gameRect,
            camera: state.singleFrame ? null : state.cameraRect,
            game_ratio: state.gameRatio,
            auto_split: !!state.autoSplit,
            single_frame: !!state.singleFrame,
            single_height_ratio: state.singleHeightRatio,
            fit_mode: 'cover'
          };
        }
        async function pollRenderUntilFinish(clip_id){
          try{
            const r = await fetch(`/api/render/status?clip_id=${encodeURIComponent(clip_id)}&verbose=1`, { cache:'no-store' });
            const j = await r.json();
            if (j.state==='done' && j.url){ if (renderLink){ const bustUrl = j.url + (j.url.includes('?')?'&':'?') + 'v=' + Date.now(); renderLink.href=bustUrl; renderLink.style.display='inline-block'; } if (btnRemoveRendered) btnRemoveRendered.style.display='inline-block'; const btnPublish = document.getElementById('btn-publish'); if (btnPublish){ btnPublish.style.display='inline-block'; btnPublish.disabled=false; } setInfo('Render zako≈Ñczony.'); if (renderProgressBar) renderProgressBar.style.display='none'; if (renderProgressFill){ renderProgressFill.classList.remove('indeterminate'); renderProgressFill.style.width='100%'; } return true; }
            if (j.state==='error'){ setInfo('B≈ÇƒÖd renderu: ' + (j.error||''), true); if (renderProgressBar) renderProgressBar.style.display='none'; if (renderProgressFill){ renderProgressFill.classList.remove('indeterminate'); renderProgressFill.style.width='0%'; } return true; }
            // w trakcie ‚Äì pasek postƒôpu: indeterminate domy≈õlnie; procenty tylko je≈õli backend je zwraca
            if (renderProgressBar) renderProgressBar.style.display='block';
            if (renderProgressFill){
              let pct = null;
              if (typeof j.pct === 'number'){ pct = j.pct; }
              else if (typeof j.done === 'number' && typeof j.total === 'number' && j.total>0){ pct = (j.done/j.total)*100; }
              if (pct != null){ renderProgressFill.classList.remove('indeterminate'); renderProgressFill.style.width = Math.max(0, Math.min(100, Math.round(pct))) + '%'; }
              else { renderProgressFill.classList.add('indeterminate'); }
            }
            return false;
          }catch(e){ if (renderProgressBar) renderProgressBar.style.display='none'; if (renderProgressFill){ renderProgressFill.classList.remove('indeterminate'); renderProgressFill.style.width='0%'; } return false; }
        }
        async function performRender(payload){
          if (!payload){ alert('Brak parametr√≥w renderu.'); return; }
          setInfo('Renderujƒô...');
          if (renderProgressBar) { renderProgressBar.style.display='block'; }
          if (renderProgressFill){ renderProgressFill.classList.add('indeterminate'); renderProgressFill.style.width='0%'; }
          try{
            const r = await fetch('/api/render', { method:'POST', headers:{'Content-Type':'application/json'}, cache:'no-store', body: JSON.stringify(payload)});
            let j; try{ j = await r.json(); }catch(parseErr){ const txt = await r.text().catch(()=> ''); j = { ok:false, status:r.status, content_type:(r.headers && r.headers.get ? r.headers.get('content-type') : undefined), text_snippet:(txt||'').slice(0,400) }; }
            if (!j.ok){
              setInfo('B≈ÇƒÖd renderu: ' + (j.error||''), true);
              const isEdgeTimeout = (String(j.status)==='524' || String(j.status)==='504' || (j.content_type||'').includes('text/html'));
              if (isEdgeTimeout && window.active?.clip_id){ setInfo('Render w tle ‚Äî sprawdzam status‚Ä¶'); let done=false; while(!done){ done = await pollRenderUntilFinish(window.active.clip_id); if (!done) await new Promise(res=>setTimeout(res,1500)); } }
              if (renderProgressBar) renderProgressBar.style.display='none';
              if (renderProgressFill){ renderProgressFill.classList.remove('indeterminate'); renderProgressFill.style.width='0%'; }
              return;
            }
            // Po uruchomieniu renderowania ‚Äî odpytywanie statusu a≈º do zako≈Ñczenia
            try {
              let done = false;
              while (!done) {
                done = await pollRenderUntilFinish(window.active?.clip_id || payload.clip_id || (window.active && window.active.clip_id));
                if (!done) await new Promise(res=>setTimeout(res, 1500));
              }
            } catch (pollErr) {
              console.warn('pollRenderUntilFinish error:', pollErr);
            }
            setInfo('Render zako≈Ñczony.');
            if (renderProgressBar) renderProgressBar.style.display='none';
            if (renderProgressFill){ renderProgressFill.classList.remove('indeterminate'); renderProgressFill.style.width='100%'; }
          }catch(e){ setInfo('B≈ÇƒÖd renderu: ' + e.message, true); if (renderProgressBar) renderProgressBar.style.display='none'; if (renderProgressFill){ renderProgressFill.classList.remove('indeterminate'); renderProgressFill.style.width='0%'; } }
        }
        if (btnRender){ btnRender.addEventListener('click', async ()=>{
          if (!window.active){ alert('Najpierw wybierz klip.'); return; }
          if (!state.gameRect || (!state.singleFrame && !state.cameraRect)){ alert('Najpierw zaznacz wymagane kadry.'); return; }
          await performRender(makeRenderPayload());
        }); }
        if (btnRemoveRendered){ btnRemoveRendered.addEventListener('click', async ()=>{
          if (!window.active?.clip_id){ alert('Brak aktywnego klipu do usuniƒôcia.'); return; }
          btnRemoveRendered.disabled=true; setInfo('Usuwam wyrenderowany klip...');
          try{
            const r = await fetch('/api/remove-rendered-clip', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ clip_id: window.active.clip_id }) });
            const j = await r.json();
            if (!r.ok || !j.ok){ setInfo('Nie uda≈Ço siƒô usunƒÖƒá wyrenderowanego klipu: ' + (j.error || r.statusText), true); return; }
            if (renderLink) renderLink.style.display='none'; btnRemoveRendered.style.display='none'; setInfo('Usuniƒôto wyrenderowany klip.');
          }catch(e){ setInfo('B≈ÇƒÖd usuwania wyrenderowanego klipu: ' + e.message, true); }
          finally{ btnRemoveRendered.disabled=false; }
        }); }
      })();
    </script>

    <div class="timeline-container panel" style="background-color: var(--panel-bg); opacity: 1; backdrop-filter: none;">
       <div class="panel-header" style="display: flex; justify-content: space-between; align-items: center;">
        <span>Timeline post√≥w</span>
        <button id="btn-refresh-timeline" class="btn btn-small" type="button">üîÑ</button>
        <button id="btn-reset-failed" class="btn btn-small btn-secondary" type="button">‚ôªÔ∏è Resetuj nieudane</button>
      </div>
       <div class="timeline-filters" style="display:flex; gap:12px; align-items:center; flex-wrap:wrap; font-size: 0.9em; margin-bottom: 12px;">
          <label><input type="checkbox" id="filter-scheduled" checked> Zaplanowane</label>
          <label><input type="checkbox" id="filter-published" checked> Opublikowane</label>
          <label><input type="checkbox" id="filter-failed"> Nieudane</label>
          <label style="margin-left:auto; display:flex; align-items:center; gap:6px;">
            Zakres:
            <select id="timeline-range">
              <option value="48h" selected>48h</option>
              <option value="24h">24h</option>
              <option value="7d">7 dni</option>
              <option value="all">Wszystkie</option>
            </select>
          </label>
        </div>
      <div id="timeline-content">≈Åadowanie...</div>
    </div>
  </div>

  <script id="clips-data" type="application/json">{{ clips | tojson }}</script>
  <button id="btn-toggle-timeline" class="btn fab-proceed" title="Poka≈º/Otw√≥rz timeline">üóìÔ∏è Timeline</button>
 
  <script>
    // Wr√≥ƒá bez pe≈Çnego prze≈Çadowania
    const btnBack = document.getElementById('btn-back');
    if (btnBack) {
      btnBack.addEventListener('click', (e) => {
        e.preventDefault();
        if (history.length > 1) history.back();
        else window.location.assign('/');
      });
    }

    let info = document.getElementById('info');
    let listEl = document.getElementById('clip-list');
    let video = document.getElementById('video');
    let cropGameEl = document.getElementById('crop-game');
    let cropCameraEl = document.getElementById('crop-camera');
    let ratioSlider = document.getElementById('ratio-slider');
    let ratioDisplay = document.getElementById('ratio-display');
    let autoSplitToggle = document.getElementById('auto-split-toggle');
    let cropHint = document.getElementById('crop-hint');
    let dlWrap = document.getElementById('dl-wrap') || { hidden: true };
    let dlBar = document.getElementById('dl-bar') || { style: { width: '' } };
    let dlText = document.getElementById('dl-text') || { textContent: '' };
    let dlCount = document.getElementById('dl-count') || { textContent: '' };
    let renderProgressBar = document.getElementById('render-progress-bar') || null;
    let renderProgressFill = document.getElementById('render-progress-fill') || null;
    let overlay = document.getElementById('overlay');
    let singleToggle = document.getElementById('single-frame-toggle');
    let singleHeightSlider = document.getElementById('single-height-slider');
    let singleHeightDisplay = document.getElementById('single-height-display');

    // Re-resolve element refs after DOM is parsed
    document.addEventListener('DOMContentLoaded', () => {
      info = document.getElementById('info');
      listEl = document.getElementById('clip-list');
      video = document.getElementById('video');
      cropGameEl = document.getElementById('crop-game');
      cropCameraEl = document.getElementById('crop-camera');
      ratioSlider = document.getElementById('ratio-slider');
      ratioDisplay = document.getElementById('ratio-display');
      autoSplitToggle = document.getElementById('auto-split-toggle');
      cropHint = document.getElementById('crop-hint');
      dlWrap = document.getElementById('dl-wrap') || dlWrap;
      dlBar = document.getElementById('dl-bar') || dlBar;
      dlText = document.getElementById('dl-text') || dlText;
      dlCount = document.getElementById('dl-count') || dlCount;
      renderProgressBar = document.getElementById('render-progress-bar') || renderProgressBar;
      renderProgressFill = document.getElementById('render-progress-fill') || renderProgressFill;
      overlay = document.getElementById('overlay');
      singleToggle = document.getElementById('single-frame-toggle');
      singleHeightSlider = document.getElementById('single-height-slider');
      singleHeightDisplay = document.getElementById('single-height-display');
    });

    
    // --- Stan edytora (tryb dw√≥ch kadr√≥w oraz jednego kadru) ---
    const state = { 
      gameRect: null,    // {x,y,w,h} w [0..1]
      cameraRect: null,  // {x,y,w,h} w [0..1]
      gameRatio: 0.7,    // 70% wysoko≈õci dla gry
      validAspect: true, // czy aktualne kadry dajƒÖ 9:16
      dragging: null,    // 'game' | 'camera' | null
      autoSplit: false,  // gdy true ‚Äì wysoko≈õci sekcji liczymy z aspekt√≥w zaznacze≈Ñ
      singleFrame: false,
      singleHeightRatio: 0.4,
      hideViewed: true
    };

    // Persistencja obejrzanych klip√≥w
    let viewedSet = new Set();
    try { viewedSet = new Set(JSON.parse(localStorage.getItem('viewedClips')||'[]').filter(x=>typeof x==='string')); } catch(e){ viewedSet = new Set(); }
    try { state.hideViewed = JSON.parse(localStorage.getItem('hideViewed')||'true'); } catch(e){ /* keep default */ }

    function markViewed(id){
      if (!id) return;
      if (!viewedSet.has(id)){
        viewedSet.add(id);
        try { localStorage.setItem('viewedClips', JSON.stringify(Array.from(viewedSet))); } catch(e){}
      }
    }
    
    // Suwak podzia≈Çu pionowego
    if (ratioSlider) {
      ratioSlider.addEventListener('input', ()=>{
        state.gameRatio = parseInt(ratioSlider.value) / 100;
        const cameraRatio = 1 - state.gameRatio;
        ratioDisplay.textContent = `${Math.round(state.gameRatio*100)}% gra / ${Math.round(cameraRatio*100)}% kamerka`;
        // po zmianie podzia≈Çu przelicz oba kadry, aby zachowaƒá nowe proporcje
        validateAndUpdateVisuals();
      });
    }

    if (autoSplitToggle){
      autoSplitToggle.addEventListener('change', ()=>{
        state.autoSplit = !!autoSplitToggle.checked;
        const controls = document.querySelector('.ratio-control');
        if (controls) controls.style.opacity = state.autoSplit ? '0.5' : '1';
        if (ratioSlider) ratioSlider.disabled = state.autoSplit;
        validateAndUpdateVisuals();
      });
    }
    if (singleToggle){
      singleToggle.addEventListener('change', ()=>{
        state.singleFrame = !!singleToggle.checked;
        const controls = document.getElementById('single-frame-controls');
        if (controls) controls.style.display = state.singleFrame ? 'inline-flex' : 'none';
        validateAndUpdateVisuals();
      });
    }
    if (singleHeightSlider){
      singleHeightSlider.addEventListener('input', ()=>{
        state.singleHeightRatio = parseInt(singleHeightSlider.value)/100;
        if (singleHeightDisplay) singleHeightDisplay.textContent = `${Math.round(state.singleHeightRatio*100)}%`;
        validateAndUpdateVisuals();
      });
    }
    
   // --- Stan edytora ---
   let clips = [];
   try {
     const el = document.getElementById('clips-data');
     const raw = el ? el.textContent : '';
     clips = JSON.parse(raw || '[]');
   } catch (e) {
     console.error('Failed to parse clips-data:', e);
     setInfo('B≈ÇƒÖd danych klip√≥w: ' + (e.message || e), true);
     clips = [];
   }
   let active = null; // {clip_id, url, broadcaster, title}
   let cropping = false;
   let dragStart = null; // {x,y}
   function setInfo(msg, isError=false){
     info.textContent = msg;
     info.classList.toggle('error', !!isError);
   }
 
     function clipIdFromUrl(url){
       try {
         const u = new URL(url);
         let last = u.pathname.split('/').filter(Boolean).pop() || 'clip';
         last = last.split('?')[0];
         return last.replace(/[^a-zA-Z0-9_-]/g, '') || 'clip';
       } catch(e) { return 'clip'; }
     }
 
     function renderList(){
      listEl.innerHTML = '';
      let newCount = 0;
      (clips || []).forEach((c)=>{
        const id = clipIdFromUrl(c.url);
        const isViewed = viewedSet.has(id);
        const isNew = !isViewed;
        if (isNew) newCount++;
        const shouldHide = state.hideViewed && isViewed && (!active || active.clip_id !== id);
        if (shouldHide) return;
        const li = document.createElement('li');
        li.className = 'clip-item' + (active && active.url===c.url ? ' active' : '');
        li.title = c.url;
        
        // Kontener dla tre≈õci klipu
        const contentDiv = document.createElement('div');
        contentDiv.style.display = 'flex';
        contentDiv.style.justifyContent = 'space-between';
        contentDiv.style.alignItems = 'center';
        contentDiv.style.width = '100%';
        
        // Lewa strona - tytu≈Ç i badge
        const leftDiv = document.createElement('div');
        leftDiv.style.flex = '1';
        leftDiv.style.cursor = 'pointer';
        leftDiv.addEventListener('click', ()=>{
          try{
            if (typeof window.selectClip === 'function'){ window.selectClip(c); }
        else { console.warn('selectClip nie jest jeszcze dostƒôpny'); }
      }catch(e){ console.warn('selectClip error:', e); }
        });
        
        const base = document.createElement('span');
        base.textContent = `${c.broadcaster} - ${c.title}`;
        leftDiv.appendChild(base);
        
        if (isNew){
          const badge = document.createElement('span');
          badge.textContent = ' NOWE';
          badge.style.color = '#0a0';
          badge.style.fontWeight = '600';
          badge.style.marginLeft = '6px';
          leftDiv.appendChild(badge);
        }
        
        // Prawa strona - przycisk usuwania
        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = 'üóëÔ∏è';
        deleteBtn.title = 'Usu≈Ñ klip z listy';
        deleteBtn.style.background = 'none';
        deleteBtn.style.border = 'none';
        deleteBtn.style.cursor = 'pointer';
        deleteBtn.style.padding = '4px';
        deleteBtn.style.fontSize = '14px';
        deleteBtn.style.opacity = '0.7';
        deleteBtn.addEventListener('mouseenter', ()=>{ deleteBtn.style.opacity = '1'; });
        deleteBtn.addEventListener('mouseleave', ()=>{ deleteBtn.style.opacity = '0.7'; });
        deleteBtn.addEventListener('click', (e)=>{
          e.stopPropagation();
          removeClipFromList(c);
        });
        
        contentDiv.appendChild(leftDiv);
        contentDiv.appendChild(deleteBtn);
        li.appendChild(contentDiv);
        listEl.appendChild(li);
      });

    }

    // Usuwanie klipu z listy
    async function removeClipFromList(clip) {
      setInfo('Usuwam klip z listy...');
      try {
        const r = await fetch('/api/remove-clip-from-list', {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify({ url: clip.url })
        });
        const j = await r.json();
        
        if (!r.ok || !j.ok) {
          setInfo('Nie uda≈Ço siƒô usunƒÖƒá klipu: ' + (j.error || r.statusText), true);
          return;
        }
        
        // Usu≈Ñ z lokalnej listy
        clips = clips.filter(c => c.url !== clip.url);
        
        // Usu≈Ñ z zapisanych klip√≥w (localStorage)
        try {
          const savedClips = JSON.parse(localStorage.getItem('savedClips') || '[]');
          const filteredSaved = savedClips.filter(c => c.url !== clip.url);
          localStorage.setItem('savedClips', JSON.stringify(filteredSaved));
        } catch (e) {
          console.warn('Nie uda≈Ço siƒô usunƒÖƒá z zapisanych klip√≥w:', e);
        }
        
        // Je≈õli usuwany klip by≈Ç aktywny, wyczy≈õƒá aktywny klip
        if (active && active.url === clip.url) {
          active = null;
          window.active = null;
          // Wyczy≈õƒá video
          const video = document.getElementById('video');
          if (video) {
            video.src = '';
            video.load();
          }
        }
        
        renderList();
        setInfo(`Usuniƒôto klip z listy i z ulubionych. Pozosta≈Ço: ${j.remaining_count} klip√≥w.`);
        
      } catch (e) {
        setInfo('B≈ÇƒÖd usuwania klipu: ' + e.message, true);
      }
    }

    // Dodawanie klipu po URL
    (function(){
      const input = document.getElementById('add-url-input');
      const btn = document.getElementById('btn-add-url');
      if (!input || !btn) return;
      async function add(){
        const url = (input.value || '').trim();
        if (!url) { setInfo('Podaj URL klipu.', true); return; }
        setInfo('Dodajƒô klip po URL...');
        try{
          const r = await fetch('/api/add-clip-by-url', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ url }) });
          const j = await r.json();
          if (!r.ok || !j.ok){ setInfo('Nie uda≈Ço siƒô dodaƒá klipu: ' + (j.error || r.statusText), true); return; }
          const clip = j.clip;
          clips = (clips || []).filter(c=>c.url !== clip.url);
          clips.push(clip);
          renderList();
          if (typeof window.selectClip === 'function'){ window.selectClip(clip); }
          setInfo('Dodano klip.');
          try { await maybeStartEnsureCacheImmediate(); } catch(_) {}
        }catch(e){ setInfo('B≈ÇƒÖd dodawania klipu: ' + e.message, true); }
      }
      btn.addEventListener('click', add);
      input.addEventListener('keydown', (ev)=>{ if (ev.key === 'Enter') add(); });
    })();
 
    async function selectClip(c){
       active = { ...c, clip_id: clipIdFromUrl(c.url) };
       window.active = active;
       markViewed(active.clip_id);
       renderList();
       fetch(`/api/crop/${active.clip_id}`).then(r=>r.json()).then(j=>{
         state.gameRect = j.game || null;
         state.cameraRect = j.camera || null;
         updateBothVisuals();
       }).catch(()=>{});
       // Preflight: sprawd≈∫ czy pliki istniejƒÖ; je≈õli nie, uruchom ensure-cache asynchronicznie i polluj dostƒôpno≈õƒá bie≈ºƒÖcego klipu
       try {
         const headPrev = await fetch(`/media/previews/${active.clip_id}.mp4`, { method: 'HEAD', cache: 'no-store' });
         const headOrig = await fetch(`/media/clips/${active.clip_id}.mp4`, { method: 'HEAD', cache: 'no-store' });
         if (!headPrev.ok && !headOrig.ok) {
           showPanel('progress');
           if (dlText) dlText.textContent = 'Pobieranie brakujƒÖcych plik√≥w...';
           if (dlBar) dlBar.style.width = '0%';
           // Start ensure-cache w tle
           try { ensureCacheWithProgress(clips.length); } catch(_) {}
           // Polluj a≈º jeden z plik√≥w stanie siƒô dostƒôpny i od razu za≈Çaduj
           (async function pollOne(clip_id){
             const maxAttempts = 120;
             for (let i=0;i<maxAttempts;i++){
               try{
                 const p = await fetch(`/media/previews/${clip_id}.mp4`, { method: 'HEAD', cache: 'no-store' });
                 if (p.ok){ setVideo(`/media/previews/${clip_id}.mp4?v=${Date.now()}`); break; }
                 const o = await fetch(`/media/clips/${clip_id}.mp4`, { method: 'HEAD', cache: 'no-store' });
                 if (o.ok){ setVideo(`/media/clips/${clip_id}.mp4?v=${Date.now()}`); break; }
               }catch{}
               await new Promise(res=>setTimeout(res, 1000));
             }
           })(active.clip_id);
         }
       } catch (e) { /* ignore */ }
       tryAutoLoadActive();
       if (video) video.addEventListener('loadedmetadata', updateBothVisuals, { once: true });
     }
 
     function setVideo(src){
       if (!video) return;
       try {
         video.pause();
         // Wyczy≈õƒá poprzedni strumie≈Ñ, aby uniknƒÖƒá czarnego ekranu
         video.src = '';
         video.load();
       } catch(e) {}
       // U≈Çatw autoodtwarzanie i odtwarzanie inline
       video.muted = true;
       video.playsInline = true;
       // Ustaw nowe ≈∫r√≥d≈Ço i pe≈Çny reset czasu
       video.src = src;
       try { video.load(); } catch(e) {}
       try { video.currentTime = 0; } catch(e) {}
       // Zaczekaj na mo≈ºliwo≈õƒá odtwarzania, potem spr√≥buj play
       const onCanPlay = ()=>{
         video.removeEventListener('canplay', onCanPlay);
         video.play().catch(()=>{});
       };
       video.addEventListener('canplay', onCanPlay, { once: true });
       // Dodatkowa pr√≥ba odtwarzania ‚Äì w razie szybkiego canplay
       video.play().catch(()=>{});
     }
 
     function tryAutoLoadActive(){
      if (!active) return;
      // Nie blokuj auto-≈Çadowania nawet gdy pasek ensure-cache jest widoczny ‚Äì pr√≥buj od razu
      const previewUrl = `/media/previews/${active.clip_id}.mp4?v=${Date.now()}`;
      const origUrl = `/media/clips/${active.clip_id}.mp4?v=${Date.now()}`;
      const onErrorOnce = ()=>{
        video.removeEventListener('error', onErrorOnce);
        // fallback do orygina≈Çu
        setVideo(origUrl);
        const onErr2 = ()=>{
          video.removeEventListener('error', onErr2);
          setInfo('Nie uda≈Ço siƒô za≈Çadowaƒá pliku wideo (prewka ani orygina≈Ç).', true);
        };
        if (video) video.addEventListener('error', onErr2, { once: true });
      };
      if (video) video.addEventListener('error', onErrorOnce, { once: true });
      setVideo(previewUrl);
    }
 
   // Przyciski wyboru √Ö¬∫r√Ö¬≥≈Ça odtwarzania
      const btnPrev = document.getElementById('btn-load-preview');
      const btnSrc = document.getElementById('btn-load-source');
      if (btnPrev) btnPrev.addEventListener('click', ()=>{
        if (!active) { alert('Najpierw wybierz klip.'); return; }
        const url = `/media/previews/${active.clip_id}.mp4?v=${Date.now()}`;
        setVideo(url);
      });
      if (btnSrc) btnSrc.addEventListener('click', ()=>{
        if (!active) { alert('Najpierw wybierz klip.'); return; }
        const url = `/media/clips/${active.clip_id}.mp4?v=${Date.now()}`;
        setVideo(url);
      });
 
      // Geometria wy√Ö‚Ä∫wietlania (bez letterbox)
     function getDisplayBox(){
       const o = overlay.getBoundingClientRect();
       const vw = video.videoWidth || o.width;
       const vh = video.videoHeight || o.height;
       const scale = Math.min(o.width / vw, o.height / vh);
       const dw = vw * scale;
       const dh = vh * scale;
       const offX = (o.width - dw) / 2;
       const offY = (o.height - dh) / 2;
       return { w:o.width, h:o.height, offX, offY, dw, dh };
     }
     function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }
     function eventToNorm(e){
       const o = overlay.getBoundingClientRect();
       const p = getDisplayBox();
       const x = clamp(e.clientX - o.left - p.offX, 0, p.dw);
       const y = clamp(e.clientY - o.top - p.offY, 0, p.dh);
       return { x: (x / p.dw), y: (y / p.dh) };
     }
     function desiredAspects(){
       const g = state.gameRatio;
       const c = 1 - g;
       // aspect = width/height w uk≈Çadzie pionowym 9:16
       return { game: 9 / (16 * g), camera: 9 / (16 * c) };
     }
     function enforceAspect(start, current, which){
       const asp = desiredAspects()[which];
       const x0 = clamp(start.x, 0, 1), y0 = clamp(start.y, 0, 1);
       let left = Math.min(x0, current.x), top = Math.min(y0, current.y);
       let w = Math.abs(current.x - x0), h = Math.abs(current.y - y0);
       if (w === 0 && h === 0) return { x:left, y:top, w:0, h:0 };
       if (w / h > asp) { w = h * asp; } else { h = w / asp; }
       if (left + w > 1) w = 1 - left;
       if (top + h > 1) h = 1 - top;
       return { x:left, y:top, w, h };
     }
     function fitAspectAroundCenter(rect, which){
       if (!rect) return rect;
       const asp = desiredAspects()[which];
       // zachowaj ≈õrodek
       let cx = rect.x + rect.w/2, cy = rect.y + rect.h/2;
       // dobierz w/h najbli≈ºsze bie≈ºƒÖcym, ale zgodne z aspectem
       let h = Math.min(rect.h, rect.w / asp);
       let w = asp * h;
       if (w === 0 || h === 0) { w = Math.max(0.02, asp*0.02); h = Math.max(0.02, 0.02); }
       // upewnij siƒô, ≈ºe mie≈õci siƒô w granicach przy sta≈Çym ≈õrodku ‚Äì ewentualnie skaluje siƒô w d√≥≈Ç
       let hx = w/2, hy = h/2;
       const hxMax = Math.min(cx, 1-cx);
       const hyMax = Math.min(cy, 1-cy);
       const s = Math.min(1, hxMax/hx, hyMax/hy);
       w *= s; h *= s; hx = w/2; hy = h/2;
       const x = clamp(cx - hx, 0, 1 - w);
       const y = clamp(cy - hy, 0, 1 - h);
       return { x, y, w, h };
     }
     function setHidden(el, val){ if (!el) return; try{ el.hidden = !!val; }catch{} }
     // Ujednolicone prze≈ÇƒÖczanie widoczno≈õci paneli: tylko jeden widoczny naraz
     function showPanel(which){
       const dlWrapEl = dlWrap || document.getElementById('dl-wrap');
       const canvasStatusEl = document.getElementById('canvas-status-wrap');
       const infoEl = info || document.getElementById('info');
       if (which === 'progress'){
         setHidden(dlWrapEl, false);
         // upewnij siƒô, ≈ºe nie pozostaje display:none po poprzednim stanie
         if (dlWrapEl && dlWrapEl.style) dlWrapEl.style.display = '';
         // ukryj ca≈Çy panel statusu, nie tylko tre≈õƒá info
         setHidden(canvasStatusEl, true);
         if (infoEl) setHidden(infoEl, true);
       } else { // 'info'
         setHidden(dlWrapEl, true);
         if (dlWrapEl && dlWrapEl.style) dlWrapEl.style.display = 'none';
         setHidden(canvasStatusEl, false);
         if (infoEl) setHidden(infoEl, false);
       }
     }
     function updateBothVisuals(){
       const p = getDisplayBox();
       function apply(el, r){
         if (!el) return;
         if (!r) { setHidden(el, true); return; }
         el.style.left = (p.offX + r.x * p.dw) + 'px';
         el.style.top = (p.offY + r.y * p.dh) + 'px';
         el.style.width = (r.w * p.dw) + 'px';
         el.style.height = (r.h * p.dh) + 'px';
         setHidden(el, false);
       }
       apply(cropGameEl, state.gameRect);
       apply(cropCameraEl, state.cameraRect);
     }
     function validateAndUpdateVisuals(){
      // Nie wymuszaj ≈ºadnego aspektu ani auto-przekszta≈Çce≈Ñ ‚Äì u≈ºytkownik ma pe≈ÇnƒÖ kontrolƒô
      state.validAspect = true;
       setInfo('Tryb edycji: narysuj/edytuj kadry gry (czerwony) i kamerki (niebieski).');
       updateBothVisuals();
     }
 
   // Tryb zaznaczania + rysowanie
     const btnToggleCrop = document.getElementById('btn-toggle-crop');
     if (btnToggleCrop) {
       btnToggleCrop.addEventListener('click', () => {
         if (!active) { alert('Najpierw wybierz klip.'); return; }
         cropping = !cropping;
         video.controls = !cropping;
         overlay.classList.toggle('inactive', !cropping);
         setInfo(cropping ? 'Tryb zaznaczania: przeciƒÖgnij myszƒÖ po wideo. Bez Shift = gra, z przytrzymanym Shift = kamerka.' : 'Tryb zaznaczania wy≈ÇƒÖczony.');
       });
     }

   // --- Nowe sterowanie: rysowanie, przesuwanie i zmiana rozmiaru ---
   let drag = null; // {mode:'draw'|'move'|'resize', which:'game'|'camera', handle?:string, start:{x,y}, rect0?:{x,y,w,h}}

   function startDraw(which, e){
     drag = { mode:'draw', which, start: eventToNorm(e) };
     const r = { x: drag.start.x, y: drag.start.y, w: 0, h: 0 };
     if (which === 'game') state.gameRect = r; else state.cameraRect = r;
     updateBothVisuals();
   }
   function startMove(which, e){
     const r = (which === 'game') ? state.gameRect : state.cameraRect;
     if (!r) return;
     drag = { mode:'move', which, start: eventToNorm(e), rect0: { ...r } };
   }
   function startResize(which, handle, e){
     const r = (which === 'game') ? state.gameRect : state.cameraRect;
     if (!r) return;
     drag = { mode:'resize', which, handle, start: eventToNorm(e), rect0: { ...r } };
   }

   if (overlay) overlay.addEventListener('mousedown', (e)=>{
     if (!active || !cropping) return;
     if (e.target !== overlay) return; // rysuj tylko na pustym tle
     const which = e.shiftKey ? 'camera' : 'game';
     startDraw(which, e);
     e.preventDefault();
   });

   function onRectMouseDown(which, e){
     if (!active || !cropping) return;
     const target = e.target;
     const handles = ['nw','n','ne','e','se','s','sw','w'];
     let handle = null;
     for (const h of handles){ if (target.classList && target.classList.contains(h)) { handle = h; break; } }
     if (handle) startResize(which, handle, e); else startMove(which, e);
     e.preventDefault();
     e.stopPropagation();
   }
   if (cropGameEl) cropGameEl.addEventListener('mousedown', onRectMouseDown.bind(null, 'game'));
   if (cropCameraEl) cropCameraEl.addEventListener('mousedown', onRectMouseDown.bind(null, 'camera'));

   window.addEventListener('mousemove', (e)=>{
     if (!drag || !active || !cropping) return;
     const p = eventToNorm(e);
     const which = drag.which;
     const r0 = drag.rect0 || ((which === 'game') ? state.gameRect : state.cameraRect) || {x:drag.start.x, y:drag.start.y, w:0, h:0};
     let rect = null;
     if (drag.mode === 'draw'){
       if (which === 'camera'){
         // swobodne rysowanie dla kamerki ‚Äì ≈Çatwiej trafiƒá w ma≈Çy box
         const left = Math.min(drag.start.x, p.x);
         const top = Math.min(drag.start.y, p.y);
         const right = Math.max(drag.start.x, p.x);
         const bottom = Math.max(drag.start.y, p.y);
         rect = { x: clamp(left,0,1), y: clamp(top,0,1), w: clamp(right,0,1) - clamp(left,0,1), h: clamp(bottom,0,1) - clamp(top,0,1) };
       } else {
         // gra: r√≥wnie≈º swobodne rysowanie (bez wymuszania aspektu)
         const left = Math.min(drag.start.x, p.x);
         const top = Math.min(drag.start.y, p.y);
         const right = Math.max(drag.start.x, p.x);
         const bottom = Math.max(drag.start.y, p.y);
         rect = { x: clamp(left,0,1), y: clamp(top,0,1), w: clamp(right,0,1) - clamp(left,0,1), h: clamp(bottom,0,1) - clamp(top,0,1) };
       }
     } else if (drag.mode === 'move'){
       const dx = p.x - drag.start.x;
       const dy = p.y - drag.start.y;
       let x = clamp(r0.x + dx, 0, 1 - r0.w);
       let y = clamp(r0.y + dy, 0, 1 - r0.h);
       rect = { x, y, w: r0.w, h: r0.h };
     } else if (drag.mode === 'resize'){

const minW = 0.01, minH = 0.01;
// Odczytaj aktualne krawƒôdzie
let left = r0.x, top = r0.y, right = r0.x + r0.w, bottom = r0.y + r0.h;
const onlyVertical = (drag.handle === 'n' || drag.handle === 's');
const onlyHorizontal = (drag.handle === 'w' || drag.handle === 'e');

if (onlyVertical) {
  // zmiana tylko wysoko≈õci (bez wymuszania aspektu)
  if (drag.handle === 'n') top = clamp(p.y, 0, bottom - minH); else bottom = clamp(p.y, top + minH, 1);
  rect = { x: left, y: top, w: right - left, h: bottom - top };
} else if (onlyHorizontal) {
  // zmiana tylko szeroko≈õci (bez wymuszania aspektu)
  if (drag.handle === 'w') left = clamp(p.x, 0, right - minW); else right = clamp(p.x, left + minW, 1);
  rect = { x: left, y: top, w: right - left, h: bottom - top };
} else {
  // uchwyty naro≈ºne ‚Äì niezale≈ºna zmiana szer./wys. bez wymuszania aspektu
  if (drag.handle === 'nw') { left = clamp(p.x, 0, right - minW); top = clamp(p.y, 0, bottom - minH); }
  else if (drag.handle === 'ne') { right = clamp(p.x, left + minW, 1); top = clamp(p.y, 0, bottom - minH); }
  else if (drag.handle === 'sw') { left = clamp(p.x, 0, right - minW); bottom = clamp(p.y, top + minH, 1); }
  else if (drag.handle === 'se') { right = clamp(p.x, left + minW, 1); bottom = clamp(p.y, top + minH, 1); }
  rect = { x: left, y: top, w: right - left, h: bottom - top };
}
     }
     if (which === 'game') state.gameRect = rect; else state.cameraRect = rect;
     updateBothVisuals();
   });
   window.addEventListener('mouseup', ()=>{ 
     // Nie modyfikuj rozmiaru/ratio po puszczeniu myszy ‚Äì pozostaw dok≈Çadnie to, co ustawi≈Ç u≈ºytkownik
     drag = null; 
     validateAndUpdateVisuals();
   });
   window.addEventListener('resize', validateAndUpdateVisuals);
 
   // stara funkcja update usuni√Ñ‚Ñ¢ta - teraz u√Ö¬ºywamy validateAndUpdateVisuals()
 
     let ensureErrorMessage = null;
     async function pollEnsureStatus(totalHint){
       try {
         const r = await fetch('/api/ensure-cache/status', { cache: 'no-store' });
         if (!r.ok) throw new Error('status failed');
         const s = await r.json();
         const total = s.total || totalHint || 0;
         const done = s.done || 0;
         if (total > 0) {
           const pct = Math.max(0, Math.min(100, Math.round((done/total)*100)));
           if (dlBar) dlBar.style.width = pct + '%';
           if (dlCount) dlCount.textContent = `${done}/${total}`;
         } else {
           if (dlBar) dlBar.style.width = '0%';
           if (dlCount) dlCount.textContent = '';
         }
         if (s.state === 'error') {
           ensureErrorMessage = s.error || s.message || 'B≈ÇƒÖd podczas pobierania';
           return true;
         }
         if (s.state === 'done' || (total && done >= total)) return true;
       } catch (e) {
         // zignoruj chwilowe b√Ö≈Ç√Ñ‚Ñ¢dy
       }
       return false;
     }
 
     async function ensureCacheWithProgress(totalHint){
       if (!clips || clips.length === 0) return;
       showPanel('progress');
       if (dlText) dlText.textContent = 'Pobieranie i generowanie prewek...';
       if (dlBar) dlBar.style.width = '0%';
       if (dlCount) dlCount.textContent = '';
       // Panel statusu jest ukryty przez showPanel('progress')
  
       ensureErrorMessage = null;
       const postPromise = fetch('/api/ensure-cache', { method: 'POST' })
         .then(r=>r.json())
         .catch(err=>{ ensureErrorMessage = err.message; });
  
       let done = false;
       while (!done) {
         const sdone = await pollEnsureStatus();
         if (sdone) done = true; else await new Promise(res=>setTimeout(res, 1000));
       }
       await postPromise;
  
       if (ensureErrorMessage) {
           if (dlText) dlText.textContent = 'B≈ÇƒÖd';
           setInfo('B≈ÇƒÖd pobierania: ' + ensureErrorMessage, true);
           // Nie blokuj UI ‚Äì pozw√≥l u≈ºytkownikowi spr√≥bowaƒá odtwarzania lub ponowiƒá, ale schowaj pasek
           showPanel('info');
           return;
         }
 
         // Zamiast pokazywaƒá panel "Zako≈Ñczono", schowaj go i poka≈º instrukcje edycji
         if (dlBar) dlBar.style.width = '';
         if (dlText) dlText.textContent = '';
         if (dlCount) dlCount.textContent = '';
         showPanel('info');
 
       setInfo('Tryb edycji: narysuj/edytuj kadry gry (czerwony) i kamerki (niebieski).');
         try { tryAutoLoadActive(); } catch(e) {}
         // Je≈õli w trakcie ensure-cache dodano nowe klipy, uruchom kolejny cykl
         try {
           const s = await fetch('/api/ensure-cache/status', { cache:'no-store' }).then(r=>r.json());
           const currentTotal = (clips || []).length;
           const ensuredTotal = Number(s?.total || 0);
           if (currentTotal > ensuredTotal) { ensureCacheWithProgress(currentTotal).catch(()=>{}); }
           else { setInfo(`Wybrano ${currentTotal} klip√≥w.`); }
         } catch(_e) { /* ignore */ }
       }

     // Auto-start ensure-cache na starcie i po zmianach, je≈õli sƒÖ brakujƒÖce pliki
     let ensureRunning = false;
     async function maybeStartEnsureCacheImmediate(){
       if (ensureRunning) return Promise.resolve();
       try {
         const s = await fetch('/api/ensure-cache/status', { cache:'no-store' }).then(r=>r.json());
         const state = s?.state || 'idle';
         const total = Number(s?.total || 0);
         const done = Number(s?.done || 0);
         const currentTotal = (clips || []).length;
         const needByStatus = state !== 'done' || done < total || total < currentTotal;
         let needByHead = false;
         if (!needByStatus) {
            const sample = (clips || []).slice(0, Math.min(5, currentTotal));
            for (const c of sample){
              const id = clipIdFromUrl(c.url);
              try {
                const p = await fetch(`/media/previews/${id}.mp4`, { method:'HEAD', cache:'no-store' });
                if (!p.ok){ needByHead = true; break; }
              } catch(_) {
                // Traktuj b≈Çƒôdy (np. aborted) jako brak pliku ‚Äì wymu≈õ ensure-cache
                needByHead = true; break;
              }
            }
          }
         if (needByStatus || needByHead){
           ensureRunning = true;
           return ensureCacheWithProgress(currentTotal).finally(()=>{ ensureRunning = false; });
         }
+        // Nie trzeba startowaƒá ensure-cache: poka≈º wy≈ÇƒÖcznie panel statusu
+        showPanel('info');
       } catch(_) { /* ignore */ }
       return Promise.resolve();
     }
 
   const btnSaveCrop = document.getElementById('btn-save-crop');
   if (btnSaveCrop) btnSaveCrop.addEventListener('click', async ()=>{
     if (!active) { alert('Najpierw wybierz klip.'); return; }
     if (!state.gameRect || !state.cameraRect){ alert('Zaznacz obszary dla gry i kamerki.'); return; }
     try {
       const [r1, r2] = await Promise.all([
         fetch('/api/crop', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ clip_id: active.clip_id, rect: state.gameRect, kind: 'game' }) }),
         fetch('/api/crop', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ clip_id: active.clip_id, rect: state.cameraRect, kind: 'camera' }) })
       ]);
       if (!r1.ok) throw new Error(await r1.text());
       if (!r2.ok) throw new Error(await r2.text());
       setInfo('Zapisano kadry (gra i kamerka) dla ' + active.clip_id);
     } catch (e) {
       setInfo('B≈ÇƒÖd zapisu kadr√≥w: ' + e.message, true);
       alert('B≈ÇƒÖd zapisu kadr√≥w: ' + e.message);
     }
   });
 
     // Bootstrap wyboru z localStorage -> backend, potem auto-start ensure-cache, auto-select first (po za≈Çadowaniu DOM)
    document.addEventListener('DOMContentLoaded', async () => {
      try {
        let posted = false;
        const raw = localStorage.getItem('pendingSelection');
        if (raw) {
          const payload = JSON.parse(raw);
          if (payload && Array.isArray(payload.clips) && payload.clips.length) {
            setInfo('Zapisujƒô wyb√≥r klip√≥w...');
            const res = await fetch('/api/selection', {
              method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload)
            });
            if (res.ok) {
              localStorage.removeItem('pendingSelection');
              // zaktualizuj lokalny stan listy klip√≥w bez prze≈Çadowania
              clips = payload.clips;
              renderList();
              posted = true;
              // Nie pokazuj "Wybrano X klip√≥w" tutaj ‚Äì bƒôdzie po ensure-cache
            }
          }
        }
        if (!clips || clips.length === 0) {
          setInfo('Brak wybranych klip√≥w. Wr√≥ƒá do raportu i zaznacz klipy.', true);
          return;
        }
        // Najpierw pozw√≥l u≈ºytkownikowi od razu zaczƒÖƒá ‚Äì wybierz pierwszy klip
        try{
          if (typeof window.selectClip === 'function'){ window.selectClip(clips[0]); }
          else { console.warn('selectClip nie jest jeszcze dostƒôpny'); }
        }catch(e){ console.warn('selectClip init error:', e); }
        // Uruchom ensure-cache asynchronicznie i po zako≈Ñczeniu poka≈º informacjƒô o liczbie klip√≥w
        await maybeStartEnsureCacheImmediate()
          .finally(()=>{ try { setInfo(`Wybrano ${clips.length} klip√≥w.`); } catch(_) {} });
      } catch(e) {
        console.error(e);
        setInfo('WystƒÖpi≈Ç b≈ÇƒÖd inicjalizacji edytora: ' + e.message, true);
      }
    });
  // cleanTail IIFE removed to avoid potential parsing issues
  </script>

  <!-- Panel podglƒÖdu 9:16 i trimowania (legacy - ukryty) -->
  <div id="legacy-panel" style="display:none;">
    <div>
      <div style="font-weight:600; margin-bottom:6px;">PodglƒÖd 9:16</div>
      <canvas id="final-preview" width="270" height="480" style="background:#000; border:1px solid #999; border-radius:6px; display:block;"></canvas>
    </div>
    <div style="min-width:260px;">
      <div style="font-weight:600; margin-bottom:6px;">Trim</div>
      <div class="timebar"><span class="time-label" id="time-label">0:00 / 0:00</span><input id="time-slider" type="range" min="0" value="0" step="0.01"></div>
      <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-top:6px;">
        <label>Start (s): <input id="trim-start" type="number" step="0.01" min="0" style="width:90px"></label>
        <button id="btn-set-start" class="btn" type="button">Ustaw = czas</button>
      </div>
      <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-top:6px;">
        <label>Koniec (s): <input id="trim-end" type="number" step="0.01" min="0" style="width:90px"></label>
        <button id="btn-set-end" class="btn" type="button">Ustaw = czas</button>
      </div>
      <div style="margin-top:10px; display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
        <button id="btn-transcribe" class="btn" type="button">üìù Transkrybuj SRT</button>
        <span id="srt-status" style="color:#555"></span>
        <a id="srt-link" href="#" target="_blank" style="display:none;">Pobierz SRT</a>
      </div>
      <div style="margin-top:10px; display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
        <button id="btn-render" class="btn" type="button">üé¨ Renderuj 1080x1920</button>
        <label style="display:flex; align-items:center; gap:6px;">
          <input type="checkbox" id="include-subtitles" checked>
          <span>Wypal napisy (karaoke/SRT)</span>
        </label>
        <a id="render-link-legacy" href="#" target="_blank" style="display:none;">Pobierz wynik</a>
        <button id="btn-render-retry" class="btn" type="button" style="display:none;">üîÅ Pon√≥w renderowanie</button>
        <button id="btn-render-error" class="btn" type="button" style="display:none;">‚ÑπÔ∏è Poka≈º b≈ÇƒÖd</button>
        <button id="btn-remove-rendered" class="btn" type="button" style="display:none; background:#ff6b6b; color:white;">üóëÔ∏è Usu≈Ñ wyrenderowany</button>
        <pre id="render-error-details" style="display:none; max-width:480px; white-space:pre-wrap; background:#fff3f3; border:1px solid #f3caca; padding:8px; border-radius:6px;"></pre>
        <!-- Usuniƒôto legacy publikacjƒô, aby uniknƒÖƒá duplikat√≥w id i konflikt√≥w -->
        <span id="karaoke-status" style="color:#555; display:none;">Karaoke: ‚Äî</span>
      </div>
    </div>
  </div>

  <script type="text/javascript">
  const previewCanvas = document.getElementById('final-preview');
  const ctxPrev = previewCanvas.getContext('2d');
  const trimStartEl = document.getElementById('trim-start');
  const trimEndEl = document.getElementById('trim-end');
  const btnSetStart = document.getElementById('btn-set-start');
  const btnSetEnd = document.getElementById('btn-set-end');
  const btnRender = document.getElementById('btn-render');
  const renderLink = document.getElementById('render-link');
  const btnRenderRetry = document.getElementById('btn-render-retry');
  const btnRenderError = document.getElementById('btn-render-error');
  const btnRemoveRendered = document.getElementById('btn-remove-rendered');
  const renderErrorDetails = document.getElementById('render-error-details');
  const karaokeStatus = document.getElementById('karaoke-status');
  const includeSubtitlesEl = document.getElementById('include-subtitles');
  const timeSlider = document.getElementById('time-slider');
  const timeLabel = document.getElementById('time-label');
  let lastRenderPayload = null;
  let lastRenderResponse = null;

  if (btnSetStart) btnSetStart.addEventListener('click', ()=>{ const t = (video && isFinite(video.currentTime)) ? video.currentTime : parseFloat(timeSlider?.value||'0')||0; if (trimStartEl) trimStartEl.value = t.toFixed(2); });
  if (btnSetEnd) btnSetEnd.addEventListener('click', ()=>{ const t = (video && isFinite(video.currentTime)) ? video.currentTime : parseFloat(timeSlider?.value||'0')||0; if (trimEndEl) trimEndEl.value = t.toFixed(2); });

  // Normalizacja rƒôcznie wpisywanych warto≈õci
  if (trimStartEl) trimStartEl.addEventListener('change', ()=>{ const dur = (video && isFinite(video.duration)) ? video.duration : undefined; let v = parseFloat(trimStartEl.value||'0'); if (!isFinite(v) || v < 0) v = 0; if (isFinite(dur)) v = Math.min(v, dur); trimStartEl.value = v.toFixed(2); });
  if (trimEndEl) trimEndEl.addEventListener('change', ()=>{ const dur = (video && isFinite(video.duration)) ? video.duration : undefined; let v = parseFloat(trimEndEl.value||'0'); if (!isFinite(v) || v < 0) v = 0; if (isFinite(dur)) v = Math.min(v, dur); trimEndEl.value = v.toFixed(2); });

  function fmtTime(t){ if (!isFinite(t) || t < 0) return '0:00'; const m = Math.floor(t/60); const s = Math.floor(t%60).toString().padStart(2,'0'); return `${m}:${s}`; }
  function updateTimeLabel(){ const cur = isFinite(video.currentTime) ? video.currentTime : 0; const dur = isFinite(video.duration) ? video.duration : 0; timeLabel.textContent = `${fmtTime(cur)} / ${fmtTime(dur)}`; }
  if (timeSlider) {
    if (video) video.addEventListener('loadedmetadata', ()=>{ if (isFinite(video.duration)) { timeSlider.max = video.duration.toFixed(2); timeSlider.value = 0; updateTimeLabel(); } });
    if (video) video.addEventListener('timeupdate', ()=>{ if (isFinite(video.currentTime)) { timeSlider.value = video.currentTime; updateTimeLabel(); } });
    timeSlider.addEventListener('input', ()=>{ if (isFinite(video.duration)) { const t = parseFloat(timeSlider.value); if (isFinite(t)) video.currentTime = t; } });
  }

  // Przenie≈õ panel podglƒÖdu/trim na prawƒÖ kolumnƒô obok edytora
  (function(){ const side = document.getElementById('side-preview'); const panel = document.getElementById('preview-trim-panel'); if (side && panel) { side.appendChild(panel); panel.style.marginTop = '0'; panel.style.display = 'block'; } })();

  function drawPreview(){
    const w = previewCanvas.width, h = previewCanvas.height;
    ctxPrev.fillStyle = '#000';
    ctxPrev.fillRect(0,0,w,h);
    if (!video.videoWidth) return;
    const vw = video.videoWidth, vh = video.videoHeight;
    const hasGame = !!(state && state.gameRect);
    const hasCam = !!(state && state.cameraRect);
    const gameRect = hasGame ? state.gameRect : { x:0, y:0, w:1, h:1 };
    const cameraRect = hasCam ? state.cameraRect : { x:0, y:0, w:1, h:1 };
    if (state.singleFrame){
      // T≈Ço: ten sam klip mocno powiƒôkszony i rozmyty, cover ca≈Çego canvasu
      (function(){
        const r = gameRect; let sx = Math.floor(r.x*vw), sy = Math.floor(r.y*vh);
        let sw = Math.floor(r.w*vw), sh = Math.floor(r.h*vh);
        sw = Math.max(1, Math.min(vw - sx, sw));
        sh = Math.max(1, Math.min(vh - sy, sh));
        if (sw<=0||sh<=0) return;
        const A = w/h, a = sw/sh; let tw, th;
        if (a > A){ th = h; tw = Math.ceil(h*a); } else { tw = w; th = Math.ceil(w/a); }
        const ox = Math.floor((w - tw)/2), oy = Math.floor((h - th)/2);
        ctxPrev.save();
        ctxPrev.filter = 'blur(12px) brightness(0.85)';
        ctxPrev.drawImage(video, sx, sy, sw, sh, ox, oy, tw, th);
        ctxPrev.restore();
      })();
      // Panel 21:9 o zadanej wysoko≈õci
      let panelH = Math.round(h * state.singleHeightRatio);
      if (panelH % 2) panelH += 1; panelH = Math.max(2, Math.min(h, panelH));
      const panelY = Math.floor((h - panelH)/2);
      const dw = w, dh = panelH;
      (function(){
        const r = gameRect; let sx = Math.floor(r.x*vw), sy = Math.floor(r.y*vh);
        let sw = Math.floor(r.w*vw), sh = Math.floor(r.h*vh);
        sw = Math.max(1, Math.min(vw - sx, sw));
        sh = Math.max(1, Math.min(vh - sy, sh));
        if (sw<=0||sh<=0) return;
        const a = sw/sh, A = dw/dh; let tw, th;
        if (a > A){ th = dh; tw = Math.ceil(dh*a); } else { tw = dw; th = Math.ceil(dw/a); }
        const ox = Math.floor((dw - tw)/2); const oy = Math.floor(panelY + (dh - th)/2);
        ctxPrev.save(); ctxPrev.beginPath(); ctxPrev.rect(0, panelY, dw, dh); ctxPrev.clip();
        ctxPrev.drawImage(video, sx, sy, sw, sh, ox, oy, tw, th);
        ctxPrev.restore();
      })();
      return;
    }
   let topH, botH;
   if (state.autoSplit && hasGame && hasCam){
     const aCam = Math.max(1e-6, cameraRect.w / Math.max(1e-6, cameraRect.h));
     const aGame = Math.max(1e-6, gameRect.w / Math.max(1e-6, gameRect.h));
     const pCam = 1 / aCam, pGame = 1 / aGame;
     const sum = pCam + pGame;
     topH = Math.max(2, Math.round(h * (pCam / sum)));
     botH = Math.max(2, h - topH);
   } else {
     const g = state.gameRatio, c = 1 - g;
     topH = Math.max(2, Math.round(h * c));
     botH = Math.max(2, h - topH);
   }
   // enforce even heights (synchronizacja z ffmpeg)
   if (topH % 2) topH += 1;
   if (botH % 2) botH -= 1;
   if (botH <= 0) botH = 2;
   if (topH + botH !== h) botH = h - topH;

    // camera (top) i game (bottom) bez pas√≥w ‚Äì wype≈Çnienie (cover)
    function drawCover(r, dx, dy, dw, dh, relief = 1.0){
      let sx = Math.floor(r.x * vw), sy = Math.floor(r.y * vh);
      let sw = Math.floor(r.w * vw), sh = Math.floor(r.h * vh);
      sw = Math.max(1, Math.min(vw - sx, sw));
      sh = Math.max(1, Math.min(vh - sy, sh));
      if (sw <= 0 || sh <= 0) return;
      const a = sw / sh, A = dw / dh; // a: aspekt ≈∫r√≥d≈Ça, A: aspekt celu
      let tw, th; // rozmiar docelowy (mo≈ºe wyjechaƒá poza ramkƒô; obetniemy klipem)
      if (a > A) {
        // ≈∫r√≥d≈Ço szersze ni≈º cel ‚Üí dopasuj wysoko≈õƒá; szeroko≈õƒá mo≈ºe wyj≈õƒá poza docelowƒÖ
        th = Math.ceil(dh * relief);
        tw = Math.ceil((dh * a) * relief);
      } else {
        // ≈∫r√≥d≈Ço wƒô≈ºsze ‚Üí dopasuj szeroko≈õƒá; wysoko≈õƒá mo≈ºe wyj≈õƒá poza docelowƒÖ
        tw = Math.ceil(dw * relief);
        th = Math.ceil((dw / a) * relief);
      }
      const ox = Math.floor(dx + (dw - tw)/2);
      const oy = Math.floor(dy + (dh - th)/2);
      // ogranicz rysowanie do obszaru [dx,dy,dw,dh], aby nic nie zachodzi≈Ço na sƒÖsiedniƒÖ sekcjƒô
      ctxPrev.save();
      ctxPrev.beginPath();
      ctxPrev.rect(dx, dy, dw, dh);
      ctxPrev.clip();
      ctxPrev.drawImage(video, sx, sy, sw, sh, ox, oy, tw, th);
      ctxPrev.restore();
    }

    // camera (top) i game (bottom) ‚Äì cover strict (bez pad√≥w/soften)
    drawCover(cameraRect, 0, 0, w, topH, 1.0);
    drawCover(gameRect, 0, topH, w, botH, 1.0);
  }
  function previewLoop(){
    try{ drawPreview(); }catch(e){}
    requestAnimationFrame(previewLoop);
  }
  previewLoop();

  // Legacy duplicates replaced with delegates to primary implementations
  function makeRenderPayload(){
    if (typeof window.makeRenderPayload === 'function') return window.makeRenderPayload();
    console.warn('makeRenderPayload (legacy) called but primary not found');
    return {};
  }
  function pollRenderUntilFinish(clipId){
    if (typeof window.pollRenderUntilFinish === 'function') return window.pollRenderUntilFinish(clipId);
    console.warn('pollRenderUntilFinish (legacy) fallback ‚Äî using no-op');
    let attempts = 0; const maxAttempts = 60; const intervalMs = 2000; const tick = ()=>{ attempts++; if (attempts<maxAttempts) setTimeout(tick, intervalMs); else setInfo('Timeout oczekiwania na zako≈Ñczenie renderu.', true); }; tick(); return;
  }
  async function performRender(payload){
    if (typeof window.performRender === 'function') return window.performRender(payload);
    console.warn('performRender (legacy) called but primary not found');
  }
  if (btnRender){
    btnRender.addEventListener('click', async ()=>{
      if (!active){ alert('Najpierw wybierz klip.'); return; }
      if (!state.gameRect || (!state.singleFrame && !state.cameraRect)){ alert('Najpierw zaznacz wymagane kadry.'); return; }
      await performRender(makeRenderPayload());
    });
  }
  if (btnRenderRetry){
    btnRenderRetry.addEventListener('click', async ()=>{
      if (!lastRenderPayload){ alert('Brak poprzednich parametr√≥w renderu.'); return; }
      const go = confirm('Ponowiƒá renderowanie tego klipu z tymi samymi parametrami?');
      if (!go) return;
      btnRenderRetry.disabled = true;
      try{ await performRender(lastRenderPayload); } finally { btnRenderRetry.disabled = false; }
    });
  }
  if (btnRenderError && renderErrorDetails){
    btnRenderError.addEventListener('click', ()=>{
      const vis = renderErrorDetails.style.display !== 'none';
      renderErrorDetails.style.display = vis ? 'none' : 'block';
    });
  }
  if (btnRemoveRendered){
    btnRemoveRendered.addEventListener('click', async ()=>{
      if (!active || !active.clip_id){
        alert('Brak aktywnego klipu do usuniƒôcia.');
        return;
      }
      
      btnRemoveRendered.disabled = true;
      setInfo('Usuwam wyrenderowany klip...');
      
      try {
        const r = await fetch('/api/remove-rendered-clip', {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify({ clip_id: active.clip_id })
        });
        const j = await r.json();
        
        if (!r.ok || !j.ok) {
          setInfo('Nie uda≈Ço siƒô usunƒÖƒá wyrenderowanego klipu: ' + (j.error || r.statusText), true);
          return;
        }
        
        // Ukryj link do pobrania i przycisk usuwania
        if (renderLink) renderLink.style.display = 'none';
        btnRemoveRendered.style.display = 'none';
        
        setInfo('Usuniƒôto wyrenderowany klip. Mo≈ºesz teraz renderowaƒá ponownie.');
        
      } catch (e) {
        setInfo('B≈ÇƒÖd usuwania wyrenderowanego klipu: ' + e.message, true);
      } finally {
        btnRemoveRendered.disabled = false;
      }
    });
  }
  </script>

  <script type="text/javascript">
  (function(){
    const btnTranscribe = document.getElementById('btn-transcribe');
    const srtStatus = document.getElementById('srt-status');
    const srtLink = document.getElementById('srt-link');
    function resetSrtUi(){ srtStatus.textContent = ''; srtLink.style.display = 'none'; srtLink.href = '#'; }
    async function pollTranscribe(clip_id){
      try{
        const r = await fetch(`/api/transcribe/status?clip_id=${encodeURIComponent(clip_id)}`, { cache:'no-store' });
        if (!r.ok) throw new Error('status failed');
        const j = await r.json();
        if (j.state === 'done' && j.url){ srtStatus.textContent = 'Gotowe'; srtLink.href = j.url; srtLink.style.display = 'inline-block'; return true; }
        if (j.state === 'error'){ srtStatus.textContent = 'B≈ÇƒÖd: ' + (j.error || ''); return true; }
        if (j.state === 'running'){ srtStatus.textContent = 'Trwa transkrypcja...'; return false; }
      }catch(e){ /* ignore transient */ }
      return false;
    }
    async function startTranscribe(){
      if (!window.active){ alert('Najpierw wybierz klip.'); return; }
      resetSrtUi(); srtStatus.textContent = 'Uruchamianie...';
      try{
        const r = await fetch('/api/transcribe', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ clip_id: window.active.clip_id }) });
        const j = await r.json();
        if (!r.ok || j.ok === false){ srtStatus.textContent = 'B≈ÇƒÖd: ' + (j.error || ''); return; }
        if (j.state === 'done' && j.url){ srtStatus.textContent = 'Gotowe'; srtLink.href = j.url; srtLink.style.display = 'inline-block'; return; }
        srtStatus.textContent = 'Trwa transkrypcja...';
        let done = false;
        while(!done){
          done = await pollTranscribe(window.active.clip_id);
          if (!done) await new Promise(res=>setTimeout(res, 1500));
        }
      }catch(e){ srtStatus.textContent = 'B≈ÇƒÖd: ' + e.message; }
    }
    if (btnTranscribe) btnTranscribe.addEventListener('click', startTranscribe);

    const _origSelectClip = (typeof window.selectClip === 'function') ? window.selectClip : null;
     if (typeof _origSelectClip === 'function'){
       window.selectClip = async function(c){
         await _origSelectClip(c);
         // Resetuj UI publikacji i powiƒÖzane elementy po zmianie klipu
         try { if (typeof window.resetPublishUi === 'function') window.resetPublishUi(); } catch{}
         resetSrtUi();
         // Resetuj status karaoke po zmianie klipu
         try {
           const ks = document.getElementById('karaoke-status');
           if (ks){ ks.style.display = 'none'; ks.textContent = 'Karaoke: ‚Äî'; }
         } catch(e){}
         if (window.active && window.active.clip_id){ pollTranscribe(window.active.clip_id); }
       };
     }
    window.resetSrtUi = resetSrtUi;
    window.pollTranscribe = pollTranscribe;
  })();
  </script>

  <script type="text/javascript">
  (function(){
    const btnPublish = document.getElementById('btn-publish');
    const publishPanel = document.getElementById('publish-panel');
    const pubNow = document.getElementById('pub-now');
    const pubSched = document.getElementById('pub-sched');
    const pubTimeContainer = document.getElementById('pub-time-container');
    const pubDate = document.getElementById('pub-date');
    const pubTimeSlot = document.getElementById('pub-time-slot');
    const pubCaption = document.getElementById('pub-caption');
    const pubTagGroupsInput = document.getElementById('pub-tag-groups');
    const pubTagGroupsSuggest = document.getElementById('pub-tag-groups-suggest');
    const pubTagGroupsSelected = document.getElementById('pub-tag-groups-selected');
    const btnPublishConfirm = document.getElementById('btn-publish-confirm');
    const publishStatus = document.getElementById('publish-status');
    const renderLink = document.getElementById('render-link');
    const pubAccounts = document.getElementById('pub-accounts');
    const pubAccountsLoading = document.getElementById('pub-accounts-loading');
    // Reset UI publikacji przy zmianie klipu
    function resetPublishUi(){
      try{
        if (pubCaption) pubCaption.value = '';
        if (publishStatus) publishStatus.textContent = '';
        if (pubTagGroupsInput) pubTagGroupsInput.value = '';
        if (window.selectedGroups && typeof window.selectedGroups.clear === 'function'){ window.selectedGroups.clear(); }
        renderSelectedGroups();
        hideSuggest();
        if (pubNow) pubNow.checked = true;
        if (pubInternal) pubInternal.checked = false;
        if (pubSched) pubSched.checked = false;
        if (pubTimeContainer) pubTimeContainer.style.display = 'none';
        if (pubDate) pubDate.value = '';
        if (pubTimeSlot) pubTimeSlot.value = '';
        if (publishPanel) publishPanel.style.display = 'none';
        const renderLinkEl = document.getElementById('render-link');
        if (renderLinkEl){ renderLinkEl.href = '#'; renderLinkEl.style.display = 'none'; }
        const btnRemoveEl = document.getElementById('btn-remove-rendered');
        if (btnRemoveEl){ btnRemoveEl.style.display = 'none'; }
        const btnPublishEl = document.getElementById('btn-publish');
        if (btnPublishEl){ btnPublishEl.disabled = true; }
        const trimStartEl2 = document.getElementById('trim-start');
        const trimEndEl2 = document.getElementById('trim-end');
        if (trimStartEl2) trimStartEl2.value = '';
        if (trimEndEl2) trimEndEl2.value = '';
      }catch(e){ console.warn('resetPublishUi error:', e); }
    }
    window.resetPublishUi = resetPublishUi;

    // --- Grupy tag√≥w ---
    window.tagGroups = {};
    window.selectedGroups = new Set();
    function renderSelectedGroups(){
      if (!pubTagGroupsSelected) return;
      pubTagGroupsSelected.innerHTML = '';
      if (selectedGroups.size === 0){
        pubTagGroupsSelected.innerHTML = '<span style="color:#888;">Brak wybranych grup</span>';
        return;
      }
      Array.from(selectedGroups).forEach(name=>{
        const el = document.createElement('span');
        el.className = 'tag';
        el.innerHTML = `<span>${name}</span> <button class="remove" title="Usu≈Ñ">‚úñ</button>`;
        const rm = el.querySelector('.remove');
        if (rm) rm.addEventListener('click', ()=>{ selectedGroups.delete(name); renderSelectedGroups(); });
        pubTagGroupsSelected.appendChild(el);
      });
    }
    function hideSuggest(){ if (pubTagGroupsSuggest){ pubTagGroupsSuggest.style.display='none'; pubTagGroupsSuggest.innerHTML=''; } }
    function showSuggest(items){
      if (!items.length){ hideSuggest(); return; }
      if (!pubTagGroupsInput || !pubTagGroupsSuggest) return;
      pubTagGroupsSuggest.style.display = 'block';
      const rect = pubTagGroupsInput.getBoundingClientRect();
      pubTagGroupsSuggest.style.position = 'fixed';
      pubTagGroupsSuggest.style.top = (rect.bottom + 4) + 'px';
      pubTagGroupsSuggest.style.left = rect.left + 'px';
      pubTagGroupsSuggest.style.minWidth = rect.width + 'px';
      pubTagGroupsSuggest.innerHTML = items.map(({name,tags})=>`<div class="suggest-item" data-name="${name}"><span>${name}</span><span class="platform">${(tags||[]).length} tag√≥w</span></div>`).join('');
      pubTagGroupsSuggest.querySelectorAll('.suggest-item').forEach(el=>{
        el.addEventListener('click', ()=>{
          const g = el.dataset.name;
          selectedGroups.add(g);
          if (pubTagGroupsInput) pubTagGroupsInput.value = g;
          hideSuggest();
          renderSelectedGroups();
          if (pubTagGroupsInput) pubTagGroupsInput.focus();
        });
      });
    }
    async function loadTagGroups(){
      try{
        const r = await fetch('/api/streamers-prefs', { cache:'no-store' });
        const j = await r.json();
        tagGroups = (j && typeof j.tag_groups==='object') ? j.tag_groups : {};
      }catch{/* ignore */}
    }
    if (pubTagGroupsInput){
      pubTagGroupsInput.addEventListener('input', ()=>{
        const q = (pubTagGroupsInput.value||'').trim().toLowerCase();
        if (!q){ hideSuggest(); return; }
        const entries = Object.entries(tagGroups||{}).map(([name,tags])=>({name, tags}));
        const matched = entries.filter(e=> e.name.includes(q)).slice(0, 10);
        showSuggest(matched);
      });
      pubTagGroupsInput.addEventListener('blur', ()=> setTimeout(hideSuggest, 120));
    }

    async function loadPublerAccounts(){
      if (!pubAccounts || pubAccounts.dataset.loaded === '1') return;
      try{
        if (pubAccountsLoading) pubAccountsLoading.style.display = 'inline';
        // Try using default workspace from .env first
        let res = await fetch('/api/publer/accounts', { cache:'no-store' });
        let j = await res.json().catch(()=>({}));
        if (!res.ok || j.ok === false){
          // Fallback: get first workspace, then accounts
          const ws = await fetch('/api/publer/workspaces', { cache:'no-store' });
          const wj = await ws.json().catch(()=>({}));
          let workspaces = (wj && wj.data && (wj.data.data || wj.data)) || [];
          if (!Array.isArray(workspaces) && workspaces && workspaces.data) workspaces = workspaces.data;
          const firstWs = Array.isArray(workspaces) && workspaces.length ? workspaces[0] : null;
          if (!firstWs || !firstWs.id){ throw new Error('Brak workspace w Publer.'); }
          const url = `/api/publer/accounts?workspace_id=${encodeURIComponent(firstWs.id)}`;
          res = await fetch(url, { cache:'no-store' });
          j = await res.json().catch(()=>({}));
          if (!res.ok || j.ok === false){ throw new Error(j && (j.error || j.status_code) || 'Nie uda≈Ço siƒô pobraƒá kont.'); }
        }
        let accounts = (j && j.data && (j.data.data || j.data)) || [];
        if (!Array.isArray(accounts) && accounts && accounts.data) accounts = accounts.data;
        // Render checkboxes, default all checked
        if (pubAccountsLoading) pubAccountsLoading.remove();
        const title = document.createElement('span'); title.style.color = '#555'; title.textContent = 'Konta:';
        if (!pubAccounts.querySelector('span')) pubAccounts.prepend(title);
        accounts.forEach(acc => {
          const accId = acc.id || acc._id || acc.account_id;
          if (!accId) return;
          const label = document.createElement('label');
          label.style.display = 'flex';
          label.style.alignItems = 'center';
          label.style.gap = '6px';
          const cb = document.createElement('input');
          cb.type = 'checkbox';
          cb.name = 'pub-acct';
          cb.value = accId;
          cb.checked = true; // default: publish to all
          const name = acc.username || acc.name || acc.title || '';
          const provider = (acc.provider || acc.type || '').toString();
          const text = provider ? `${name} (${provider})` : name || accId;
          const span = document.createElement('span'); span.textContent = text;
          label.appendChild(cb); label.appendChild(span);
          pubAccounts.appendChild(label);
        });
        pubAccounts.dataset.loaded = '1';
      }catch(e){
        if (pubAccountsLoading) pubAccountsLoading.textContent = 'Nie uda≈Ço siƒô za≈Çadowaƒá kont: ' + e.message;
      }
    }

    async function loadTimeSlots(){
      if (pubTimeSlot?.dataset.loaded === '1') return;
      try{
        const r = await fetch('/api/publer/timeslots');
        const j = await r.json();
        if (!r.ok || !j.ok){ throw new Error(j.error || r.statusText); }
        const timeslots = j.timeslots || [];
        pubTimeSlot.innerHTML = '<option value="">Wybierz godzinƒô...</option>';
        timeslots.forEach(slot=>{
          const option = document.createElement('option');
          option.value = slot;
          option.textContent = slot;
          pubTimeSlot.appendChild(option);
        });
        pubTimeSlot.dataset.loaded = '1';
      }catch(e){
        console.error('Nie uda≈Ço siƒô za≈Çadowaƒá time slot√≥w:', e.message);
      }
    }

    btnPublish?.addEventListener('click', async ()=>{
      if (!window.active){ alert('Najpierw wybierz klip.'); return; }
      const willShow = (publishPanel.style.display === 'none' || publishPanel.style.display === '');
      publishPanel.style.display = willShow ? 'flex' : 'none';
      publishStatus.textContent = '';
      if (willShow){ await loadPublerAccounts(); await loadTimeSlots(); await loadTagGroups(); renderSelectedGroups(); }
    });


    const pubInternal = document.getElementById('pub-internal');
    pubNow?.addEventListener('change', ()=>{ if (pubNow.checked){ pubTimeContainer.style.display = 'none'; }});
    pubInternal?.addEventListener('change', ()=>{ if (pubInternal.checked){ pubTimeContainer.style.display = 'flex'; }});
    pubSched?.addEventListener('change', ()=>{ if (pubSched.checked){ pubTimeContainer.style.display = 'flex'; }});
    btnPublishConfirm?.addEventListener('click', async ()=>{
      try{
        if (!window.active){ alert('Najpierw wybierz klip.'); return; }
        if (!renderLink.href || renderLink.style.display === 'none'){
          alert('Najpierw wyrenderuj klip.'); return;
        }
        publishStatus.textContent = 'Wysy≈Çam‚Ä¶';
        const clip_id = window.active.clip_id;
        // Wklej tagi z wybranych grup do podpisu (deduplikacja)
        let caption = pubCaption.value || '';
        const existing = new Set((caption.match(/(^|\s)#\w+/g)||[]).map(s=>s.trim().toLowerCase()));
        const addTags = [];
        Array.from(selectedGroups).forEach(name=>{
          const tags = tagGroups[name] || [];
          tags.forEach(t=>{
            const norm = (t||'').trim();
            if (!norm) return;
            const withHash = norm.startsWith('#') ? norm : ('#' + norm);
            const key = withHash.toLowerCase();
            if (!existing.has(key)) { existing.add(key); addTags.push(withHash); }
          });
        });
        if (addTags.length > 0){
          const sep = caption ? ' ' : '';
          caption = caption + sep + addTags.join(' ');
          pubCaption.value = caption; // uaktualnij widocznie
        }
        const body = { caption: caption || undefined };
        if (pubInternal.checked){
          const date = pubDate.value; // yyyy-MM-dd
          const timeSlot = pubTimeSlot.value; // HH:mm
          if (!date || !timeSlot){ publishStatus.textContent = 'Wybierz datƒô i godzinƒô.'; return; }
          const dateTimeStr = `${date}T${timeSlot}:00`;
          const local = new Date(dateTimeStr);
          const localDate = new Date(local.getFullYear(), local.getMonth(), local.getDate(), 
                                     local.getHours(), local.getMinutes(), local.getSeconds());
          const iso = localDate.toISOString();
          body.publish_now = false;
          body.scheduled_at = iso;
          body.use_internal_scheduler = true;
        } else if (pubSched.checked){
          const date = pubDate.value; // yyyy-MM-dd
          const timeSlot = pubTimeSlot.value; // HH:mm
          if (!date || !timeSlot){ publishStatus.textContent = 'Wybierz datƒô i godzinƒô.'; return; }
          const dateTimeStr = `${date}T${timeSlot}:00`;
          const local = new Date(dateTimeStr);
          const localDate = new Date(local.getFullYear(), local.getMonth(), local.getDate(), 
                                     local.getHours(), local.getMinutes(), local.getSeconds());
          const iso = localDate.toISOString();
          body.publish_now = false;
          body.scheduled_at = iso;
          body.use_internal_scheduler = false;
        } else {
          body.publish_now = true;
        }
        // gather selected accounts (default all)
        if (pubAccounts){
          const selected = Array.from(pubAccounts.querySelectorAll('input[name="pub-acct"]:checked')).map(el=>el.value);
          if (selected.length > 0){ body.publer_account_ids = selected; }
        }
        const r = await fetch(`/publish/${encodeURIComponent(clip_id)}`, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body)});
        const j = await r.json();
        if (!r.ok || j.ok === false){ publishStatus.textContent = 'B≈ÇƒÖd: ' + (j.error || r.statusText); return; }
        if (j.dry_run){ publishStatus.textContent = 'OK (dry-run). Dodaj PUBLER_* do .env aby publikowaƒá.'; }
        else if (j.published){ publishStatus.textContent = 'Opublikowano!'; }
        else { publishStatus.textContent = 'Wys≈Çano. Sprawd≈∫ logi.'; }
      }catch(e){ publishStatus.textContent = 'B≈ÇƒÖd: ' + e.message; }
    });
    // Usuwanie zbƒôdnych wƒôz≈Ç√≥w tekstowych na ko≈Ñcu dokumentu (np. same nawiasy)
    try {
      Array.from(document.body.childNodes).forEach(n=>{
        if (n.nodeType === Node.TEXT_NODE){
          const s = n.textContent || '';
          if (/^[\s}]+$/.test(s)) n.remove();
        }
      });
      // Uruchom ponownie po pe≈Çnym parsowaniu dokumentu, by z≈Çapaƒá p√≥≈∫niej wstawione wƒôz≈Çy
      document.addEventListener('DOMContentLoaded', ()=>{
        Array.from(document.body.childNodes).forEach(n=>{
          if (n.nodeType === Node.TEXT_NODE){
            const s = n.textContent || '';
            if (/^[\s}]+$/.test(s)) n.remove();
          }
        });
      }, { once:true });
      // Dodatkowo obserwuj p√≥≈∫niejsze wstawienia i natychmiast usuwaj artefakty
      const obs = new MutationObserver(muts=>{
        try{
          muts.forEach(m=>{
            (m.addedNodes || []).forEach(n=>{
              if (n.nodeType === Node.TEXT_NODE){
                const s = n.textContent || '';
                if (/^[\s}]+$/.test(s)) n.remove();
              } else if (n.nodeType === Node.ELEMENT_NODE){
                Array.from(n.childNodes).forEach(c=>{
                  if (c.nodeType === Node.TEXT_NODE){
                    const s = c.textContent || '';
                    if (/^[\s}]+$/.test(s)) c.remove();
                  }
                });
              }
            });
          });
        }catch(e){}
      });
      obs.observe(document.body, { childList: true, subtree: true });
    } catch (e) {}
  })();
  </script>

  <pre style="display:none">
  </pre>
  <script>
    (function(){
      try{
        const pres = document.querySelectorAll('pre[style*="display:none"]');
        const pre = pres[pres.length-1];
        if (pre){
          let n = pre.nextSibling;
          while(n){
            const next = n.nextSibling;
            if (n.nodeType === Node.TEXT_NODE){ n.textContent = ''; }
            else if (n.nodeType === Node.ELEMENT_NODE){ n.style.display = 'none'; }
            n = next;
          }
        }
      }catch(e){/* ignore */}
    })();
  </script>

  <script>
  // Timeline functionality
  async function loadTimelineData() {
    try {
      const response = await fetch('/api/internal-scheduler/posts');
      const data = await response.json();
      window.timelineData = data.posts;
      await renderTimeline(data.posts);
    } catch (error) {
      console.error('B≈ÇƒÖd ≈Çadowania timeline:', error);
      document.getElementById('timeline-content').innerHTML = '<div style="color:#f44; padding:8px;">B≈ÇƒÖd ≈Çadowania timeline</div>';
    }
  }

  async function renderTimeline(posts) {
    const timelineContent = document.getElementById('timeline-content');
    const filterScheduled = document.getElementById('filter-scheduled').checked;
    const filterPublished = document.getElementById('filter-published').checked;
    const filterFailed = document.getElementById('filter-failed').checked;

    let allPosts = [];
    if (filterScheduled && posts.scheduled) allPosts = allPosts.concat(posts.scheduled);
    if (filterPublished && posts.published) allPosts = allPosts.concat(posts.published);
    if (filterFailed && posts.failed) allPosts = allPosts.concat(posts.failed);

    // Filtruj wg zakresu czasu
    const rangeEl = document.getElementById('timeline-range');
    const rangeVal = rangeEl ? rangeEl.value : '48h';
    let rangeMs = null;
    if (rangeVal === '24h') rangeMs = 24 * 3600 * 1000;
    else if (rangeVal === '48h') rangeMs = 48 * 3600 * 1000;
    else if (rangeVal === '7d') rangeMs = 7 * 24 * 3600 * 1000;
    const nowTs = Date.now();
    if (rangeMs) {
      allPosts = allPosts.filter(p => {
        const tsStr = p.published_at || p.scheduled_at || p.failed_at || p.created_at;
        if (!tsStr) return true;
        let d = new Date(tsStr);
        if (isNaN(d)) {
          const withTZ = /[Z+]/.test(tsStr) ? tsStr : (tsStr + '+00:00');
          d = new Date(withTZ);
        }
        return (nowTs - d.getTime()) <= rangeMs;
      });
    }

    if (allPosts.length === 0) {
      timelineContent.innerHTML = '<div style="color:#888; padding:8px;">Brak post√≥w do wy≈õwietlenia</div>';
      return;
    }

    // Sortuj posty wed≈Çug daty
    allPosts.sort((a, b) => new Date(b.scheduled_at || b.published_at || 0) - new Date(a.scheduled_at || a.published_at || 0));

    let html = '<div class="timeline-list">';
    
    // Pobierz dane klip√≥w dla wszystkich post√≥w
    const clipDataPromises = allPosts.map(async post => {
      try {
        const response = await fetch(`/api/clip-data/${post.clip_id}`);
        const data = await response.json();
        return { ...post, clipData: data.ok ? data : null };
      } catch (error) {
        console.error(`B≈ÇƒÖd pobierania danych klipu ${post.clip_id}:`, error);
        return { ...post, clipData: null };
      }
    });
    
    const postsWithClipData = await Promise.all(clipDataPromises);
    
    postsWithClipData.forEach(post => {
       // Poprawka strefy czasowej - u≈ºywaj scheduled_at zamiast scheduled_time
       const dateField = post.scheduled_at || post.published_at || post.failed_at;
       if (!dateField) {
         console.error('Brak daty dla posta:', post);
         return;
       }
       
       // Parsuj datƒô jako UTC i wy≈õwietl w czasie lokalnym
       const utcDate = new Date(dateField);
       if (isNaN(utcDate.getTime())) {
         console.error('Nieprawid≈Çowa data:', dateField);
         return;
       }
       
       const dateStr = utcDate.toLocaleDateString('pl-PL');
       const timeStr = utcDate.toLocaleTimeString('pl-PL', {hour: '2-digit', minute: '2-digit'});
       
      const statusText = getTimelineStatusText(post.status);
      const statusClass = post.status === 'pending' ? 'status-pending' : post.status === 'published' ? 'status-published' : 'status-failed';
      
      // Ujednolicone nazewnictwo: najpierw caption u≈ºytkownika, potem streamer - tytu≈Ç, inaczej clip_id
      let clipTitle = '';
      if (post.caption && post.caption.trim()) {
        clipTitle = post.caption.trim();
      } else if (post.clipData && post.clipData.broadcaster && post.clipData.title) {
        clipTitle = `${post.clipData.broadcaster} - ${post.clipData.title}`;
      } else {
        clipTitle = post.clip_id;
      }
      
      html += `
        <div class="timeline-item" onclick="window.open('/editor?clip=${encodeURIComponent(post.clip_id)}', '_blank')">
          <div class="timeline-item-title">${clipTitle}</div>
          <div class="timeline-item-meta">${dateStr} ${timeStr}</div>
          <div class="timeline-item-status ${statusClass}">${statusText}</div>
        </div>
      `;
    });
    html += '</div>';
    
    timelineContent.innerHTML = html;
  }

  function getTimelineStatusText(status) {
    switch(status) {
      case 'pending': return 'Zaplanowany';
      case 'published': return 'Opublikowany';
      case 'failed': return 'Nieudany';
      default: return status;
    }
  }


  async function resetFailedPosts() {
    try {
      const res = await fetch('/api/internal-scheduler/reset-failed', { method: 'POST' });
      const data = await res.json();
      if (data.success) {
        alert(`Zresetowano ${data.reset || data.reset_count || 0} post√≥w z failed do scheduled`);
      } else {
        alert(`B≈ÇƒÖd resetu: ${data.error || 'unknown'}`);
      }
      await loadTimelineData();
    } catch (e) {
      console.error('B≈ÇƒÖd resetu nieudanych:', e);
      alert('B≈ÇƒÖd resetu nieudanych');
    }
  }

  // Inicjalizacja timeline po pe≈Çnym za≈Çadowaniu DOM ‚Äì ≈Çaduj na ≈ºƒÖdanie
  document.addEventListener('DOMContentLoaded', () => {
    const btnToggleTimeline = document.getElementById('btn-toggle-timeline');
    const timelinePanel = document.querySelector('.timeline-container');
    if (btnToggleTimeline && timelinePanel && !btnToggleTimeline.hasAttribute('data-listeners-added')) {
      btnToggleTimeline.setAttribute('data-listeners-added','1');
      btnToggleTimeline.addEventListener('click', () => {
        const isOpen = timelinePanel.classList.toggle('open');
        if (isOpen && (!window.timelineData || !Array.isArray(window.timelineData))) {
          loadTimelineData().catch(console.error);
        }
      });
    }
    const btnRefresh = document.getElementById('btn-refresh-timeline');
    if (btnRefresh) btnRefresh.addEventListener('click', () => loadTimelineData().catch(console.error));
    const btnReset = document.getElementById('btn-reset-failed');
    if (btnReset) btnReset.addEventListener('click', () => resetFailedPosts());
    ['filter-scheduled','filter-published','filter-failed','timeline-range'].forEach(id => {
      const el = document.getElementById(id);
      if (el) el.addEventListener('change', () => window.timelineData && renderTimeline(window.timelineData));
    });
  });
  </script>
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  </body>
  </html>
