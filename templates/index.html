<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="utf-8">
  <title>StreamClipper ‚Äì Panel klip√≥w</title>
  <link rel="stylesheet" href="/static/style.css?v={{ cache_buster }}">
  <style>
    .dropdown-item:hover {
      background-color: #f8f9fa;
    }
    .dropdown-container.open .dropdown-menu {
      display: block !important;
    }

    /* Terminarz: karty klip√≥w (bez gradient√≥w, uk≈Çad grid) */
    .calendar-content {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .calendar-post {
      display: grid;
      grid-template-columns: 24px 1fr;
      align-items: center;
      gap: 12px;
      padding: 12px 14px;
      border-radius: 10px;
      background: #1c1f26; /* usuniƒôty gradient */
      border: 1px solid #2a2d34;
      box-shadow: 0 6px 16px rgba(0,0,0,0.35);
      min-height: 88px;
      transition: transform .12s ease, box-shadow .12s ease, border-color .12s ease;
      cursor: pointer;
    }
    .calendar-post:hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 22px rgba(0,0,0,0.45);
      border-color: #3a3f48;
    }

    .calendar-post-info {
      display: grid;
      grid-template-columns: 1fr auto;
      grid-template-rows: auto auto;
      column-gap: 12px;
      row-gap: 6px;
      align-items: start;
    }

    /* Tytu≈Ç: jedna linia, skr√≥cenie, sp√≥jna typografia */
    .calendar-post-title {
      grid-column: 1 / 2;
      grid-row: 1 / 2;
      font-size: 14px;
      font-weight: 600;
      color: #e5e7eb;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .calendar-post-date {
      grid-column: 1 / 2;
      grid-row: 2 / 3;
      font-size: 12px;
      color: #9ca3af;
    }

    /* Statusy: badge bez gradient√≥w */
    .calendar-post-status {
      grid-column: 2 / 3;
      grid-row: 1 / 2;
      justify-self: end;
      align-self: start;
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 700;
      letter-spacing: .02em;
      color: #0f172a;
      background: #e5e7eb; /* baza bez gradientu */
    }
    .status-scheduled { background: #34d399; color: #052e1f; }
    .status-published { background: #10b981; color: #06372c; }
    .status-failed { background: #ef4444; color: #3b0d0d; }

    .calendar-post-actions {
      grid-column: 2 / 3;
      grid-row: 2 / 3;
      justify-self: end;
      display: inline-flex;
      gap: 8px;
      align-items: center;
    }
    .calendar-post-actions .btn {
      padding: 6px 10px;
      border-radius: 8px;
      font-size: 12px;
      line-height: 1;
    }
    .calendar-post-actions .btn-danger {
      background: #b91c1c; /* bez gradientu */
      color: #fff;
      border: 1px solid #7f1d1d;
      box-shadow: 0 2px 8px rgba(239,68,68,.35);
    }
    .calendar-post-actions .btn-primary {
      background: #2563eb; /* bez gradientu */
      color: #fff;
      border: 1px solid #1d4ed8;
      box-shadow: 0 2px 8px rgba(37,99,235,.35);
    }
    .calendar-post-actions .btn-warning {
      background: #f59e0b; /* bez gradientu */
      color: #0b0b0b;
      border: 1px solid #b45309;
      box-shadow: 0 2px 8px rgba(245,158,11,.35);
    }
    .calendar-post-actions .btn:hover { filter: brightness(1.06); }
    .calendar-post-actions .btn:active { transform: translateY(1px); }

    /* Checkbox: p≈Çaski, bez gradientu */
    .calendar-post-checkbox,
    .calendar-filters input[type="checkbox"] {
      appearance: none;
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 4px;
      background: #2b2e36; /* bez gradientu */
      border: 2px solid #4b5563;
      position: relative;
      transition: all .12s ease;
      cursor: pointer;
      box-shadow: inset 0 1px 2px rgba(0,0,0,.4);
    }
    .calendar-post-checkbox:hover,
    .calendar-filters input[type="checkbox"]:hover { border-color: #6b7280; }
    .calendar-post-checkbox:checked,
    .calendar-filters input[type="checkbox"]:checked {
      border-color: #34d399;
      background: #1e3a2f; /* ciemna ziele≈Ñ, bez gradientu */
    }
    .calendar-post-checkbox:checked::after,
    .calendar-filters input[type="checkbox"]:checked::after {
      content: "";
      position: absolute;
      width: 6px; height: 10px;
      border-right: 2px solid #fff;
      border-bottom: 2px solid #fff;
      transform: rotate(45deg);
      left: 5px; top: 1px;
    }

    /* Filtry terminarza: wyglƒÖd jak wcze≈õniej, bez gradientu */
    .calendar-filters {
      display: inline-flex;
      gap: 14px;
      align-items: center;
      padding: 8px 12px;
      border-radius: 10px;
      background: #1f232b; /* bez gradientu */
      border: 1px solid #2b2f38;
      box-shadow: 0 6px 16px rgba(0,0,0,0.35);
      margin: 10px 0 14px;
    }
    .calendar-filters label {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      color: #e5e7eb;
      font-size: 13px;
      font-weight: 600;
      user-select: none;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>StreamClipper ‚Äì Panel klip√≥w</h1>
      <div class="actions">
        <!-- Przeniesiono przycisk Terminarza do sta≈Çego paska edytora -->
        <a href="/admin" id="admin-link" class="btn" title="Preferencje streamer√≥w">‚öôÔ∏è Panel admina</a>
        <span id="spinner" style="display:none;margin-left:8px;">‚è≥</span>
      </div>
      <div id="status" class="status"></div>
    <div id="progress-counter" class="status" style="display:none"></div>
    <div id="auto-refresh" class="status" style="margin-top:6px;">
      üîÅ Auto-od≈õwie≈ºanie za: <span id="refresh-timer">--:--</span>
      <div id="twitch-progress-bar" class="progress-bar" style="margin-top:6px; display:none;">
        <div id="progress-fill" class="progress-fill" style="width:0%"></div>
      </div>
    </div>
    <!-- Kick: progres analogiczny do Twitch -->
    <div id="kick-progress" class="status" style="margin-top:6px; display:none;">
      üü¢ Kick: postƒôp: <span id="progress-counter-kick">‚Äî</span>
      <div id="kick-progress-bar" class="progress-bar" style="margin-top:6px; display:none;">
        <div id="progress-fill-kick" class="progress-fill" style="width:0%"></div>
      </div>
    </div>
    </header>

    <div id="view-controls" class="subactions" style="margin:12px 0;">
      <button id="btn-hide-viewed" class="btn">Ukryj obejrzane</button>
      <div class="dropdown-container" style="position:relative; display:inline-block;">
        <button id="btn-open-unviewed" class="btn" style="background:#28a745; color:white;">üöÄ Otw√≥rz nieobejrzane</button>
        <div id="unviewed-dropdown" class="dropdown-menu" style="display:none; position:absolute; top:100%; left:0; background:white; border:1px solid #ddd; border-radius:4px; box-shadow:0 2px 10px rgba(0,0,0,0.1); z-index:1000; min-width:180px;">
          <button class="dropdown-item" data-limit="10" style="display:block; width:100%; padding:8px 12px; border:none; background:none; text-align:left; cursor:pointer;">üìã Otw√≥rz 10 klip√≥w</button>
          <button class="dropdown-item" data-limit="25" style="display:block; width:100%; padding:8px 12px; border:none; background:none; text-align:left; cursor:pointer;">üìã Otw√≥rz 25 klip√≥w</button>
          <button class="dropdown-item" data-limit="50" style="display:block; width:100%; padding:8px 12px; border:none; background:none; text-align:left; cursor:pointer;">üìã Otw√≥rz 50 klip√≥w</button>
          <button class="dropdown-item" data-limit="all" style="display:block; width:100%; padding:8px 12px; border:none; background:none; text-align:left; cursor:pointer;">üî• Otw√≥rz wszystkie</button>
        </div>
      </div>
      <span id="global-count" class="hint"></span>
    </div>

    <!-- Globalny pasek edytora: zawsze widoczny niezale≈ºnie od raportu -->
    <div id="global-editor-fixedbar" class="fixed-editor-bar" style="display:flex;">
      <div class="feb-left">
        <button id="btn-calendar" class="btn">üìÖ Terminarz</button>
      </div>
      <div class="feb-right">
        <button id="view-saved-fixed" class="btn">üëÅÔ∏è Poka≈º zapisane</button>
        <button id="proceed-editor-fixed" class="btn" disabled>‚û°Ô∏è Dalej do edytora</button>
      </div>
    </div>

    <main>
      <!-- G≈Ç√≥wna strona z raportami -->
      <div id="main-page" style="display:block;">
        <section id="raport-container" style="display:none;"></section>
        <section id="kick-report-container" style="display:none; margin-top:12px;"></section>
      </div>

      <!-- Osobna strona kalendarza -->
      <div id="calendar-page" style="display:none;">
        <div class="calendar-page-header">
          <button id="btn-back-to-main" class="btn btn-back">‚Üê Wr√≥ƒá</button>
          <h2>üìÖ Terminarz post√≥w</h2>
        </div>
        
        <section id="calendar-container" style="display:block;">
          <div class="calendar-header">
            <div class="calendar-controls">
              <button id="btn-select-all" class="btn">Zaznacz wszystkie</button>
              <button id="btn-deselect-all" class="btn">Odznacz wszystkie</button>
              <button id="btn-push-selected" class="btn btn-primary" disabled>üöÄ Push do Publera</button>
              <button id="btn-refresh-calendar" class="btn">üîÑ Od≈õwie≈º</button>
              <button id="btn-reset-failed" class="btn btn-danger">‚ôªÔ∏è Resetuj nieudane</button>
            </div>
          </div>
          
          <div class="calendar-filters">
            <label>
              <input type="checkbox" id="filter-scheduled" checked> Zaplanowane
            </label>
            <label>
              <input type="checkbox" id="filter-published" checked> Opublikowane
            </label>
            <label>
              <input type="checkbox" id="filter-failed"> Nieudane
            </label>
          </div>
          
          <div id="calendar-content" class="calendar-content">
            <div class="loading">≈Åadowanie terminarza...</div>
          </div>
        </section>
      </div>

<!-- Overlay zapisanych klip√≥w -->
<div id="saved-clips-panel" style="display:none; position:fixed; right:12px; bottom:56px; width:360px; max-height:50vh; overflow:auto; background:#15161a; border:1px solid #333; border-radius:6px; box-shadow:0 8px 24px rgba(0,0,0,0.4); padding:10px; z-index:999;"></div>
    </main>
  </div>

  <script type="text/javascript">
    const statusEl = document.getElementById('status');
  const progressCounter = document.getElementById('progress-counter');
    const raportContainer = document.getElementById('raport-container');
    const btnReport = document.getElementById('btn-report');
    const btnKick = document.getElementById('btn-kick');
    const spinner = document.getElementById('spinner');
    const refreshTimerEl = document.getElementById('refresh-timer');
    const progressFillEl = document.getElementById('progress-fill');
    const progressCounterKick = document.getElementById('progress-counter-kick');
    const progressFillElKick = document.getElementById('progress-fill-kick');
    const twitchProgressBar = document.getElementById('twitch-progress-bar');
    // Lokalne przyciski z fragmentu Twitch bƒôdƒÖ podpinane po wstrzykniƒôciu
    const kickProgressContainer = document.getElementById('kick-progress');
    const kickProgressBar = document.getElementById('kick-progress-bar');
    let kickProgressInterval = null;
    let kickStatusPollId = null;
    let kickReadyPollId = null;
    let kickFinishedHideTimeoutId = null;


    let reportReadyPoll = null;
    let reportStatusPoll = null;
    // Lokalny timer 15-minutowy i lekkie pollowanie tylko podczas generowania
    let nextRunAt = null;            // ms timestamp nastƒôpnego uruchomienia (lokalny)
    let countdownTimerId = null;     // setInterval id dla lokalnego odliczania
    let autoGenPollId = null;        // setInterval id pollowania statusu w trakcie generowania
    let autoGenReadyPollId = null;   // setInterval id pollowania gotowo≈õci raportu (Twitch)
    let autoGenKickReadyPollId = null; // setInterval id pollowania gotowo≈õci raportu Kick (cicho)
    let ensureKickMountPollId = null;  // sta≈Çy stra≈ºnik: je≈õli gotowy i kontener pusty, dociƒÖgnij fragment
    let autoGenActive = false;       // flaga: czy aktualnie trwa generowanie
    let autoTriggerStarted = false;  // stra≈ºnik: czy auto-trigger tego cyklu ju≈º wystartowa≈Ç
    let autoGenSeenActive = false;   // stra≈ºnik: czy w bie≈ºƒÖcym cyklu status by≈Ç aktywny
    let ensureTwitchMountPollId = null; // stra≈ºnik: po reloadzie dociƒÖgnij fragment Twitch, je≈õli gotowy
    // Guardy przeciw wielokrotnemu wczytaniu i wstrzykniƒôciu fragmentu Twitch
    if (typeof window.twitchFragmentLoaded === 'undefined') window.twitchFragmentLoaded = false;
    if (typeof window.twitchFragmentLoading === 'undefined') window.twitchFragmentLoading = false;
    // Guard na r√≥wnoleg≈Çe zapytania /api/report-ready
    let readyFetchLock = false;
    // Guard na r√≥wnoleg≈Çe zapytania /api/report-status
    let statusFetchLock = false;
    

    // Guardy przeciw wielokrotnemu wczytaniu i wstrzykniƒôciu fragmentu Twitch (duplikat ‚Äì usu≈Ñ)
    // [cleanup] usuniƒôto podw√≥jnƒÖ deklaracjƒô let twitchFragmentLoaded/twitchFragmentLoading

    // Ostatni znany status i koordynacja pollowania miƒôdzy wieloma podglƒÖdami
    let latestStatus = null;
    const LEADER_KEY = 'pollLeaderV1';
    const LATEST_STATUS_KEY = 'latestStatusV1';
    const LEADER_TTL_MS = 5000;
    const leaderId = Math.random().toString(36).slice(2);
    let isPollLeader = true; // leader disabled: ka≈ºda karta dzia≈Ça samodzielnie
    let leaderHeartbeatId = null;
    const nowMs = ()=>Date.now();
    const readLeader = ()=>{ try { return JSON.parse(localStorage.getItem(LEADER_KEY)||'null'); } catch{ return null; } };
    const writeLeader = (obj)=>{ try { localStorage.setItem(LEADER_KEY, JSON.stringify(obj)); } catch{} };
    const readLatest = ()=>{ try { return JSON.parse(localStorage.getItem(LATEST_STATUS_KEY)||'{}'); } catch{ return {}; } };
    const writeLatest = (p)=>{ try { localStorage.setItem(LATEST_STATUS_KEY, JSON.stringify(p||{})); } catch{} };
    function acquireLeaderIfPossible(){
      const cur = readLeader();
      const expired = !cur || !cur.ts || ((nowMs()-cur.ts) > LEADER_TTL_MS);
      if (expired || (cur && cur.id === leaderId)){
        isPollLeader = true;
        writeLeader({ id: leaderId, ts: nowMs() });
        if (leaderHeartbeatId) clearInterval(leaderHeartbeatId);
        leaderHeartbeatId = setInterval(()=>{ writeLeader({ id: leaderId, ts: nowMs() }); }, 2000);
      } else {
        isPollLeader = false;
        if (leaderHeartbeatId) { clearInterval(leaderHeartbeatId); leaderHeartbeatId = null; }
      }
    }
    function releaseLeader(){
      const cur = readLeader();
      if (cur && cur.id === leaderId){ try { localStorage.removeItem(LEADER_KEY); } catch{} }
      isPollLeader = false;
      if (leaderHeartbeatId) { clearInterval(leaderHeartbeatId); leaderHeartbeatId = null; }
    }
    window.addEventListener('storage', (e)=>{ if (e.key === LEADER_KEY) acquireLeaderIfPossible(); });
    document.addEventListener('visibilitychange', ()=>{ if (document.hidden) releaseLeader(); else acquireLeaderIfPossible(); });
    window.addEventListener('beforeunload', releaseLeader);
    setTimeout(acquireLeaderIfPossible, 0);

    // Obserwator: uruchamiaj oznaczanie NOWE po wstrzykniƒôciu/zmianie tre≈õci raportu
    function debounce(fn, wait){
      let t;
      return function(...args){
        try{ clearTimeout(t); }catch{}
        t = setTimeout(()=>{ try{ fn.apply(this, args); }catch{} }, wait);
      };
    }
    function setupMarkObservers(){
      try{
        const runMark = (root)=>{ if (!root) return; try{ markNewRowsAfterInject(root); updateGlobalCounters(); }catch{} };
        const twitchRoot = document.getElementById('raport-container');
        const kickRoot = document.getElementById('kick-report-container');
        const opts = { childList: true, subtree: true };
        if (twitchRoot){
          const obsT = new MutationObserver(debounce(()=>runMark(twitchRoot), 120));
          obsT.observe(twitchRoot, opts);
          runMark(twitchRoot);
          window.twitchMarkObserver = obsT;
        }
        if (kickRoot){
          const obsK = new MutationObserver(debounce(()=>runMark(kickRoot), 120));
          obsK.observe(kickRoot, opts);
          runMark(kickRoot);
          window.kickMarkObserver = obsK;
        }
      }catch{}
    }
    try{ setupMarkObservers(); }catch{}

    // Centralne czyszczenie wszystkich interwa≈Ç√≥w zwiƒÖzanych z pollowaniem
    function stopAllIntervals(){
      try{ if (autoGenPollId) { clearInterval(autoGenPollId); autoGenPollId = null; } }catch{}
      try{ if (autoGenReadyPollId) { clearInterval(autoGenReadyPollId); autoGenReadyPollId = null; } }catch{}
      try{ if (reportStatusPoll) { clearInterval(reportStatusPoll); reportStatusPoll = null; } }catch{}
      try{ if (reportReadyPoll) { clearInterval(reportReadyPoll); reportReadyPoll = null; } }catch{}
      try{ if (ensureTwitchMountPollId) { clearInterval(ensureTwitchMountPollId); ensureTwitchMountPollId = null; } }catch{}
      try{ if (ensureKickMountPollId) { clearInterval(ensureKickMountPollId); ensureKickMountPollId = null; } }catch{}
      try{ if (kickStatusPollId) { clearInterval(kickStatusPollId); kickStatusPollId = null; } }catch{}
      try{ if (kickReadyPollId) { clearInterval(kickReadyPollId); kickReadyPollId = null; } }catch{}
      // nie czy≈õcimy countdownTimerId ‚Äì timer ma dzia≈Çaƒá w trybie idle
    }

    // Selewtywne czyszczenie interwa≈Ç√≥w Twitch, bez ruszania pollowania Kick
    function stopTwitchIntervalsOnly(){
      try{ if (autoGenPollId) { clearInterval(autoGenPollId); autoGenPollId = null; } }catch{}
      try{ if (autoGenReadyPollId) { clearInterval(autoGenReadyPollId); autoGenReadyPollId = null; } }catch{}
      try{ if (reportStatusPoll) { clearInterval(reportStatusPoll); reportStatusPoll = null; } }catch{}
      try{ if (reportReadyPoll) { clearInterval(reportReadyPoll); reportReadyPoll = null; } }catch{}
      try{ if (ensureTwitchMountPollId) { clearInterval(ensureTwitchMountPollId); ensureTwitchMountPollId = null; } }catch{}
      // kickStatusPollId / kickReadyPollId / ensureKickMountPollId pozostajƒÖ aktywne
    }

    // Globalny licznik: sumuje Twitch + Kick (definicja na g√≥rze, aby uniknƒÖƒá b≈Çƒôd√≥w widoczno≈õci)
    function updateGlobalCounters(){
      try{
        const counterEl = document.getElementById('global-count');
        if (!counterEl) return;
        // Pobierz wiersze z obu raport√≥w (oba u≈ºywajƒÖ id `report-table` w fragmentach)
        const rows = Array.from(document.querySelectorAll('#report-table tbody tr'));
        let viewedArr = []; let newPendingArr = [];
        try { viewedArr = JSON.parse(localStorage.getItem('viewedClips')||'[]')||[]; } catch{}
        try { newPendingArr = JSON.parse(localStorage.getItem('newPendingClipIds')||'[]')||[]; } catch{}
        const viewedSet = new Set(viewedArr); const newPendingSet = new Set(newPendingArr);
        const clipIdFromUrl = (url)=>{ try{ const u = new URL(url); let last = u.pathname.split('/').filter(Boolean).pop()||'clip'; last = last.split('?')[0]; return last.replace(/[^a-zA-Z0-9_-]/g,'')||'clip'; }catch{ return 'clip'; } };
        let total = 0, newUnviewed = 0, viewedCount = 0;
        rows.forEach(tr=>{
          const cb = tr.querySelector('.clip-select');
          const url = cb ? cb.dataset.url : (tr.querySelector('a[href]')?.getAttribute('href')||'');
          const id = clipIdFromUrl(url);
          total++;
          const isViewed = viewedSet.has(id);
          const isNewPending = newPendingSet.has(id);
          if (isViewed) viewedCount++;
          if (isNewPending && !isViewed) newUnviewed++;
        });
        counterEl.textContent = `Nowe: ${newUnviewed} / Wszystkie: ${total} ‚Ä¢ Obejrzane: ${viewedCount}`;
      }catch{}
    }

    function formatMMSS(sec){
      try{ sec = Math.max(0, Math.floor(Number(sec)||0)); }catch{ sec = 0; }
      const m = Math.floor(sec/60); const s = sec%60;
      return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
    }

    // Wylicz lokalnie najbli≈ºsze 10 min (00, 10, 20, 30, 40, 50)
    function calcNextDecaminTimestamp(){
      const now = new Date();
      const s = now.getSeconds();
      const ms = now.getMilliseconds();
      const remainder = now.getMinutes() % 10;
      let addMin = 10 - remainder;
      // je≈õli jeste≈õmy idealnie na kwadransie, przejd≈∫ do nastƒôpnego
      if (remainder === 0 && s === 0 && ms === 0) addMin = 10;
      const nextMs = now.getTime() + addMin*60*1000 - s*1000 - ms;
      return nextMs;
    }

    function updateCountdown(){
      if (!nextRunAt){
        if (refreshTimerEl) refreshTimerEl.textContent = '--:--';
        return;
      }
      const now = Date.now();
      let diffSec = Math.floor((nextRunAt - now) / 1000);
      if (diffSec < 0) diffSec = 0;
      if (refreshTimerEl) refreshTimerEl.textContent = formatMMSS(diffSec);
      // Po doj≈õciu do zera: zawsze przeskocz na kolejne okno odliczania,
      // aby licznik nie "sta≈Ç" na 00:00 (nawet gdy trwa generowanie).
      if (diffSec === 0){
        nextRunAt = calcNextDecaminTimestamp();
        // Uruchom generowanie tylko raz, gdy nie trwa aktywny cykl
        if (!autoGenActive && !autoTriggerStarted){
          autoTriggerGeneration();
        }
      }
    }

    function startCountdown(){
      if (countdownTimerId) clearInterval(countdownTimerId);
      updateCountdown();
      countdownTimerId = setInterval(updateCountdown, 1000);
    }

    async function checkReadyOnce(){
      if (readyFetchLock) return false;
      readyFetchLock = true;
      try{
        const rr = await fetch('/api/report-ready');
        const rj = await rr.json();
        return !!(rj && rj.ready);
      }catch(e){ return false; }
      finally { readyFetchLock = false; }
    }

    function stopAutoGenerationPolling(){
      autoGenActive = false;
      if (autoGenPollId){ clearInterval(autoGenPollId); autoGenPollId = null; }
      if (autoGenReadyPollId){ clearInterval(autoGenReadyPollId); autoGenReadyPollId = null; }
    }

    // Kick: status polling i ≈Çadowanie raportu po gotowo≈õci
    function startKickStatusPolling(fromUserClick){
      console.log(`[Kick] startKickStatusPolling fromUserClick=${!!fromUserClick}`);
      // natychmiastowy odczyt
      (async ()=>{
        try{
          const r0 = await fetch('/api/report-kick-status', { cache: 'no-store' });
          const d0 = await r0.json();
          const p0 = d0 && d0.progress ? d0.progress : {};
          console.log('[Kick] immediate status:', p0);
          updateKickProgressUI(p0);
        }catch{}
      })();
      // cykliczny status
      if (kickStatusPollId) clearInterval(kickStatusPollId);
      kickStatusPollId = setInterval(async ()=>{
        try{
          const r = await fetch('/api/report-kick-status', { cache: 'no-store' });
          const d = await r.json();
          const p = d && d.progress ? d.progress : {};
          console.log('[Kick] status tick:', p);
          updateKickProgressUI(p);
          if (p.status === 'finished'){
            clearInterval(kickStatusPollId); kickStatusPollId = null;
            console.log('[Kick] status finished ‚Üí pollKick');
            try{ await pollKick(); }catch{}
          }
        }catch{}
      }, 2000);
      // gotowo≈õƒá co kilka sekund
      if (kickReadyPollId) clearInterval(kickReadyPollId);
      kickReadyPollId = setInterval(async ()=>{
        try{
          const rk = await fetch('/api/report-kick-ready', { cache: 'no-store' }).then(r=>r.json());
          console.log('[Kick] ready tick:', rk);
          if (rk && rk.ready){
            clearInterval(kickReadyPollId); kickReadyPollId = null;
            console.log('[Kick] ready=true ‚Üí pollKick');
            try{ await pollKick(); }catch{}
          }
        }catch{}
      }, fromUserClick ? 3000 : 5000);
    }

    function updateKickProgressUI(p){
      const st = p && p.status ? p.status : 'idle';
      const total = Number(p && p.total || 0);
      let label = '‚Äî'; let pct = 0;
      if (st === 'scraping'){
        label = '‚è≥ Skrobanie klip√≥w‚Ä¶'; pct = 5;
        if (kickProgressContainer) kickProgressContainer.style.display = 'block';
        if (kickProgressBar) kickProgressBar.style.display = 'block';
      } else if (st === 'generating'){
        label = total>0 ? `üîß Generowanie‚Ä¶ (klipy: ${total})` : 'üîß Generowanie‚Ä¶';
        pct = total>0 ? 70 : 50;
        if (kickProgressContainer) kickProgressContainer.style.display = 'block';
        if (kickProgressBar) kickProgressBar.style.display = 'block';
      } else if (st === 'finished'){
        label = '‚úÖ Gotowe'; pct = 100;
        if (kickProgressBar) kickProgressBar.style.display = 'none';
        if (kickProgressContainer) kickProgressContainer.style.display = 'block';
        if (kickFinishedHideTimeoutId) { clearTimeout(kickFinishedHideTimeoutId); }
        kickFinishedHideTimeoutId = setTimeout(()=>{
          if (kickProgressContainer) kickProgressContainer.style.display = 'none';
        }, 4000);
      } else {
        label = '‚Äî'; pct = 0;
        if (kickProgressContainer) kickProgressContainer.style.display = 'none';
        if (kickProgressBar) kickProgressBar.style.display = 'none';
      }
      if (progressCounterKick) progressCounterKick.textContent = label;
      if (progressFillElKick) progressFillElKick.style.width = pct + '%';
    }

    async function autoTriggerGeneration(){
      autoGenActive = true;
      autoTriggerStarted = true;
      autoGenSeenActive = false; // reset global stra≈ºnika aktywno≈õci dla nowego cyklu
      // Reset guard√≥w fragmentu na nowy cykl
      window.twitchFragmentLoaded = false;
      window.twitchFragmentLoading = false;
      // Przed startem nowego cyklu wyczy≈õƒá ewentualne stare interwa≈Çy pollowania
      try { stopAllIntervals(); } catch{}
      // Start generowania Twitch
      try { await fetch('/api/generate-raport'); } catch{}
      try { await fetch('/api/generate-raport-kick'); } catch(e) { console.warn('[Kick][auto] generate error:', e); }
      // Uruchom pollowanie postƒôpu Twitch
      if (twitchProgressBar) twitchProgressBar.style.display = 'block';
      if (progressCounter) { progressCounter.style.display = 'block'; progressCounter.textContent = '‚è≥ Przetworzono: 0 / 0'; }
      startAutoGenerationPolling();
      // Pollowanie Kick uruchamiaj zawsze z auto-triggera
      try{ console.log('[Kick][auto] start status polling'); startKickStatusPolling(false); }catch(e){ console.warn('[Kick][auto] status polling start error:', e); }
    }

    async function startAutoGenerationPolling(){
      autoGenActive = true;
      autoGenSeenActive = false; // reset na poczƒÖtku cyklu auto-pollowania
      // Pollowanie postƒôpu tylko w trakcie generowania (co 3s)
      if (autoGenPollId) clearInterval(autoGenPollId);
      autoGenPollId = setInterval(pollStatus, 3000);
      // Pollowanie gotowo≈õci raportu (co 3s)
      if (autoGenReadyPollId) clearInterval(autoGenReadyPollId);
      autoGenReadyPollId = setInterval(async ()=>{
        try{
          // Korzystaj z ostatniego statusu z pollStatus(), aby uniknƒÖƒá podw√≥jnych wywo≈Ça≈Ñ
          const p = latestStatus || {};
          if (p && p.status && p.status !== 'finished') { autoGenSeenActive = true; }
          if (p && p.status === 'finished' && autoGenSeenActive){
            const ready = await checkReadyOnce();
            if (ready){
              await loadTwitchFragmentOnce();
            }
          }
        }catch{}
      }, 3000);
      // Kick: bez pollowania w stanie idle ‚Äì wznowienie tylko po starcie cyklu
    }

    // Aktualizacja UI Twitch na podstawie statusu (bez fetch)
    function updateTwitchProgressFromStatus(p){
      try{
        const processed = Number(p && p.processed || 0);
        const total = Number(p && p.total || 0);
        const st = p && p.status ? p.status : 'idle';
        latestStatus = p || {};
        if (progressCounter){
          if (st === 'scraping' || st === 'generating' || st === 'running'){
            progressCounter.style.display = 'block';
            progressCounter.textContent = total>0 ? `‚è≥ Przetworzono: ${processed} / ${total}` : '‚è≥ Generowanie‚Ä¶';
          } else {
            progressCounter.style.display = 'none';
            progressCounter.textContent = '';
          }
        }
        if (progressFillEl){
          if (twitchProgressBar) twitchProgressBar.style.display = (st==='finished' || st==='idle') ? 'none' : 'block';
          const pct = total>0 ? Math.floor(processed*100/total) : 0;
          progressFillEl.style.width = pct + '%';
        }
        if (st && st !== 'finished') { autoGenSeenActive = true; }
      }catch{}
    }

    async function pollStatus(){
      // Nie pollowaƒá poza aktywnym cyklem
      if (!autoGenActive) return;
      // Guard przed r√≥wnoleg≈Çymi wywo≈Çaniami /api/report-status
      if (statusFetchLock) return;
      statusFetchLock = true;
      try{
        const rs = await fetch('/api/report-status');
        const data = await rs.json();
        const p = (data && data.progress) ? data.progress : {};
        latestStatus = p;
        writeLatest(p);
        updateTwitchProgressFromStatus(p);
        // Oznacz aktywno≈õƒá cyklu gdy status jest inny ni≈º 'finished'
        if (p && p.status && p.status !== 'finished') {
          autoGenSeenActive = true;
        }
        // Je≈õli status zako≈Ñczony i wcze≈õniej widziano aktywno≈õƒá ‚Äî wstrzyknij fragment bez rƒôcznego od≈õwie≈ºania
        if ((p.status === 'finished') && autoGenSeenActive) {
          try {
            const ready = await checkReadyOnce();
            if (ready) {
              await loadTwitchFragmentOnce();
            }
          } catch{}
        }
      }catch(e){ /* ignore */ }
      finally { statusFetchLock = false; }
    }

    const btnKickEl = document.getElementById('btn-kick');
    if (btnKickEl) {
      btnKickEl.onclick = async () => {
        if (btnKick.disabled) return;
        btnKick.disabled = true;
        const prevTxt = btnKick.textContent;
        btnKick.textContent = 'Generujƒô‚Ä¶';
        spinner.style.display = 'inline-block';
        // Wyzeruj pasek postƒôpu Kick i uruchom pollowanie statusu
        if (progressCounterKick) { progressCounterKick.textContent = '‚è≥ Generowanie‚Ä¶'; }
        if (progressFillElKick) { progressFillElKick.style.width = '0%'; }
        if (kickProgressContainer) kickProgressContainer.style.display = 'block';
        if (kickProgressBar) kickProgressBar.style.display = 'block';
        try {
          await fetch('/api/generate-raport-kick');
          startKickStatusPolling(true);
        } finally {
          btnKick.disabled = false;
          btnKick.textContent = prevTxt;
          spinner.style.display = 'none';
        }
      };
    }

function pollKick() {
  return fetch('/api/report-kick-ready', { cache: 'no-store' })
    .then(r=>r.json())
    .then(async (j) => {
      if (j && j.ready) {
        const bust = Date.now();
        const html = await fetch(`/raport-kick-fragment?v=${bust}`, { cache: 'no-store' }).then(r=>r.text());
        const kc = document.getElementById('kick-report-container');
        if (kc) {
          kc.innerHTML = html;
          try { kc.style.display = 'block'; } catch{}
          try { markNewRowsAfterInject(kc); } catch{}
          initReportFiltersAndStats(kc);
          // Reset calendar button text when showing kick report
          try { 
            const btnCalendar = document.getElementById('btn-calendar');
            if (btnCalendar) btnCalendar.textContent = 'üìÖ Terminarz';
          } catch{}
          // Zatrzymaj animacjƒô i poka≈º 100%
          if (kickProgressInterval) { clearInterval(kickProgressInterval); kickProgressInterval = null; }
          if (progressFillElKick) { progressFillElKick.style.width = '100%'; }
          if (progressCounterKick) { progressCounterKick.textContent = '‚úÖ Gotowe'; }
          try { updateGlobalCounters(); } catch{}
          if (kickProgressBar) kickProgressBar.style.display = 'none';
          if (kickFinishedHideTimeoutId) { clearTimeout(kickFinishedHideTimeoutId); }
          kickFinishedHideTimeoutId = setTimeout(()=>{
            if (kickProgressContainer) kickProgressContainer.style.display = 'none';
          }, 4000);
          // Proaktywnie zatrzymaj pollowanie Kick po wstrzykniƒôciu raportu
          if (kickStatusPollId) { clearInterval(kickStatusPollId); kickStatusPollId = null; }
          if (kickReadyPollId) { clearInterval(kickReadyPollId); kickReadyPollId = null; }
          if (ensureKickMountPollId) { clearInterval(ensureKickMountPollId); ensureKickMountPollId = null; }
          return true;
        }
      }
      return false;
    })
    .catch(()=>false);
}

    // 1) Od√Ö‚Ä∫wie√Ö¬º streamer√É¬≥w
    async function runUpdate() {
      const btn = document.getElementById('btn-update');
      if (btn.disabled) return;
      btn.disabled = true;
      const prev = btn.textContent;
      btn.textContent = 'Od√Ö‚Ä∫wie√Ö¬ºam√¢‚Ç¨¬¶';
      statusEl.textContent = 'üîÑ Od≈õwie≈ºanie streamer√≥w‚Ä¶';
      try {
        const res = await fetch('/api/update-streamers');
        const obj = await res.json();
        statusEl.textContent = obj.message || obj.error;
      } catch (e) {
        statusEl.textContent = 'B√Ö‚Äö√Ñ‚Ä¶d: ' + e;
      } finally {
        btn.disabled = false;
        btn.textContent = prev;
      }
    }

    // 2) Generowanie raportu i pollowanie gotowo√Ö‚Ä∫ci
    async function runReport() {
      const btn = btnReport;
      if (btn.disabled) return;
      // Przed rƒôcznym startem wyczy≈õƒá wszystkie interwa≈Çy pollowania
      try { stopTwitchIntervalsOnly(); } catch{}
      // Reset guard√≥w fragmentu przy rƒôcznym starcie cyklu
      window.twitchFragmentLoaded = false;
      window.twitchFragmentLoading = false;
      btn.disabled = true;
      const prev = btn.textContent;
      // Zabezpieczenie przed podw√≥jnym uruchomieniem (zbieg z autoTriggerem)
      autoGenActive = true;
      autoTriggerStarted = true;
      autoGenSeenActive = false; // wyzeruj globalny stra≈ºnik dla rƒôcznego cyklu
      let hasSeenActive = false; // lokalny stra≈ºnik dla tego cyklu
      btn.textContent = 'Generujƒô‚Ä¶';
      statusEl.textContent = 'üïí Rozpoczynam generowanie‚Ä¶';
      spinner.style.display = 'inline-block';
      if (progressCounter) {


      progressCounter.style.display = 'block';
      progressCounter.textContent = '‚è≥ Przetworzono: 0 / 0';
      }
      if (progressFillEl){ progressFillEl.style.width = '0%'; }
      try {
        await fetch('/api/generate-raport');
        statusEl.textContent = '‚åõ Czekam na raport‚Ä¶';
        // U≈ºywaj wy≈ÇƒÖcznie wsp√≥lnego mechanizmu auto-pollowania
        startAutoGenerationPolling();
        // Upewnij siƒô, ≈ºe Kick dalej pollowany podczas rƒôcznego cyklu Twitch
        try { startKickStatusPolling(true); } catch(e) { console.warn('[Kick][manual] status polling start error:', e); }
      } catch (e) {
        statusEl.textContent = 'B√Ö‚Äö√Ñ‚Ä¶d: ' + e;
        btn.disabled = false;
        btn.textContent = prev;
        spinner.style.display = 'none';
        if (progressCounter) {
          progressCounter.style.display = 'none';
          progressCounter.textContent = '';
        }
        if (progressFillEl){ progressFillEl.style.width = '0%'; }
        if (twitchProgressBar){ twitchProgressBar.style.display = 'none'; }
        if (reportReadyPoll) { clearInterval(reportReadyPoll); reportReadyPoll = null; }
        if (reportStatusPoll) { clearInterval(reportStatusPoll); reportStatusPoll = null; }
      }
    }

    // 3) Pobranie i wstrzykni√Ñ‚Ñ¢cie fragmentu raportu
    async function loadReportFragment() {
      const html = await fetch('/raport-fragment').then(r => r.text());
      // Stra≈ºnik: wstrzyknij raport tylko, je≈õli sƒÖ wiersze tabeli (realne dane)
      try {
        const tmp = document.createElement('div');
        tmp.innerHTML = html;
        const hasRows = tmp.querySelectorAll('#report-table tbody tr').length > 0;
        if (!hasRows) {
          // Nie pokazuj pustego raportu
          return false;
        }
      } catch {}
      raportContainer.innerHTML = html;
      try { raportContainer.style.display = 'block'; } catch{}
      try { initReportFiltersAndStats(raportContainer); } catch{}
      // Reset calendar button text when showing report
      try { 
        const btnCalendar = document.getElementById('btn-calendar');
        if (btnCalendar) btnCalendar.textContent = 'üìÖ Terminarz';
      } catch{}
      // Usuniƒôto lokalne przyciski; u≈ºywamy globalnego paska i overlayu zapisanych
      (function bindGlobalEditorButtons(){
        const proceedFixed = document.getElementById('fallback-proceed-editor');
        const viewSavedFixed = document.getElementById('fallback-view-saved');
        if (proceedFixed && !proceedFixed.dataset.bound){
          proceedFixed.dataset.bound = '1';
          proceedFixed.addEventListener('click', (e)=>{
            e.preventDefault();
            if (proceedFixed.disabled) return;
            const selected = savedAll();
            try {
              localStorage.setItem('pendingSelection', JSON.stringify({ clips: selected }));
              window.location.assign('/editor');
            } catch (e) {
              alert('Nie uda≈Ço siƒô zapisaƒá wyboru: ' + e);
            }
          });
        }
        if (viewSavedFixed && !viewSavedFixed.dataset.bound){
          viewSavedFixed.dataset.bound = '1';
          viewSavedFixed.addEventListener('click', (e)=>{
            e.preventDefault();
            let panel = document.getElementById('saved-clips-panel');
            if (!panel){
              panel = document.createElement('div');
              panel.id = 'saved-clips-panel';
              panel.className = 'saved-panel';
              panel.style.display = 'none';
              panel.style.position = 'fixed';
              panel.style.right = '16px';
              panel.style.bottom = '64px';
              panel.style.background = '#fafafa';
              panel.style.border = '1px solid #ddd';
              panel.style.borderRadius = '6px';
              panel.style.padding = '8px';
              panel.style.maxWidth = '360px';
              panel.style.zIndex = '9998';
              document.body.appendChild(panel);
            }
            if (panel.style.display === 'none' || !panel.style.display){ renderSavedPanel(panel); panel.style.display = 'block'; }
            else { panel.style.display = 'none'; }
          });
        }
        updateProceedState();
      })();
      initReportFiltersAndStats(raportContainer);
      // Po wstrzykniƒôciu: oznacz NOWE (trwa≈Çe do klikniƒôcia) i aktualizuj pamiƒôƒá
      markNewRowsAfterInject(raportContainer);
      try { updateGlobalCounters(); } catch{}
    }

    // Wstrzykniƒôcie fragmentu Twitch tylko raz i zatrzymanie ca≈Çego pollowania
    async function loadTwitchFragmentOnce(){
      if (window.twitchFragmentLoaded || window.twitchFragmentLoading) return false;
      window.twitchFragmentLoading = true;
      let ok = false;
      try {
        if (typeof window.loadReportFragment === 'function'){
          ok = await window.loadReportFragment();
        } else {
          ok = await loadReportFragment();
        }
      } catch(e){ ok = false; }
      // Niezale≈ºnie od powodzenia wstrzykniƒôcia ‚Äî zako≈Ñcz cykl i zatrzymaj pollowanie
      try { stopTwitchIntervalsOnly(); } catch{}
      autoGenActive = false;
      autoTriggerStarted = false;
      autoGenSeenActive = false;
      try{ if (twitchProgressBar) twitchProgressBar.style.display = 'none'; }catch{}
      try{ if (progressCounter) { progressCounter.style.display = 'none'; progressCounter.textContent = ''; } }catch{}
      try{ if (progressFillEl) progressFillEl.style.width = '0%'; }catch{}
      nextRunAt = calcNextDecaminTimestamp();
      startCountdown();
      window.twitchFragmentLoading = false;
      window.twitchFragmentLoaded = (ok !== false);
      return window.twitchFragmentLoaded;
    }

    // Oznaczanie nowych i obejrzanych po wstrzykniƒôciu fragmentu
    function markNewRowsAfterInject(root){
      if (!root) return;
      // Odczytaj dotychczasowe zbiory
      let known = [];
      let newPending = [];
      let viewed = [];
      try { known = JSON.parse(localStorage.getItem('knownClipIds')||'[]')||[]; } catch{}
      try { newPending = JSON.parse(localStorage.getItem('newPendingClipIds')||'[]')||[]; } catch{}
      try { viewed = JSON.parse(localStorage.getItem('viewedClips')||'[]')||[]; } catch{}
      const knownSet = new Set(known);
      const newPendingSet = new Set(newPending);
      const viewedSetLocal = new Set(viewed);

      const rows = Array.from(root.querySelectorAll('#report-table tbody tr'));
      const currentIds = [];
      rows.forEach(tr=>{
        const cb = tr.querySelector('.clip-select');
        const url = cb ? cb.dataset.url : (tr.querySelector('a[href]')?.getAttribute('href')||'');
        const id = window.clipIdFrom ? window.clipIdFrom(url) : url;
        currentIds.push(id);
      });
      // Zaktualizuj known (dodaj bie≈ºƒÖce id)
      const updatedKnown = Array.from(new Set([...knownSet, ...currentIds]));
      // NOWE = wszystkie nieobejrzane z bie≈ºƒÖcego widoku + poprzednie, po odfiltrowaniu obejrzanych
      const perContainerNew = currentIds.filter(id => !viewedSetLocal.has(id));
      const updatedNewPending = Array.from(new Set([...newPendingSet, ...perContainerNew])).filter(id=>!viewedSetLocal.has(id));
      try { localStorage.setItem('knownClipIds', JSON.stringify(updatedKnown)); } catch{}
      try { localStorage.setItem('newPendingClipIds', JSON.stringify(updatedNewPending)); } catch{}

      // Zastosuj klasy CSS w zale≈ºno≈õci od stanu
      const updatedNewSet = new Set(updatedNewPending);
      rows.forEach(tr=>{
        const cb = tr.querySelector('.clip-select');
        const url = cb ? cb.dataset.url : (tr.querySelector('a[href]')?.getAttribute('href')||'');
        const id = window.clipIdFrom ? window.clipIdFrom(url) : url;
        const isViewed = viewedSetLocal.has(id);
        const isNewPending = updatedNewSet.has(id);
        tr.classList.toggle('viewed-row', isViewed);
        tr.classList.toggle('new-row', isNewPending && !isViewed);
        tr.classList.toggle('new-unviewed', isNewPending && !isViewed);
      });
    }

    // 4) Inicjalizacja dropdown√É¬≥w i aplikacja filtr√É¬≥w
function initReportFiltersAndStats(root) {
  if (!root) return;

  // Globalny stan obejrzanych i filtra
  const hideViewedBtn = document.getElementById('btn-hide-viewed');
  const globalCountEl = document.getElementById('global-count');
  let viewedSet = new Set();
  try { viewedSet = new Set(JSON.parse(localStorage.getItem('viewedClips')||'[]').filter(x=>typeof x==='string')); } catch(e){ viewedSet = new Set(); }
  let hideViewed = false;
  try { hideViewed = JSON.parse(localStorage.getItem('hideViewed')||'false'); } catch(e){}
  if (hideViewedBtn){ hideViewedBtn.textContent = hideViewed ? 'Poka≈º obejrzane' : 'Ukryj obejrzane'; }

  // 1. Toggle dropdown√≥w tylko wewnƒÖtrz root
  root.querySelectorAll('.dropdown').forEach(dd => {
    const btn = dd.querySelector('button');
    if (btn) {
      btn.addEventListener('click', () => {
        dd.classList.toggle('open');
      });
    }
  });

  // 2. Pobierz wszystkie wiersze tabeli wewnƒÖtrz root
  const rows = Array.from(root.querySelectorAll('#report-table tbody tr'));

  // --- SORTOWANIE: Wy≈õwietlenia (domy≈õlnie) lub Czas (najnowsze) ---
  const tbody = root.querySelector('#report-table tbody');
  let sortKey = 'views';
  function parseRelativeTime(rel){
    if (!rel || typeof rel !== 'string') return null;
    const m = rel.match(/(\d+)\s*(d|h|m|s)/i);
    if (!m) return null;
    const val = parseInt(m[1], 10);
    const unit = m[2].toLowerCase();
    const now = Date.now();
    const ms = unit==='d'?val*24*3600*1000: unit==='h'?val*3600*1000: unit==='m'?val*60*1000: unit==='s'?val*1000: 0;
    return new Date(now - ms).getTime();
  }
  function createdTs(row){
    const iso = row.dataset.createdAt || '';
    const rel = (row.querySelector('td:nth-child(5)')?.textContent || '').trim();
    let t = iso ? Date.parse(iso) : NaN;
    if (isNaN(t)) { const approx = parseRelativeTime(rel); t = approx ?? 0; }
    return t;
  }
  function viewsVal(row){
    const attr = row.dataset.views;
    if (attr !== undefined){ const n = parseInt(attr, 10); if (!isNaN(n)) return n; }
    const txt = (row.querySelector('td:nth-child(4)')?.textContent || '').replace(/[^0-9]/g,'');
    const n2 = parseInt(txt, 10);
    return isNaN(n2) ? 0 : n2;
  }
  function applySort(){
    if (!tbody) return;
    const arr = Array.from(tbody.querySelectorAll('tr'));
    arr.sort((a,b)=> sortKey==='time' ? (createdTs(b)-createdTs(a)) : (viewsVal(b)-viewsVal(a)) );
    arr.forEach(tr=> tbody.appendChild(tr));
    // Pod≈õwietl aktywnƒÖ kolumnƒô sortowania
    if (thViews) thViews.classList.toggle('active-sort', sortKey==='views');
    if (thTime)  thTime.classList.toggle('active-sort',  sortKey==='time');
  }
  const thViews = root.querySelector('#report-table thead th.col-views') || root.querySelector('#report-table thead th:nth-child(4)');
  const thTime  = root.querySelector('#report-table thead th.col-time')  || root.querySelector('#report-table thead th:nth-child(5)');
  if (thViews) thViews.classList.add('sortable');
  if (thTime)  thTime.classList.add('sortable');
  if (thViews && !thViews.dataset.bound){ thViews.dataset.bound='1'; thViews.style.cursor='pointer'; thViews.title = thViews.title||'Kliknij, aby sortowaƒá po wy≈õwietleniach'; thViews.addEventListener('click', ()=>{ sortKey='views'; applySort(); }); }
  if (thTime && !thTime.dataset.bound){ thTime.dataset.bound='1'; thTime.style.cursor='pointer'; thTime.title = thTime.title||'Kliknij, aby sortowaƒá po czasie (najnowsze)'; thTime.addEventListener('click', ()=>{ sortKey='time'; applySort(); }); }
  applySort();

  // Zaznacz jako obejrzany po klikniƒôciu linku
  root.addEventListener('click', (e)=>{
    const a = e.target.closest('a[href]');
    if (!a) return;
    if (!root.contains(a)) return;
    const tr = a.closest('tr');
    if (!tr) return;
    const cb = tr.querySelector('.clip-select');
    const url = cb ? cb.dataset.url : a.getAttribute('href');
    const id = clipIdFromUrl(url);
    if (!viewedSet.has(id)){
      viewedSet.add(id);
      try { localStorage.setItem('viewedClips', JSON.stringify(Array.from(viewedSet))); } catch(e){}
    }
    // Usu≈Ñ z pending nowych je≈õli zosta≈Ç obejrzany
    try {
      const pending = JSON.parse(localStorage.getItem('newPendingClipIds')||'[]')||[];
      const updated = pending.filter(x=>x!==id);
      localStorage.setItem('newPendingClipIds', JSON.stringify(updated));
    } catch(e){}
    // Re-render bez reloadu (po klikniƒôciu i tak otwiera siƒô karta, ale UI od≈õwie≈ºamy natychmiast)
    applyFiltersAndStats();
    try { updateGlobalCounters(); } catch{}
  }, true);

  // Czy w tym widoku istnieje filtrowanie po kategoriach?
  const hasCategoryFiltering = root.querySelectorAll('.filter-category').length > 0;

  // Pomocnicze: id klipu z data-url (deklaracja funkcji hoistowana)
  function clipIdFromUrl(url){
    try{
      const u = new URL(url);
      let last = u.pathname.split('/').filter(Boolean).pop()||'clip';
      last = last.split('?')[0];
      return last.replace(/[^a-zA-Z0-9_-]/g,'')||'clip';
    }catch{ return 'clip'; }
  }

  // 3. Funkcja filtrujƒÖca + aktualizujƒÖca statystyki
  function applyFiltersAndStats() {
    // a) streamerzy
    const ignoredStreamers = new Set(
      Array.from(root.querySelectorAll('.filter-streamer'))
        .filter(cb => !cb.checked).map(cb => cb.value)
    );
    // b) kategorie (opcjonalne)
    const ignoredCategories = new Set(
      hasCategoryFiltering
        ? Array.from(root.querySelectorAll('.filter-category'))
            .filter(cb => !cb.checked).map(cb => cb.value)
        : []
    );

    let newCount = 0;
    // Odczytaj bie≈ºƒÖce newPending (NOWE)
    let newPendingArr = [];
    try { newPendingArr = JSON.parse(localStorage.getItem('newPendingClipIds')||'[]')||[]; } catch{}
    const newPendingSet = new Set(newPendingArr);
    // Tryb pokazywania tylko nowych
    const visible = [];
    rows.forEach(row => {
      const st = row.dataset.streamer;
      const ct = row.dataset.category;
      // ≈πr√≥d≈Ço URL klipu: preferuj przycisk .add-to-editor, inaczej fallback do linku w tytule
      const btn = row.querySelector('.add-to-editor');
      const hrefLink = row.querySelector('a[href]');
      const url = (btn && btn.dataset.url) ? btn.dataset.url : (hrefLink ? hrefLink.getAttribute('href') || '' : '');
      const id = clipIdFromUrl(url);
      const isViewed = viewedSet.has(id);
      const hideByStreamer = ignoredStreamers.has(st);
      const hideByCategory = hasCategoryFiltering ? ignoredCategories.has(ct) : false;
      const hideByViewed = hideViewed && isViewed === true;
      // Stylowanie: obejrzane i nowe
      if (isViewed){
        row.classList.add('viewed-row');
        row.classList.remove('new-unviewed');
      } else {
        row.classList.remove('viewed-row');
        if (row.classList.contains('new-row')) row.classList.add('new-unviewed');
      }
      const isNewPending = newPendingSet.has(id);
      const hide = hideByStreamer || hideByCategory || hideByViewed;
      row.style.display = hide ? 'none' : '';
      if (isNewPending && !isViewed) newCount++;
      if (!hide) visible.push(row);
      // Oznaczenie NOWE w tytule
      const titleLink = row.querySelector('a[title]');
      if (titleLink){
        const baseTitle = titleLink.getAttribute('title') || '';
        const badge = ' [NOWE]';
        if (!isViewed && !baseTitle.includes(' [NOWE]')){
          titleLink.setAttribute('title', baseTitle + badge);
        } else if (isViewed && baseTitle.includes(' [NOWE]')){
          titleLink.setAttribute('title', baseTitle.replace(' [NOWE]',''));
        }
      }
    });

    // c) oblicz statystyki
    const total = visible.length;
    const catCounts = {}, strCounts = {};
    visible.forEach(r => {
      const st = r.dataset.streamer;
      strCounts[st] = (strCounts[st]||0)+1;
      if (hasCategoryFiltering) {
        const ct = r.dataset.category;
        if (ct !== undefined) {
          catCounts[ct] = (catCounts[ct]||0)+1;
        }
      }
    });
    const topCats = hasCategoryFiltering
      ? Object.entries(catCounts).sort((a,b)=>b[1]-a[1]).slice(0,3)
      : [];
    const topStr = Object.entries(strCounts)
      .sort((a,b)=>b[1]-a[1]).slice(0,3);

    // d) wstaw do root, nie do document (i tylko je≈õli elementy istniejƒÖ)
    const totalEl = root.querySelector('#stats-total');
    if (totalEl) totalEl.textContent = total;

    const catsEl = root.querySelector('#stats-categories');
    if (catsEl) catsEl.textContent = topCats.map(([c,n])=>`${c} (${n})`).join(', ');

    const strEl = root.querySelector('#stats-streamers');
    if (strEl) strEl.textContent = topStr.map(([s,n])=>`${s} (${n})`).join(', ');

    applySort();
    // e) lokalne liczniki zostawiamy, globalny licznik zsumujemy poni≈ºej
  }

  // 4. Pod≈ÇƒÖcz przyciski filtr√≥w tylko wewnƒÖtrz root (z guardami)
  const applyStreamersBtn = root.querySelector('#apply-streamers');
  if (applyStreamersBtn) {
    applyStreamersBtn.addEventListener('click', ()=>{
      applyFiltersAndStats();
      const ddS = root.querySelector('#dd-streamers');
      if (ddS) ddS.classList.remove('open');
      try { updateGlobalCounters(); } catch{}
    });
  }

  const applyCategoriesBtn = root.querySelector('#apply-categories');
  if (applyCategoriesBtn) {
    applyCategoriesBtn.addEventListener('click', ()=>{
      applyFiltersAndStats();
      const ddC = root.querySelector('#dd-categories');
      if (ddC) ddC.classList.remove('open');
      try { updateGlobalCounters(); } catch{}
    });
  }

  // 5. Kolejka edytora: dodawanie per klip, zapisane i przej≈õcie
  const proceedBtn = root.querySelector('#twitch-proceed-editor') || root.querySelector('#kick-proceed-editor');
  const viewSavedBtn = root.querySelector('#twitch-view-saved') || root.querySelector('#kick-view-saved');
  const isTwitch = !!root.querySelector('#twitch-report-root');
  const currentSource = isTwitch ? 'Twitch' : 'Kick';
  // Lekki, estetyczny popup (toast) przy g√≥rze ekranu
  function showToast(message, type='info'){
    try{
      let rootEl = document.getElementById('toast-root');
      if (!rootEl){
        rootEl = document.createElement('div');
        rootEl.id = 'toast-root';
        rootEl.style.cssText = 'position:fixed;top:12px;left:50%;transform:translateX(-50%);z-index:9999;display:flex;flex-direction:column;gap:8px;';
        document.body.appendChild(rootEl);
      }
      const t = document.createElement('div');
      t.textContent = message;
      t.style.cssText = 'background:#1f2937;color:#fff;padding:8px 12px;border-radius:8px;box-shadow:0 8px 20px rgba(0,0,0,0.20);border:1px solid rgba(255,255,255,0.08);font-size:14px;opacity:0;transform:translateY(-6px);transition:opacity .25s ease, transform .25s ease;';
      if (type==='success'){ t.style.background = '#14532d'; t.style.borderColor = '#166534'; }
      if (type==='error'){ t.style.background = '#7f1d1d'; t.style.borderColor = '#991b1b'; }
      rootEl.appendChild(t);
      requestAnimationFrame(()=>{ t.style.opacity = '1'; t.style.transform = 'translateY(0)'; });
      setTimeout(()=>{
        t.style.opacity = '0';
        t.style.transform = 'translateY(-6px)';
        setTimeout(()=>{ try{ t.remove(); }catch{} }, 300);
      }, 2500);
    }catch{}
  }
  const readSavedClips = () => { try { return JSON.parse(localStorage.getItem('savedClips')||'[]')||[]; } catch { return []; } };
  const writeSavedClips = (arr) => { try { localStorage.setItem('savedClips', JSON.stringify(arr)); } catch {} };
  // Wsp√≥lna kolejka klip√≥w (Twitch + Kick)
  // Zapisy pozostajƒÖ z polem source, ale operacje UI dzia≈ÇajƒÖ na ca≈Çej li≈õcie
    const savedAll = () => readSavedClips();
    const clipIdFrom = (url)=>{ try{ const u = new URL(url); let last = u.pathname.split('/').filter(Boolean).pop()||url; return last.split('?')[0]; }catch{ return url; } };
    const getProceedBtn = () => document.querySelector('#raport-container #twitch-proceed-editor');
    const updateProceedState = () => {
      const disabled = savedAll().length===0;
      const localProceed = getProceedBtn();
      if (localProceed) localProceed.disabled = disabled;
      const fab = document.getElementById('proceed-fab');
      if (fab) { fab.disabled = disabled; }
      const proceedFixed = document.getElementById('proceed-editor-fixed');
      if (proceedFixed) proceedFixed.disabled = disabled;
      const proceedFallback = document.getElementById('fallback-proceed-editor');
      if (proceedFallback) proceedFallback.disabled = disabled;
    };

    // Global: panel zapisanych (u≈ºywany przez fallback i lokalny panel)
    function renderSavedPanel(panel){
      if (!panel) return;
      const clips = savedAll();
      if (!clips.length){
        panel.innerHTML = '<div class="hint">Brak zapisanych klip√≥w.</div>';
      } else {
        const items = clips.map(c=>`<li data-url="${c.url}"><a href="${c.url}" target="_blank">${(c.title||c.url).replace(/"/g,'&quot;')}</a> <span class="hint">(${c.broadcaster||'?'}${c.source?' ‚Ä¢ '+c.source:''})</span> <button class="btn btn-small remove-saved" data-url="${c.url}">Usu≈Ñ</button></li>`).join('');
        panel.innerHTML = `<div style="margin-bottom:6px;"><strong>Zapisane klipy (${clips.length}):</strong></div><ul style="margin:0; padding-left:20px;">${items}</ul>`;
      }
    }
    // Uczy≈Ñ najwa≈ºniejsze funkcje dostƒôpne globalnie, aby uniknƒÖƒá ReferenceError
    try {
      window.readSavedClips = readSavedClips;
      window.writeSavedClips = writeSavedClips;
      window.savedAll = savedAll;
      window.renderSavedPanel = renderSavedPanel;
      window.clipIdFrom = clipIdFrom;
    } catch {}

    

    // Global fallback: oznaczanie obejrzanych po klikniƒôciu linku w tabeli
    document.addEventListener('click', (e)=>{
      const a = e.target.closest('#raport-container #report-table a[href], #kick-report-container #report-table a[href]');
      if (!a) return;
      const href = a.getAttribute('href')||'';
      const id = (window.clipIdFrom ? window.clipIdFrom(href) : href);
      let viewedSet = new Set();
      try{ viewedSet = new Set(JSON.parse(localStorage.getItem('viewedClips')||'[]')); }catch{}
      if (!viewedSet.has(id)){
        viewedSet.add(id);
        try{ localStorage.setItem('viewedClips', JSON.stringify(Array.from(viewedSet))); }catch{}
      }
      try { if (typeof applyFiltersAndStats === 'function') applyFiltersAndStats(); } catch {}
      try { markViewedRowsGeneric(); } catch{}
      try { updateGlobalCounters(); } catch{}
    }, true);

    // Uniwersalne od≈õwie≈ºenie klas obejrzanych dla Twitch i Kick
    function markViewedRowsGeneric(){
      // Odczyt aktualnego stanu
      let viewedArr = [];
      try { viewedArr = JSON.parse(localStorage.getItem('viewedClips')||'[]')||[]; } catch {}
      const viewedSet = new Set(viewedArr);
      let newPendingArr = [];
      try { newPendingArr = JSON.parse(localStorage.getItem('newPendingClipIds')||'[]')||[]; } catch{}
      const newPendingSet = new Set(newPendingArr);
      let hideViewed = false;
      try { hideViewed = JSON.parse(localStorage.getItem('hideViewed')||'false'); } catch{}
      let showOnlyNew = false;
      try { showOnlyNew = JSON.parse(localStorage.getItem('showOnlyNew')||'false'); } catch{}
      ['#raport-container', '#kick-report-container'].forEach(rootSel=>{
        const root = document.querySelector(rootSel);
        if (!root) return;
        const rows = root.querySelectorAll('#report-table tbody tr');
        rows.forEach(row=>{
          const btn = row.querySelector('.add-to-editor');
          const hrefLink = row.querySelector('a[href]');
          const url = (btn && btn.dataset.url) ? btn.dataset.url : (hrefLink ? hrefLink.getAttribute('href')||'' : '');
          const id = window.clipIdFrom ? window.clipIdFrom(url) : url;
          const isViewed = viewedSet.has(id);
          const isNewPending = newPendingSet.has(id);
          // Aktualizuj klasy, bez ingerencji w display (logikƒô ukrywania robi applyFiltersAndStats)
          row.classList.toggle('viewed-row', isViewed);
          row.classList.toggle('new-row', isNewPending && !isViewed);
          row.classList.toggle('new-unviewed', isNewPending && !isViewed);
          // Nie zmieniaj bezpo≈õrednio row.style.display tutaj, aby nie nadpisaƒá filtr√≥w streamer/kategoria
        });
      });
    }

    // Fallback: poka≈º/ukryj globalne przyciski, gdy nie ma lokalnego przycisku w raporcie
    function toggleFallbackControls(show){
      const fc = document.getElementById('fallback-editor-controls');
      if (!fc) return;
      fc.style.display = show ? 'flex' : 'none';
      updateProceedState();
    }

    // Podpiƒôcie zdarze≈Ñ dla fallback przycisk√≥w
    (function bindFallbackControls(){
      const proceedFallback = document.getElementById('fallback-proceed-editor');
      const viewSavedFallback = document.getElementById('fallback-view-saved');
      if (proceedFallback && !proceedFallback.dataset.bound){
        proceedFallback.dataset.bound = '1';
        proceedFallback.addEventListener('click', (e)=>{
          e.preventDefault();
          if (proceedFallback.disabled) return;
          const selected = savedAll();
          try {
            localStorage.setItem('pendingSelection', JSON.stringify({ clips: selected }));
            window.location.assign('/editor');
          } catch (e) {
            alert('Nie uda≈Ço siƒô zapisaƒá wyboru: ' + e);
          }
        });
      }
      if (viewSavedFallback && !viewSavedFallback.dataset.bound){
        viewSavedFallback.dataset.bound = '1';
        viewSavedFallback.addEventListener('click', (e)=>{
          e.preventDefault();
          let panel = document.getElementById('saved-clips-panel');
          if (!panel){
            panel = document.createElement('div');
            panel.id = 'saved-clips-panel';
            panel.className = 'saved-panel';
            panel.style.display = 'none';
            panel.style.position = 'fixed';
            panel.style.right = '16px';
            panel.style.bottom = '64px';
            panel.style.background = 'var(--panel-bg)';
            panel.style.border = '1px solid var(--border)';
            panel.style.borderRadius = '6px';
            panel.style.padding = '8px';
            panel.style.maxWidth = '360px';
            panel.style.zIndex = '9998';
            panel.style.color = 'var(--text)';
            panel.style.boxShadow = '0 8px 24px rgba(0,0,0,0.35)';
            document.body.appendChild(panel);
          }
          if (panel.style.display === 'none' || !panel.style.display){ renderSavedPanel(panel); panel.style.display = 'block'; }
          else { panel.style.display = 'none'; }
        });
      }
      updateProceedState();
    })();
    // Je≈õli globalny pasek istnieje, upewnij siƒô, ≈ºe ma podpiƒôte zdarzenia
    (function ensureFixedBarEvents(){
      const proceedFixed = document.getElementById('proceed-editor-fixed');
      const viewSavedFixed = document.getElementById('view-saved-fixed');
      if (proceedFixed && !proceedFixed.dataset.bound){
        proceedFixed.dataset.bound = '1';
        proceedFixed.addEventListener('click', (e)=>{
          e.preventDefault();
          if (proceedFixed.disabled) return;
          const selected = savedAll();
          try { localStorage.setItem('pendingSelection', JSON.stringify({ clips: selected })); window.location.assign('/editor'); }
          catch (e) { alert('Nie uda≈Ço siƒô zapisaƒá wyboru: ' + e); }
        });
      }
      if (viewSavedFixed && !viewSavedFixed.dataset.bound){
        viewSavedFixed.dataset.bound = '1';
        viewSavedFixed.addEventListener('click', (e)=>{
          e.preventDefault();
          let panel = document.querySelector('#raport-container #saved-clips-panel') || document.getElementById('saved-clips-panel');
          if (!panel){
            panel = document.createElement('div');
            panel.id = 'saved-clips-panel';
            panel.className = 'saved-panel';
            panel.style.display = 'none';
            panel.style.position = 'fixed';
            panel.style.right = '16px';
            panel.style.bottom = '64px';
            panel.style.background = '#fafafa';
            panel.style.border = '1px solid #ddd';
            panel.style.borderRadius = '6px';
            panel.style.padding = '8px';
            panel.style.maxWidth = '360px';
            panel.style.zIndex = '9998';
            document.body.appendChild(panel);
          }
          if (panel.style.display === 'none' || !panel.style.display){ renderSavedPanel(panel); panel.style.display = 'block'; }
          else { panel.style.display = 'none'; }
        });
      }
      updateProceedState();
    })();

    // Nowy globalny handler: przyciski ‚ûï/‚úñ w kolumnie ‚ÄûAkcja‚Äù (Twitch + Kick)
    (function bindGlobalAddRemove(){
      function detectSource(url){
        try {
          const u = new URL(url, window.location.origin);
          const h = (u.hostname||'').toLowerCase();
          if (h.includes('kick.com')) return 'Kick';
          if (h.includes('twitch.tv') || h.includes('clips.twitch.tv')) return 'Twitch';
        } catch {}
        return '';
      }
      function syncButtons(url, added){
        try{
          document.querySelectorAll(`.add-to-editor[data-url="${url}"]`).forEach(b=>{
            b.classList.toggle('added', !!added);
            b.textContent = added ? '‚úñ' : '‚ûï';
            b.style.minWidth = '28px';
            b.style.textAlign = 'center';
          });
        }catch{}
      }
      function refreshSavedPanelIfOpen(){
        try{
          const panel = document.getElementById('saved-clips-panel');
          if (panel && panel.style.display !== 'none'){ renderSavedPanel(panel); }
        }catch{}
      }
      // Guard: nie dopuszczaj do wielokrotnego bindowania handlera
      if (!window.__queueToggleBound){
        window.__queueToggleBound = true;
        const onDocClickToggle = (e)=>{
          const btn = e.target.closest('.add-to-editor');
          if (!btn) return;
          e.preventDefault();
          // zatrzymaj propagacjƒô, aby uniknƒÖƒá ewentualnych dubli
          if (typeof e.stopImmediatePropagation === 'function') e.stopImmediatePropagation();
          // Globalny deduplikator: ignoruj kolejne klikniƒôcie tego samego klipu w kr√≥tkim oknie czasowym
          const urlGuard = btn.dataset.url || '';
          const idGuard = clipIdFrom(urlGuard);
          try{
            if (!window.__toggleGuard) window.__toggleGuard = new Map();
            const last = window.__toggleGuard.get(idGuard) || 0;
            const now = performance.now ? performance.now() : Date.now();
            if (now - last < 300) return; // zbyt szybko ‚Äì potraktuj jako duplikat
            window.__toggleGuard.set(idGuard, now);
          }catch{}
          // Lokalny busy-guard na sam przycisk (dla bezpiecze≈Ñstwa)
          if (btn.dataset.busy) return;
          btn.dataset.busy = '1';
          setTimeout(()=>{ try { delete btn.dataset.busy; } catch{} }, 150);

          const url = btn.dataset.url || '';
          const broadcaster = btn.dataset.broadcaster || '';
          const title = btn.dataset.title || '';
          const id = clipIdFrom(url);
          let saved = readSavedClips();
          const exists = saved.some(x=> clipIdFrom(x.url)===id);
          if (exists){
            saved = saved.filter(x=> clipIdFrom(x.url)!==id);
            writeSavedClips(saved);
            syncButtons(url, false);
            try{ showToast('Usuniƒôto z kolejki', 'success'); }catch{}
          } else {
            const source = detectSource(url);
            saved.push({ url, broadcaster, title, source });
            writeSavedClips(saved);
            syncButtons(url, true);
            try{ showToast('Dodano do kolejki edytora', 'success'); }catch{}
          }
          refreshSavedPanelIfOpen();
          updateProceedState();
        };
        document.addEventListener('click', onDocClickToggle);
        // Silny guard: usuwaj i ponownie podpinaj handler przy ka≈ºdej pe≈Çnej wymianie fragmentu raportu,
        // aby uniknƒÖƒá dublowania w sytuacjach dynamicznego montowania (generowanie raportu Twitch/Kick)
        const originalLoadReportFragment = window.loadReportFragment;
        if (typeof originalLoadReportFragment === 'function'){
          window.loadReportFragment = async function(){
            // Zdejmij nas≈Çuch przed pe≈ÇnƒÖ wymianƒÖ fragmentu
            try{ document.removeEventListener('click', onDocClickToggle); }catch{}
            let res;
            try{
              res = await originalLoadReportFragment();
            } finally {
              // Przywr√≥ƒá nas≈Çuch ZAWSZE, nawet je≈õli wystƒÖpi b≈ÇƒÖd/abort
              try{ document.addEventListener('click', onDocClickToggle); }catch{}
            }
            return res;
          };
        }
        const originalPollKick = window.pollKick;
        if (typeof originalPollKick === 'function'){
          window.pollKick = async function(){
            try{ document.removeEventListener('click', onDocClickToggle); }catch{}
            let v;
            try{
              v = await originalPollKick();
            } finally {
              try{ document.addEventListener('click', onDocClickToggle); }catch{}
            }
            return v;
          };
        }
      }
    })();
  // Pasywna synchronizacja UI dla nielider√≥w: nas≈Çuch zmian latestStatus w localStorage
  try{
    window.addEventListener('storage', (e)=>{
      try{
        if (e && e.key === LATEST_STATUS_KEY){
          const p = JSON.parse(e.newValue||'{}');
          updateTwitchProgressFromStatus(p);
        }
      }catch{}
    });
    // Jednorazowa aktualizacja z ostatniego stanu (je≈õli istnieje)
    try{ const p0 = readLatest(); if (p0 && p0.status){ updateTwitchProgressFromStatus(p0); } }catch{}
  }catch{}
  // Inicjalna synchronizacja ikon +/‚úñ z zapisanymi klipami
  (function initAddButtons(){
    try{
      const saved = savedAll();
      document.querySelectorAll('.add-to-editor').forEach(b=>{
        const id = clipIdFrom(b.dataset.url);
        const exists = saved.some(x=>clipIdFrom(x.url)===id);
        if (exists){ b.classList.add('added'); b.textContent = '‚úñ'; }
        else { b.classList.remove('added'); b.textContent = '‚ûï'; }
      });
    }catch{}
  })();
  // Podpinanie lokalnego przycisku po wstrzykniƒôciu fragmentu Twitch

  // 5b. Panel zapisanych + usuwanie (panel lokalny w Twitch fragmencie)
  // Dodawanie pojedynczego klipu z wiersza tabeli
  // (usuniƒôto: lokalny handler klikniƒôƒá .add-to-editor)

  // (usuniƒôto: efekty hover dla .add-to-editor)
  // Usuwanie z panelu zapisanych
  root.addEventListener('click', (e)=>{
    const rm = e.target.closest('.remove-saved');
    if (!rm) return;
    e.preventDefault();
    const url = rm.dataset.url;
    const all = readSavedClips();
    // Usuwamy po id klipu (niezale≈ºnie od ≈∫r√≥d≈Ça), aby kolejka by≈Ça globalna
    const filtered = all.filter(c=>clipIdFrom(c.url) !== clipIdFrom(url));
    writeSavedClips(filtered);
    // Od≈õwie≈º panel tylko je≈õli jest widoczny
    try{
      const panel = document.getElementById('saved-clips-panel');
      if (panel && panel.style.display !== 'none'){ renderSavedPanel(panel); }
    }catch{}
    updateProceedState();
    try{
      // Odblokuj wszystkie odpowiadajƒÖce przyciski w obu raportach
      document.querySelectorAll(`.add-to-editor[data-url="${url}"]`).forEach(rowBtn=>{
        rowBtn.classList.remove('added');
        rowBtn.textContent = '‚ûï';
      });
    }catch{}
  });
  // Globalny overlay: obs≈Çuga usuwania zapisanych poza raportem Twitch/Kick
  document.addEventListener('click', (e)=>{
    const rm = e.target.closest('.remove-saved');
    if (!rm) return;
    // je≈õli klik by≈Ç wewnƒÖtrz root, zosta≈Ç ju≈º obs≈Çu≈ºony powy≈ºej
    if (root.contains(rm)) return;
    e.preventDefault();
    const url = rm.dataset.url;
    const all = readSavedClips();
    const filtered = all.filter(c=>clipIdFrom(c.url) !== clipIdFrom(url));
    writeSavedClips(filtered);
    showToast('Usuniƒôto z kolejki', 'success');
    try{
      document.querySelectorAll(`.add-to-editor[data-url="${url}"]`).forEach(rowBtn=>{
        rowBtn.classList.remove('added');
        rowBtn.textContent = '‚ûï';
      });
    }catch{}
    try{
      const panel = document.getElementById('saved-clips-panel');
      if (panel && panel.style.display !== 'none'){ renderSavedPanel(panel); }
    }catch{}
    updateProceedState();
  });
  // Przycisk "Poka≈º zapisane" lokalny bƒôdzie podpinany po wstrzykniƒôciu

  // 6. Reakcja na przycisk Ukryj/Poka≈º obejrzane
  if (hideViewedBtn){
    hideViewedBtn.addEventListener('click', ()=>{
      hideViewed = !hideViewed;
      try{ localStorage.setItem('hideViewed', JSON.stringify(hideViewed)); }catch(e){}
      hideViewedBtn.textContent = hideViewed ? 'Poka≈º obejrzane' : 'Ukryj obejrzane';
      try { if (typeof applyFiltersAndStats === 'function') applyFiltersAndStats(); } catch{}
      try { markViewedRowsGeneric(); } catch{}
      try { updateGlobalCounters(); } catch{}
    });
  }

  // 7. Obs≈Çuga dropdown dla otwierania nieobejrzanych klip√≥w
  const openUnviewedBtn = document.getElementById('btn-open-unviewed');
  const unviewedDropdown = document.getElementById('unviewed-dropdown');
  const dropdownContainer = openUnviewedBtn?.parentElement;

  if (openUnviewedBtn && unviewedDropdown && !openUnviewedBtn.hasAttribute('data-listeners-added')) {
    // Oznacz, ≈ºe event listenery zosta≈Çy dodane
    openUnviewedBtn.setAttribute('data-listeners-added', 'true');
    
    // Toggle dropdown
    openUnviewedBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      dropdownContainer.classList.toggle('open');
    });

    // Zamknij dropdown po klikniƒôciu poza nim
    const closeDropdown = () => {
      dropdownContainer.classList.remove('open');
    };
    document.addEventListener('click', closeDropdown);

    // Obs≈Çuga opcji dropdown
    unviewedDropdown.addEventListener('click', (e) => {
      e.stopPropagation();
      const limit = e.target.dataset.limit;
      if (limit) {
        openUnviewedClips(limit);
        dropdownContainer.classList.remove('open');
      }
    });
  }

  // Funkcja otwierania nieobejrzanych klip√≥w
  let isOpeningClips = false;
  function openUnviewedClips(limit) {
    try {
      // Zabezpieczenie przed wielokrotnym wywo≈Çaniem
      if (isOpeningClips) {
        console.log('openUnviewedClips already in progress, ignoring call');
        return;
      }
      isOpeningClips = true;
      
      // Pobierz listƒô obejrzanych klip√≥w
      const viewedSet = new Set(JSON.parse(localStorage.getItem('viewedClips') || '[]'));
      console.log('Viewed clips:', Array.from(viewedSet));
      
      // Znajd≈∫ wszystkie nieobejrzane klipy z aktualnie widocznej tabeli
      const unviewedClips = [];
      const rows = document.querySelectorAll('tbody tr');
      console.log('Total rows found:', rows.length);
      
      rows.forEach((row, index) => {
        // Sprawd≈∫ czy wiersz jest ukryty
        const isHidden = row.style.display === 'none';
        if (isHidden) {
          console.log(`Row ${index} is hidden, skipping`);
          return;
        }
        
        // Znajd≈∫ link do klipu w wierszu (trzecia kolumna z tytu≈Çem)
        const clipLink = row.querySelector('td:nth-child(3) a[target="_blank"]');
        if (!clipLink) {
          console.log(`Row ${index}: No clip link found`);
          return;
        }
        
        const clipUrl = clipLink.href;
        const clipId = clipIdFromUrl(clipUrl);
        console.log(`Row ${index}: URL=${clipUrl}, ID=${clipId}, viewed=${viewedSet.has(clipId)}`);
        
        if (clipId && !viewedSet.has(clipId)) {
          unviewedClips.push({ id: clipId, url: clipUrl });
          console.log(`Added clip ${clipId} to unviewed list`);
        }
      });

      console.log('Total unviewed clips found:', unviewedClips.length);
      if (unviewedClips.length === 0) {
        alert('Brak nieobejrzanych klip√≥w do otwarcia!');
        return;
      }

      // Okre≈õl liczbƒô klip√≥w do otwarcia
      let clipsToOpen = unviewedClips;
      if (limit !== 'all') {
        const limitNum = parseInt(limit);
        clipsToOpen = unviewedClips.slice(0, limitNum);
        console.log(`Limiting to ${limitNum} clips from ${unviewedClips.length} total`);
      }
      console.log('Clips to open:', clipsToOpen.length);

      // Potwierdzenie dla du≈ºej liczby kart
      if (clipsToOpen.length > 20) {
        const confirmed = confirm(`Czy na pewno chcesz otworzyƒá ${clipsToOpen.length} kart? To mo≈ºe spowolniƒá przeglƒÖdarkƒô.`);
        if (!confirmed) return;
      }

      // Otw√≥rz klipy w nowych kartach i oznacz jako obejrzane
      clipsToOpen.forEach((clip, index) => {
        console.log(`Scheduling clip ${index + 1}/${clipsToOpen.length}: ${clip.url}`);
        setTimeout(() => {
          console.log(`Opening clip ${index + 1}: ${clip.url}`);
          // Otw√≥rz prawdziwy URL klipu (Kick/Twitch)
          window.open(clip.url, '_blank');
          
          // Oznacz jako obejrzany
          viewedSet.add(clip.id);
          try {
            localStorage.setItem('viewedClips', JSON.stringify(Array.from(viewedSet)));
            console.log(`Marked clip ${clip.id} as viewed`);
          } catch(e) {
            console.error('Error saving to localStorage:', e);
          }
        }, index * 100); // Op√≥≈∫nienie 100ms miƒôdzy otwieraniem kart
      });

      // Od≈õwie≈º widok po oznaczeniu jako obejrzane
      setTimeout(() => {
        try {
          if (typeof markViewedRowsGeneric === 'function') markViewedRowsGeneric();
          if (typeof updateGlobalCounters === 'function') updateGlobalCounters();
        } catch(e) {}
      }, clipsToOpen.length * 100 + 500);

      alert(`Otwarto ${clipsToOpen.length} klip√≥w w nowych kartach!`);
      
      // Resetuj flagƒô po zako≈Ñczeniu
      setTimeout(() => {
        isOpeningClips = false;
      }, clipsToOpen.length * 100 + 1000);
      
    } catch (error) {
      console.error('B≈ÇƒÖd podczas otwierania klip√≥w:', error);
      alert('WystƒÖpi≈Ç b≈ÇƒÖd podczas otwierania klip√≥w.');
      isOpeningClips = false; // Resetuj flagƒô w przypadku b≈Çƒôdu
    }
  }

  // Przycisk "Poka≈º tylko nowe" / "Poka≈º wszystkie"
  // usuniƒôto przycisk trybu ‚Äûtylko nowe", pozostaje filtr obejrzanych

  // Floating FAB: poka≈º przycisk "Dalej do edytora" w prawym dolnym rogu, gdy lokalny przycisk niewidoczny
  function setupProceedFabFor(localBtn){
    let fab = document.getElementById('proceed-fab');
    if (!fab){
      fab = document.createElement('button');
      fab.id = 'proceed-fab';
      fab.className = 'btn fab-proceed';
      fab.textContent = '‚û°Ô∏è Dalej do edytora';
      fab.style.display = 'none';
      document.body.appendChild(fab);
      fab.addEventListener('click', (e)=>{
        e.preventDefault();
        if (fab.disabled) return;
        const selected = savedAll();
        try {
          localStorage.setItem('pendingSelection', JSON.stringify({ clips: selected }));
          window.location.assign('/editor');
        } catch (e) {
          alert('Nie uda≈Ço siƒô zapisaƒá wyboru: ' + e);
        }
      });
    }
    if (!localBtn){ fab.style.display = 'none'; return; }
    try { if (window._fabObserver) { window._fabObserver.disconnect(); } } catch{}
    const io = new IntersectionObserver((entries)=>{
      const visible = entries.some(en=>en.isIntersecting);
      fab.style.display = (!visible) ? 'block' : 'none';
      fab.disabled = savedAll().length===0;
    }, { threshold: 0.3 });
    io.observe(localBtn);
    window._fabObserver = io;
    updateProceedState();
  }

  // 7. Pierwsze wyliczenie
  applyFiltersAndStats();
  updateGlobalCounters();
}

  // (usuniƒôto zduplikowanƒÖ definicjƒô updateGlobalCounters; funkcja jest zdefiniowana na g√≥rze skryptu)

    // Pod√Ö‚Äö√Ñ‚Ä¶czamy eventy do przycisk√É¬≥w
    try {
      const elUpd = document.getElementById('btn-update');
      if (elUpd) elUpd.addEventListener('click', runUpdate);
      const elRep = document.getElementById('btn-report');
      if (elRep) elRep.addEventListener('click', runReport);
    } catch{}

    // Auto-od≈õwie≈ºanie: ca≈Çkowicie lokalny timer bez zapyta≈Ñ do backendu
    window.addEventListener('load', async ()=>{
      console.log('[Kick] window.load: start');
      nextRunAt = calcNextDecaminTimestamp();
      startCountdown();
      // Nie sprawdzaj gotowo≈õci Twitch na starcie; ograniczamy wywo≈Çania API
      // (fragment Twitch zostanie za≈Çadowany dopiero po generowaniu)
      // UWAGA: Na starcie nie odpytywaƒá Kick (status/ready). Uruchamiamy tylko
      // lokalny licznik i Twitch fragment (je≈õli gotowy). Kick odpytujemy dopiero
      // gdy u≈ºytkownik kliknie lub gdy timer dojdzie do zera (autoTriggerGeneration).
      // Wymu≈õ ukrycie UI Kick na starcie (bez generowania)
      try{
        if (kickProgressContainer) kickProgressContainer.style.display = 'none';
        if (kickProgressBar) kickProgressBar.style.display = 'none';
        if (progressCounterKick) progressCounterKick.textContent = '‚Äî';
      }catch{}
      // Zaktualizuj globalny licznik po starcie (guard na istnienie funkcji)
      try { if (typeof updateGlobalCounters === 'function') updateGlobalCounters(); } catch {}
      // Przywr√≥ƒá pasek postƒôpu po od≈õwie≈ºeniu na podstawie ostatniego statusu
      try {
        const persisted = readLatest();
        const st = persisted && persisted.status ? persisted.status : 'idle';
        if (st === 'scraping' || st === 'generating' || st === 'running'){
          // Wznowienie cyklu: poka≈º pasek i uruchom wsp√≥lne pollowanie
          autoGenActive = true;
          autoTriggerStarted = true; // zapobiegaj podw√≥jnemu startowi
          autoGenSeenActive = true;
          try { updateTwitchProgressFromStatus(persisted); } catch{}
          try{ if (twitchProgressBar) twitchProgressBar.style.display = 'block'; }catch{}
          if (autoGenPollId) clearInterval(autoGenPollId);
          if (autoGenReadyPollId) clearInterval(autoGenReadyPollId);
          startAutoGenerationPolling();
        } else if (st === 'finished') {
          // Je≈õli zako≈Ñczone: spr√≥buj wstrzyknƒÖƒá utrwalony raport bez pollowania
          try {
            const isReady = await checkReadyOnce();
            if (isReady) { await loadTwitchFragmentOnce(); }
          } catch{}
          autoGenActive = false;
          autoTriggerStarted = false;
          autoGenSeenActive = false;
          try{ if (twitchProgressBar) twitchProgressBar.style.display = 'none'; }catch{}
          try{ if (progressCounter) { progressCounter.style.display = 'none'; progressCounter.textContent = ''; } }catch{}
          try{ if (progressFillEl) progressFillEl.style.width = '0%'; }catch{}
        } else {
          // Idle: licz wy≈ÇƒÖcznie lokalny countdown, bez pollowania backendu
          autoGenActive = false;
          autoTriggerStarted = false;
          autoGenSeenActive = false;
          try{ if (twitchProgressBar) twitchProgressBar.style.display = 'none'; }catch{}
          try{ if (progressCounter) { progressCounter.style.display = 'none'; progressCounter.textContent = ''; } }catch{}
          try{ if (progressFillEl) progressFillEl.style.width = '0%'; }catch{}
        }
      } catch {}
      // Fallback: je≈õli lokalny przycisk Twitch nie istnieje ‚Üí poka≈º globalne przyciski
      try{
        const hasLocalProceed = !!document.querySelector('#raport-container #twitch-proceed-editor');
        toggleFallbackControls(true);
      }catch{}
      // Stra≈ºnik po reloadzie: je≈õli raport Twitch jest gotowy, a kontener pusty ‚Äî dociƒÖgnij fragment
      try {
        if (ensureTwitchMountPollId) clearInterval(ensureTwitchMountPollId);
        ensureTwitchMountPollId = setInterval(async ()=>{
          try {
            const tc = document.getElementById('raport-container');
            const hasContent = !!(tc && tc.innerHTML && tc.innerHTML.trim().length);
            if (!autoGenActive && !hasContent) {
              const isReady = await checkReadyOnce();
              if (isReady) {
                const injected = await loadTwitchFragmentOnce();
                if (injected && ensureTwitchMountPollId) { clearInterval(ensureTwitchMountPollId); ensureTwitchMountPollId = null; }
              }
            }
          } catch {}
        }, 3000);
      } catch {}
      // Stra≈ºnik po reloadzie: Kick ‚Äì je≈õli gotowy i kontener pusty, dociƒÖgnij fragment bez rƒôcznego od≈õwie≈ºania
      try {
        if (ensureKickMountPollId) clearInterval(ensureKickMountPollId);
        ensureKickMountPollId = setInterval(async ()=>{
          try {
            const kc = document.getElementById('kick-report-container');
            const hasKickContent = !!(kc && kc.innerHTML && kc.innerHTML.trim().length);
            if (!hasKickContent) {
              const rk = await fetch('/api/report-kick-ready', { cache: 'no-store' }).then(r=>r.json());
              if (rk && rk.ready) {
                const bust = Date.now();
                const htmlK = await fetch(`/raport-kick-fragment?v=${bust}`, { cache: 'no-store' }).then(r=>r.text());
                // Poka≈º tylko je≈õli sƒÖ wiersze z danymi
                let canShowKick = false;
                try {
                  const tmpK = document.createElement('div');
                  tmpK.innerHTML = htmlK;
                  canShowKick = tmpK.querySelectorAll('#report-table tbody tr').length > 0;
                } catch {}
                if (kc && canShowKick) {
                  kc.innerHTML = htmlK;
                  try { kc.style.display = 'block'; } catch{}
                  try { markNewRowsAfterInject(kc); } catch{}
                  initReportFiltersAndStats(kc);
                  try { updateGlobalCounters(); } catch{}
                  if (ensureKickMountPollId) { clearInterval(ensureKickMountPollId); ensureKickMountPollId = null; }
                }
              }
            }
          } catch {}
        }, 3000);
      } catch {}
      try {
        // Kick: po za≈Çadowaniu strony uruchom tylko pollowanie statusu,
        // bez natychmiastowego wstrzykiwania starego raportu.
        try { startKickStatusPolling(false); } catch{}
        
      } catch {}
      // Usuniƒôto fallback sta≈Çego paska; wykorzystujemy tylko lokalny przycisk + FAB
    });
  </script>
  <script>
    // Logika lidera wy≈ÇƒÖczona ‚Äî wszystkie karty dzia≈ÇajƒÖ samodzielnie
  </script>
  
  <script>
    // Calendar/Scheduler functionality
    let calendarData = [];
    let selectedPosts = new Set();
    
    // SPA Navigation State
    let currentPage = 'main'; // 'main' or 'calendar'
    let savedReportsState = {
      twitchVisible: false,
      kickVisible: false,
      twitchContent: '',
      kickContent: ''
    };

    // SPA Navigation Functions
    function showMainPage() {
      document.getElementById('main-page').style.display = 'block';
      document.getElementById('calendar-page').style.display = 'none';
      currentPage = 'main';
      
      // Restore reports state
      const raportContainer = document.getElementById('raport-container');
      const kickReportContainer = document.getElementById('kick-report-container');
      
      if (savedReportsState.twitchContent) {
        raportContainer.innerHTML = savedReportsState.twitchContent;
      }
      if (savedReportsState.kickContent) {
        kickReportContainer.innerHTML = savedReportsState.kickContent;
      }
      
      if (savedReportsState.twitchVisible && savedReportsState.twitchContent) {
        raportContainer.style.display = 'block';
      }
      if (savedReportsState.kickVisible && savedReportsState.kickContent) {
        kickReportContainer.style.display = 'block';
      }
      
      // Check if we should resume polling based on last known status
      try {
        const persisted = readLatest();
        const st = persisted && persisted.status ? persisted.status : 'idle';
        if (st === 'scraping' || st === 'generating' || st === 'running') {
          // Resume polling if report generation is in progress
          autoGenActive = true;
          startAutoGenerationPolling();
        }
      } catch(e) {
        console.warn('Error checking status for polling resume:', e);
      }
    }

    function showCalendarPage() {
      // Save current reports state
      const raportContainer = document.getElementById('raport-container');
      const kickReportContainer = document.getElementById('kick-report-container');
      
      savedReportsState.twitchVisible = raportContainer.style.display === 'block';
      savedReportsState.kickVisible = kickReportContainer.style.display === 'block';
      savedReportsState.twitchContent = raportContainer.innerHTML;
      savedReportsState.kickContent = kickReportContainer.innerHTML;
      
      // Stop any active polling when showing calendar
      try {
        stopAutoGenerationPolling();
      } catch(e) {
        console.warn('Error stopping polling:', e);
      }
      
      // Switch to calendar page
      document.getElementById('main-page').style.display = 'none';
      document.getElementById('calendar-page').style.display = 'block';
      currentPage = 'calendar';
      
      // Load calendar data
      loadCalendarData().catch(console.error);
    }

    // Initialize SPA navigation
    document.addEventListener('DOMContentLoaded', function() {
      const btnCalendar = document.getElementById('btn-calendar');
      const btnBackToMain = document.getElementById('btn-back-to-main');
      
      // Calendar button click handler
      btnCalendar.addEventListener('click', function() {
        showCalendarPage();
      });
      
      // Back button click handler
      btnBackToMain.addEventListener('click', function() {
        showMainPage();
      });
      
      // Calendar controls
      document.getElementById('btn-select-all').addEventListener('click', selectAllPosts);
      document.getElementById('btn-deselect-all').addEventListener('click', deselectAllPosts);
      document.getElementById('btn-push-selected').addEventListener('click', pushSelectedToPubler);
      document.getElementById('btn-refresh-calendar').addEventListener('click', loadCalendarData);
      const btnResetFailed = document.getElementById('btn-reset-failed');
      if (btnResetFailed) btnResetFailed.addEventListener('click', resetFailedPosts);
      
      // Filter checkboxes
      document.getElementById('filter-scheduled').addEventListener('change', filterCalendarData);
      document.getElementById('filter-published').addEventListener('change', filterCalendarData);
      document.getElementById('filter-failed').addEventListener('change', filterCalendarData);
    });
    
    async function loadCalendarData() {
      try {
        const response = await fetch('/api/internal-scheduler/posts');
        const data = await response.json();
        
        calendarData = [
          ...data.posts.scheduled.map(post => ({...post, status: 'scheduled'})),
          ...data.posts.published.map(post => ({...post, status: 'published'})),
          ...data.posts.failed.map(post => ({...post, status: 'failed'}))
        ];
        
        await renderCalendar();
      } catch (error) {
        console.error('Error loading calendar data:', error);
        document.getElementById('calendar-content').innerHTML = 
          '<div class="loading">B≈ÇƒÖd ≈Çadowania danych terminarza</div>';
      }
    }
    
    async function renderCalendar() {
      const content = document.getElementById('calendar-content');
      const scheduledFilter = document.getElementById('filter-scheduled').checked;
      const publishedFilter = document.getElementById('filter-published').checked;
      const failedFilter = document.getElementById('filter-failed').checked;
      
      let filteredData = calendarData.filter(post => {
        if (post.status === 'scheduled' && !scheduledFilter) return false;
        if (post.status === 'published' && !publishedFilter) return false;
        if (post.status === 'failed' && !failedFilter) return false;
        return true;
      });
      
      if (filteredData.length === 0) {
        content.innerHTML = '<div class="loading">Brak post√≥w do wy≈õwietlenia</div>';
        return;
      }
      
      // Pobierz dane klip√≥w dla wszystkich post√≥w
      const clipDataPromises = filteredData.map(async post => {
        try {
          const response = await fetch(`/api/clip-data/${post.clip_id}`);
          const data = await response.json();
          return { ...post, clipData: data.ok ? data : null };
        } catch (error) {
          console.error(`B≈ÇƒÖd pobierania danych klipu ${post.clip_id}:`, error);
          return { ...post, clipData: null };
        }
      });
      
      const postsWithClipData = await Promise.all(clipDataPromises);
      
      const html = postsWithClipData.map(post => {
        const isSelected = selectedPosts.has(post.id || post.clip_id);
        const postId = post.id || post.clip_id;
        
        // Ujednolicone nazewnictwo: najpierw caption, potem streamer - tytu≈Ç
        let title = '';
        if (post.caption && post.caption.trim()) {
          title = post.caption.trim();
        } else if (post.clipData && post.clipData.broadcaster && post.clipData.title) {
          title = `${post.clipData.broadcaster} - ${post.clipData.title}`;
        } else {
          title = `Post ${postId}`;
        }
        
        const date = post.scheduled_at || post.published_at || post.created_at || 'Brak daty';
        // Poprawka strefy czasowej - parsuj datƒô jako UTC i wy≈õwietl w czasie lokalnym
        const utcDate = new Date(date);
        const formattedDate = utcDate.toLocaleString('pl-PL');
        
        return `
          <div class="calendar-post" style="cursor:pointer;" 
               onclick="window.open('/editor?clip=${encodeURIComponent(post.clip_id)}', '_blank')">
            <input type="checkbox" class="calendar-post-checkbox" 
                   data-post-id="${postId}" ${isSelected ? 'checked' : ''} 
                   onclick="event.stopPropagation();">
            <div class="calendar-post-info">
              <div class="calendar-post-title">${title}</div>
              <div class="calendar-post-date">${formattedDate}</div>
              <div class="calendar-post-status status-${post.status}">${getStatusText(post.status)}</div>
              <div class="calendar-post-actions" onclick="event.stopPropagation();">
                ${post.status === 'scheduled' ? 
                  `<button class=\"btn btn-sm\" onclick=\"editPostTime('${postId}', '${date}')\">Edytuj czas</button>
                   <button class=\"btn btn-sm\" onclick=\"pushSinglePost('${postId}')\">Push</button>
                   <button class=\"btn btn-sm btn-danger\" onclick=\"deleteScheduledPost('${postId}')\">Usu≈Ñ</button>` : 
                  (post.status === 'failed' ?
                  `<button class=\"btn btn-sm btn-warning\" onclick=\"retryFailedPost('${postId}')\">Pon√≥w</button>` :
                  '')}
              </div>
            </div>
          </div>
        `;
      }).join('');
      
      content.innerHTML = html;
      
      // Add event listeners to checkboxes
      content.querySelectorAll('.calendar-post-checkbox').forEach(checkbox => {
        checkbox.addEventListener('change', function() {
          const postId = this.dataset.postId;
          if (this.checked) {
            selectedPosts.add(postId);
          } else {
            selectedPosts.delete(postId);
          }
          updatePushButton();
        });
      });
    }
    
    function getStatusText(status) {
      switch(status) {
        case 'scheduled': return 'Zaplanowany';
        case 'published': return 'Opublikowany';
        case 'failed': return 'Nieudany';
        default: return status;
      }
    }
    
    function selectAllPosts() {
      const checkboxes = document.querySelectorAll('.calendar-post-checkbox');
      checkboxes.forEach(checkbox => {
        checkbox.checked = true;
        selectedPosts.add(checkbox.dataset.postId);
      });
      updatePushButton();
    }
    

    async function resetFailedPosts() {
      try {
        const res = await fetch('/api/internal-scheduler/reset-failed', { method: 'POST' });
        const data = await res.json();
        if (data.success) {
          alert(`Zresetowano ${data.reset || data.reset_count || 0} post√≥w z failed do scheduled`);
        } else {
          alert(`B≈ÇƒÖd resetu: ${data.error || 'unknown'}`);
        }
        await loadCalendarData();
      } catch (e) {
        console.error('B≈ÇƒÖd resetu nieudanych:', e);
        alert('B≈ÇƒÖd resetu nieudanych');
      }
    }

    async function retryFailedPost(postId) {
      try {
        const res = await fetch(`/api/internal-scheduler/retry-failed/${postId}`, { method: 'POST' });
        const data = await res.json();
        if (res.ok && data.success) {
          alert(`Ponowiono publikacjƒô: ${postId}`);
        } else {
          alert(`Nie uda≈Ço siƒô ponowiƒá: ${data.error || res.status}`);
        }
        await loadCalendarData();
      } catch (e) {
        console.error('B≈ÇƒÖd ponowienia publikacji:', e);
        alert('B≈ÇƒÖd ponowienia publikacji');
      }
    }
    
    function deselectAllPosts() {
      const checkboxes = document.querySelectorAll('.calendar-post-checkbox');
      checkboxes.forEach(checkbox => {
        checkbox.checked = false;
        selectedPosts.delete(checkbox.dataset.postId);
      });
      updatePushButton();
    }
    
    function updatePushButton() {
      const pushButton = document.getElementById('btn-push-selected');
      const hasScheduledSelected = Array.from(selectedPosts).some(postId => {
        const post = calendarData.find(p => (p.id || p.clip_id) === postId);
        return post && post.status === 'scheduled';
      });
      
      pushButton.disabled = !hasScheduledSelected;
      pushButton.textContent = `üöÄ Push do Publera (${selectedPosts.size})`;
    }
    
    async function pushSelectedToPubler() {
      const scheduledSelected = Array.from(selectedPosts).filter(postId => {
        const post = calendarData.find(p => (p.id || p.clip_id) === postId);
        return post && post.status === 'scheduled';
      });
      
      if (scheduledSelected.length === 0) {
        alert('Nie wybrano ≈ºadnych zaplanowanych post√≥w');
        return;
      }
      
      try {
        const pushButton = document.getElementById('btn-push-selected');
        pushButton.disabled = true;
        pushButton.textContent = 'Szukam wolnych slot√≥w...';
        
        // Pobierz dostƒôpne sloty czasowe
        const slotsResponse = await fetch(`/api/publer/available-slots?count=${scheduledSelected.length}`);
        const slotsData = await slotsResponse.json();
        
        if (!slotsData.ok || !slotsData.available_slots || slotsData.available_slots.length < scheduledSelected.length) {
          alert(`Nie znaleziono wystarczajƒÖcej liczby wolnych slot√≥w. Potrzeba: ${scheduledSelected.length}, dostƒôpne: ${slotsData.available_slots?.length || 0}`);
          return;
        }
        
        pushButton.textContent = 'Przypisujƒô sloty i przesy≈Çam...';
        
        // Przypisz sloty i prze≈õlij posty
        let successCount = 0;
        let errorCount = 0;
        
        for (let i = 0; i < scheduledSelected.length; i++) {
          const postId = scheduledSelected[i];
          const slot = slotsData.available_slots[i];
          
          try {
            // Najpierw zaktualizuj czas w schedulerze
            const updateResponse = await fetch(`/api/internal-scheduler/posts/${postId}`, {
              method: 'PUT',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                scheduled_at: slot.datetime
              })
            });
            
            if (updateResponse.ok) {
              // Nastƒôpnie prze≈õlij do Publera
              const pushResponse = await fetch(`/api/internal-scheduler/push-to-publer/post/${postId}`, {
                method: 'POST'
              });
              
              if (pushResponse.ok) {
                successCount++;
              } else {
                errorCount++;
                console.error(`B≈ÇƒÖd przesy≈Çania posta ${postId}:`, await pushResponse.text());
              }
            } else {
              errorCount++;
              console.error(`B≈ÇƒÖd aktualizacji czasu posta ${postId}:`, await updateResponse.text());
            }
          } catch (error) {
            errorCount++;
            console.error(`B≈ÇƒÖd przetwarzania posta ${postId}:`, error);
          }
        }
        
        if (successCount > 0) {
          alert(`Przes≈Çano ${successCount} post√≥w do Publera z automatycznie przypisanymi slotami czasowymi.${errorCount > 0 ? ` B≈Çƒôd√≥w: ${errorCount}` : ''}`);
        } else {
          alert('Nie uda≈Ço siƒô przes≈Çaƒá ≈ºadnego posta');
        }
        
        selectedPosts.clear();
        loadCalendarData().catch(console.error); // Refresh calendar
        
      } catch (error) {
        console.error('Error pushing posts:', error);
        alert('B≈ÇƒÖd podczas przesy≈Çania post√≥w');
      } finally {
        updatePushButton();
      }
    }
    
    async function pushSinglePost(postId) {
      try {
        const response = await fetch(`/api/internal-scheduler/push-now-to-publer/post/${postId}`, {
          method: 'POST'
        });
        
        if (response.ok) {
          alert('Post przes≈Çany do Publera (publish_now)');
          loadCalendarData().catch(console.error); // Refresh calendar
        } else {
          alert('B≈ÇƒÖd podczas przesy≈Çania posta');
        }
      } catch (error) {
        console.error('Error pushing post:', error);
        alert('B≈ÇƒÖd podczas przesy≈Çania posta');
      }
    }
    
    async function editPostTime(postId, currentTime) {
      try {
        // Konwertuj aktualny czas na format datetime-local
        const currentDate = new Date(currentTime);
        const localDateTime = new Date(currentDate.getTime() - currentDate.getTimezoneOffset() * 60000)
          .toISOString().slice(0, 16);
        
        // Poka≈º dialog z inputem datetime-local
        const newTime = prompt(`Podaj nowy czas publikacji (format: YYYY-MM-DD HH:MM):\n\nAktualny czas: ${currentDate.toLocaleString('pl-PL')}`, 
          localDateTime.replace('T', ' '));
        
        if (!newTime) return; // U≈ºytkownik anulowa≈Ç
        
        // Walidacja formatu
        let newDate;
        try {
          // Spr√≥buj parsowaƒá w formacie "YYYY-MM-DD HH:MM"
          if (newTime.includes(' ')) {
            const [datePart, timePart] = newTime.split(' ');
            newDate = new Date(`${datePart}T${timePart}:00`);
          } else {
            newDate = new Date(newTime);
          }
          
          if (isNaN(newDate.getTime())) {
            throw new Error('Invalid date');
          }
        } catch (error) {
          alert('Nieprawid≈Çowy format daty. U≈ºyj formatu: YYYY-MM-DD HH:MM (np. 2024-12-25 14:30)');
          return;
        }
        
        // Konwertuj na ISO string z poprawnƒÖ strefƒÖ czasowƒÖ
        // U≈ºytkownik wprowadza czas lokalny, wiƒôc traktujemy go jako lokalny czas
        // Tworzymy nowy obiekt Date z wprowadzonƒÖ datƒÖ jako lokalnƒÖ datƒÖ
        // JavaScript automatycznie obs≈Çu≈ºy konwersjƒô na UTC uwzglƒôdniajƒÖc czas letni/zimowy
        const localDate = new Date(newDate.getFullYear(), newDate.getMonth(), newDate.getDate(), 
                                   newDate.getHours(), newDate.getMinutes(), newDate.getSeconds());
        const isoString = localDate.toISOString();
        
        // Wy≈õlij ≈ºƒÖdanie aktualizacji
        const response = await fetch(`/api/internal-scheduler/posts/${postId}`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            scheduled_at: isoString
          })
        });
        
        if (response.ok) {
          alert(`Czas publikacji zosta≈Ç zmieniony na: ${newDate.toLocaleString('pl-PL')}`);
          loadCalendarData().catch(console.error); // Refresh calendar
        } else {
          const errorData = await response.json();
          alert(`B≈ÇƒÖd podczas aktualizacji czasu: ${errorData.error || 'Nieznany b≈ÇƒÖd'}`);
        }
      } catch (error) {
        console.error('Error editing post time:', error);
        alert('B≈ÇƒÖd podczas edycji czasu posta');
      }
    }
    
    async function deleteScheduledPost(postId) {
      if (!confirm('Czy na pewno chcesz usunƒÖƒá ten zaplanowany post?')) {
        return;
      }
      
      try {
        const response = await fetch(`/api/internal-scheduler/posts/${postId}`, {
          method: 'DELETE'
        });
        
        if (response.ok) {
          alert('Post zosta≈Ç usuniƒôty z harmonogramu');
          loadCalendarData().catch(console.error); // Refresh calendar
        } else {
          const errorData = await response.json();
          alert(`B≈ÇƒÖd podczas usuwania posta: ${errorData.error || 'Nieznany b≈ÇƒÖd'}`);
        }
      } catch (error) {
        console.error('Error deleting post:', error);
        alert('B≈ÇƒÖd podczas usuwania posta');
      }
    }
    
    async function filterCalendarData() {
      await renderCalendar();
    }
  </script>
  
  </body>
  </html>
