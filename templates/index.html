<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="utf-8">
  <title>Panel Twitch Clips</title>
  <link rel="stylesheet" href="/static/style.css?v={{ cache_buster }}">
  <style>
    .dropdown-item:hover {
      background-color: #f8f9fa;
    }
    .dropdown-container.open .dropdown-menu {
      display: block !important;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Panel Twitch Clips</h1>
      <div class="actions">
        <button id="btn-update" class="btn">OdÅ›wieÅ¼ streamerÃ³w twitch</button>
        <button id="btn-report" class="btn">Generuj raport Twitch</button>
        <button id="btn-kick" class="btn">Generuj raport Kick</button>
        <button id="btn-calendar" class="btn">ğŸ“… Terminarz</button>
        <a href="/admin" id="admin-link" class="btn" title="Preferencje streamerÃ³w">âš™ï¸ Panel admina</a>
        <span id="spinner" style="display:none;margin-left:8px;">â³</span>
      </div>
      <div id="status" class="status"></div>
    <div id="progress-counter" class="status" style="display:none"></div>
    <div id="auto-refresh" class="status" style="margin-top:6px;">
      ğŸ” Auto-odÅ›wieÅ¼anie za: <span id="refresh-timer">--:--</span>
      <div id="twitch-progress-bar" class="progress-bar" style="margin-top:6px; display:none;">
        <div id="progress-fill" class="progress-fill" style="width:0%"></div>
      </div>
    </div>
    <!-- Kick: progres analogiczny do Twitch -->
    <div id="kick-progress" class="status" style="margin-top:6px; display:none;">
      ğŸŸ¢ Kick: postÄ™p: <span id="progress-counter-kick">â€”</span>
      <div id="kick-progress-bar" class="progress-bar" style="margin-top:6px; display:none;">
        <div id="progress-fill-kick" class="progress-fill" style="width:0%"></div>
      </div>
    </div>
    </header>

    <div id="view-controls" class="subactions" style="margin:12px 0;">
      <button id="btn-hide-viewed" class="btn">Ukryj obejrzane</button>
      <div class="dropdown-container" style="position:relative; display:inline-block;">
        <button id="btn-open-unviewed" class="btn" style="background:#28a745; color:white;">ğŸš€ OtwÃ³rz nieobejrzane</button>
        <div id="unviewed-dropdown" class="dropdown-menu" style="display:none; position:absolute; top:100%; left:0; background:white; border:1px solid #ddd; border-radius:4px; box-shadow:0 2px 10px rgba(0,0,0,0.1); z-index:1000; min-width:180px;">
          <button class="dropdown-item" data-limit="10" style="display:block; width:100%; padding:8px 12px; border:none; background:none; text-align:left; cursor:pointer;">ğŸ“‹ OtwÃ³rz 10 klipÃ³w</button>
          <button class="dropdown-item" data-limit="25" style="display:block; width:100%; padding:8px 12px; border:none; background:none; text-align:left; cursor:pointer;">ğŸ“‹ OtwÃ³rz 25 klipÃ³w</button>
          <button class="dropdown-item" data-limit="50" style="display:block; width:100%; padding:8px 12px; border:none; background:none; text-align:left; cursor:pointer;">ğŸ“‹ OtwÃ³rz 50 klipÃ³w</button>
          <button class="dropdown-item" data-limit="all" style="display:block; width:100%; padding:8px 12px; border:none; background:none; text-align:left; cursor:pointer;">ğŸ”¥ OtwÃ³rz wszystkie</button>
        </div>
      </div>
      <span id="global-count" class="hint"></span>
    </div>

    <!-- Globalny pasek edytora: zawsze widoczny niezaleÅ¼nie od raportu -->
    <div id="global-editor-fixedbar" class="fixed-editor-bar" style="display:flex;">
      <button id="proceed-editor-fixed" class="btn" disabled>â¡ï¸ Dalej do edytora</button>
      <button id="view-saved-fixed" class="btn">ğŸ‘ï¸ PokaÅ¼ zapisane</button>
    </div>

    <main>
      <!-- GÅ‚Ã³wna strona z raportami -->
      <div id="main-page" style="display:block;">
        <section id="raport-container" style="display:none;"></section>
        <section id="kick-report-container" style="display:none; margin-top:12px;"></section>
      </div>

      <!-- Osobna strona kalendarza -->
      <div id="calendar-page" style="display:none;">
        <div class="calendar-page-header">
          <button id="btn-back-to-main" class="btn btn-back">â† WrÃ³Ä‡</button>
          <h2>ğŸ“… Terminarz postÃ³w</h2>
        </div>
        
        <section id="calendar-container" style="display:block;">
          <div class="calendar-header">
            <div class="calendar-controls">
              <button id="btn-select-all" class="btn">Zaznacz wszystkie</button>
              <button id="btn-deselect-all" class="btn">Odznacz wszystkie</button>
              <button id="btn-push-selected" class="btn btn-primary" disabled>ğŸš€ Push do Publera</button>
              <button id="btn-refresh-calendar" class="btn">ğŸ”„ OdÅ›wieÅ¼</button>
            </div>
          </div>
          
          <div class="calendar-filters">
            <label>
              <input type="checkbox" id="filter-scheduled" checked> Zaplanowane
            </label>
            <label>
              <input type="checkbox" id="filter-published" checked> Opublikowane
            </label>
            <label>
              <input type="checkbox" id="filter-failed"> Nieudane
            </label>
          </div>
          
          <div id="calendar-content" class="calendar-content">
            <div class="loading">Åadowanie terminarza...</div>
          </div>
        </section>
      </div>
<!-- StaÅ‚y pasek edytora na dole: dwa przyciski gÅ‚Ã³wne -->
<div id="fallback-editor-controls" style="position:fixed; left:0; right:0; bottom:0; display:flex; gap:8px; padding:8px; background:rgba(20,20,24,0.9); border-top:1px solid #333; justify-content:center; z-index:1000;">
  <button id="fallback-proceed-editor" class="btn" title="PrzejdÅº do edytora z zapisanymi">â• Dodaj do edytora</button>
  <button id="fallback-view-saved" class="btn" title="PokaÅ¼/Ukryj zapisane">ğŸ“Œ PokaÅ¼ zapisane</button>
</div>
<!-- Overlay zapisanych klipÃ³w -->
<div id="saved-clips-panel" style="display:none; position:fixed; right:12px; bottom:56px; width:360px; max-height:50vh; overflow:auto; background:#15161a; border:1px solid #333; border-radius:6px; box-shadow:0 8px 24px rgba(0,0,0,0.4); padding:10px; z-index:999;"></div>
    </main>
  </div>

  <script type="text/javascript">
    const statusEl = document.getElementById('status');
  const progressCounter = document.getElementById('progress-counter');
    const raportContainer = document.getElementById('raport-container');
    const btnReport = document.getElementById('btn-report');
    const btnKick = document.getElementById('btn-kick');
    const spinner = document.getElementById('spinner');
    const refreshTimerEl = document.getElementById('refresh-timer');
    const progressFillEl = document.getElementById('progress-fill');
    const progressCounterKick = document.getElementById('progress-counter-kick');
    const progressFillElKick = document.getElementById('progress-fill-kick');
    const twitchProgressBar = document.getElementById('twitch-progress-bar');
    // Lokalne przyciski z fragmentu Twitch bÄ™dÄ… podpinane po wstrzykniÄ™ciu
    const kickProgressContainer = document.getElementById('kick-progress');
    const kickProgressBar = document.getElementById('kick-progress-bar');
    let kickProgressInterval = null;
    let kickStatusPollId = null;
    let kickReadyPollId = null;
    let kickFinishedHideTimeoutId = null;


    let reportReadyPoll = null;
    let reportStatusPoll = null;
    // Lokalny timer 15-minutowy i lekkie pollowanie tylko podczas generowania
    let nextRunAt = null;            // ms timestamp nastÄ™pnego uruchomienia (lokalny)
    let countdownTimerId = null;     // setInterval id dla lokalnego odliczania
    let autoGenPollId = null;        // setInterval id pollowania statusu w trakcie generowania
    let autoGenReadyPollId = null;   // setInterval id pollowania gotowoÅ›ci raportu (Twitch)
    let autoGenKickReadyPollId = null; // setInterval id pollowania gotowoÅ›ci raportu Kick (cicho)
    let ensureKickMountPollId = null;  // staÅ‚y straÅ¼nik: jeÅ›li gotowy i kontener pusty, dociÄ…gnij fragment
    let autoGenActive = false;       // flaga: czy aktualnie trwa generowanie
    let autoTriggerStarted = false;  // straÅ¼nik: czy auto-trigger tego cyklu juÅ¼ wystartowaÅ‚
    let autoGenSeenActive = false;   // straÅ¼nik: czy w bieÅ¼Ä…cym cyklu status byÅ‚ aktywny
    let ensureTwitchMountPollId = null; // straÅ¼nik: po reloadzie dociÄ…gnij fragment Twitch, jeÅ›li gotowy
    // Guardy przeciw wielokrotnemu wczytaniu i wstrzykniÄ™ciu fragmentu Twitch
    if (typeof window.twitchFragmentLoaded === 'undefined') window.twitchFragmentLoaded = false;
    if (typeof window.twitchFragmentLoading === 'undefined') window.twitchFragmentLoading = false;
    // Guard na rÃ³wnolegÅ‚e zapytania /api/report-ready
    let readyFetchLock = false;
    // Guard na rÃ³wnolegÅ‚e zapytania /api/report-status
    let statusFetchLock = false;
    

    // Guardy przeciw wielokrotnemu wczytaniu i wstrzykniÄ™ciu fragmentu Twitch (duplikat â€“ usuÅ„)
    // [cleanup] usuniÄ™to podwÃ³jnÄ… deklaracjÄ™ let twitchFragmentLoaded/twitchFragmentLoading

    // Ostatni znany status i koordynacja pollowania miÄ™dzy wieloma podglÄ…dami
    let latestStatus = null;
    const LEADER_KEY = 'pollLeaderV1';
    const LATEST_STATUS_KEY = 'latestStatusV1';
    const LEADER_TTL_MS = 5000;
    const leaderId = Math.random().toString(36).slice(2);
    let isPollLeader = true; // leader disabled: kaÅ¼da karta dziaÅ‚a samodzielnie
    let leaderHeartbeatId = null;
    const nowMs = ()=>Date.now();
    const readLeader = ()=>{ try { return JSON.parse(localStorage.getItem(LEADER_KEY)||'null'); } catch{ return null; } };
    const writeLeader = (obj)=>{ try { localStorage.setItem(LEADER_KEY, JSON.stringify(obj)); } catch{} };
    const readLatest = ()=>{ try { return JSON.parse(localStorage.getItem(LATEST_STATUS_KEY)||'{}'); } catch{ return {}; } };
    const writeLatest = (p)=>{ try { localStorage.setItem(LATEST_STATUS_KEY, JSON.stringify(p||{})); } catch{} };
    function acquireLeaderIfPossible(){
      const cur = readLeader();
      const expired = !cur || !cur.ts || ((nowMs()-cur.ts) > LEADER_TTL_MS);
      if (expired || (cur && cur.id === leaderId)){
        isPollLeader = true;
        writeLeader({ id: leaderId, ts: nowMs() });
        if (leaderHeartbeatId) clearInterval(leaderHeartbeatId);
        leaderHeartbeatId = setInterval(()=>{ writeLeader({ id: leaderId, ts: nowMs() }); }, 2000);
      } else {
        isPollLeader = false;
        if (leaderHeartbeatId) { clearInterval(leaderHeartbeatId); leaderHeartbeatId = null; }
      }
    }
    function releaseLeader(){
      const cur = readLeader();
      if (cur && cur.id === leaderId){ try { localStorage.removeItem(LEADER_KEY); } catch{} }
      isPollLeader = false;
      if (leaderHeartbeatId) { clearInterval(leaderHeartbeatId); leaderHeartbeatId = null; }
    }
    window.addEventListener('storage', (e)=>{ if (e.key === LEADER_KEY) acquireLeaderIfPossible(); });
    document.addEventListener('visibilitychange', ()=>{ if (document.hidden) releaseLeader(); else acquireLeaderIfPossible(); });
    window.addEventListener('beforeunload', releaseLeader);
    setTimeout(acquireLeaderIfPossible, 0);

    // Obserwator: uruchamiaj oznaczanie NOWE po wstrzykniÄ™ciu/zmianie treÅ›ci raportu
    function debounce(fn, wait){
      let t;
      return function(...args){
        try{ clearTimeout(t); }catch{}
        t = setTimeout(()=>{ try{ fn.apply(this, args); }catch{} }, wait);
      };
    }
    function setupMarkObservers(){
      try{
        const runMark = (root)=>{ if (!root) return; try{ markNewRowsAfterInject(root); updateGlobalCounters(); }catch{} };
        const twitchRoot = document.getElementById('raport-container');
        const kickRoot = document.getElementById('kick-report-container');
        const opts = { childList: true, subtree: true };
        if (twitchRoot){
          const obsT = new MutationObserver(debounce(()=>runMark(twitchRoot), 120));
          obsT.observe(twitchRoot, opts);
          runMark(twitchRoot);
          window.twitchMarkObserver = obsT;
        }
        if (kickRoot){
          const obsK = new MutationObserver(debounce(()=>runMark(kickRoot), 120));
          obsK.observe(kickRoot, opts);
          runMark(kickRoot);
          window.kickMarkObserver = obsK;
        }
      }catch{}
    }
    try{ setupMarkObservers(); }catch{}

    // Centralne czyszczenie wszystkich interwaÅ‚Ã³w zwiÄ…zanych z pollowaniem
    function stopAllIntervals(){
      try{ if (autoGenPollId) { clearInterval(autoGenPollId); autoGenPollId = null; } }catch{}
      try{ if (autoGenReadyPollId) { clearInterval(autoGenReadyPollId); autoGenReadyPollId = null; } }catch{}
      try{ if (reportStatusPoll) { clearInterval(reportStatusPoll); reportStatusPoll = null; } }catch{}
      try{ if (reportReadyPoll) { clearInterval(reportReadyPoll); reportReadyPoll = null; } }catch{}
      try{ if (ensureTwitchMountPollId) { clearInterval(ensureTwitchMountPollId); ensureTwitchMountPollId = null; } }catch{}
      try{ if (ensureKickMountPollId) { clearInterval(ensureKickMountPollId); ensureKickMountPollId = null; } }catch{}
      try{ if (kickStatusPollId) { clearInterval(kickStatusPollId); kickStatusPollId = null; } }catch{}
      try{ if (kickReadyPollId) { clearInterval(kickReadyPollId); kickReadyPollId = null; } }catch{}
      // nie czyÅ›cimy countdownTimerId â€“ timer ma dziaÅ‚aÄ‡ w trybie idle
    }

    // Selewtywne czyszczenie interwaÅ‚Ã³w Twitch, bez ruszania pollowania Kick
    function stopTwitchIntervalsOnly(){
      try{ if (autoGenPollId) { clearInterval(autoGenPollId); autoGenPollId = null; } }catch{}
      try{ if (autoGenReadyPollId) { clearInterval(autoGenReadyPollId); autoGenReadyPollId = null; } }catch{}
      try{ if (reportStatusPoll) { clearInterval(reportStatusPoll); reportStatusPoll = null; } }catch{}
      try{ if (reportReadyPoll) { clearInterval(reportReadyPoll); reportReadyPoll = null; } }catch{}
      try{ if (ensureTwitchMountPollId) { clearInterval(ensureTwitchMountPollId); ensureTwitchMountPollId = null; } }catch{}
      // kickStatusPollId / kickReadyPollId / ensureKickMountPollId pozostajÄ… aktywne
    }

    // Globalny licznik: sumuje Twitch + Kick (definicja na gÃ³rze, aby uniknÄ…Ä‡ bÅ‚Ä™dÃ³w widocznoÅ›ci)
    function updateGlobalCounters(){
      try{
        const counterEl = document.getElementById('global-count');
        if (!counterEl) return;
        // Pobierz wiersze z obu raportÃ³w (oba uÅ¼ywajÄ… id `report-table` w fragmentach)
        const rows = Array.from(document.querySelectorAll('#report-table tbody tr'));
        let viewedArr = []; let newPendingArr = [];
        try { viewedArr = JSON.parse(localStorage.getItem('viewedClips')||'[]')||[]; } catch{}
        try { newPendingArr = JSON.parse(localStorage.getItem('newPendingClipIds')||'[]')||[]; } catch{}
        const viewedSet = new Set(viewedArr); const newPendingSet = new Set(newPendingArr);
        const clipIdFromUrl = (url)=>{ try{ const u = new URL(url); let last = u.pathname.split('/').filter(Boolean).pop()||'clip'; last = last.split('?')[0]; return last.replace(/[^a-zA-Z0-9_-]/g,'')||'clip'; }catch{ return 'clip'; } };
        let total = 0, newUnviewed = 0, viewedCount = 0;
        rows.forEach(tr=>{
          const cb = tr.querySelector('.clip-select');
          const url = cb ? cb.dataset.url : (tr.querySelector('a[href]')?.getAttribute('href')||'');
          const id = clipIdFromUrl(url);
          total++;
          const isViewed = viewedSet.has(id);
          const isNewPending = newPendingSet.has(id);
          if (isViewed) viewedCount++;
          if (isNewPending && !isViewed) newUnviewed++;
        });
        counterEl.textContent = `Nowe: ${newUnviewed} / Wszystkie: ${total} â€¢ Obejrzane: ${viewedCount}`;
      }catch{}
    }

    function formatMMSS(sec){
      try{ sec = Math.max(0, Math.floor(Number(sec)||0)); }catch{ sec = 0; }
      const m = Math.floor(sec/60); const s = sec%60;
      return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
    }

    // Wylicz lokalnie najbliÅ¼sze 10 min (00, 10, 20, 30, 40, 50)
    function calcNextDecaminTimestamp(){
      const now = new Date();
      const s = now.getSeconds();
      const ms = now.getMilliseconds();
      const remainder = now.getMinutes() % 10;
      let addMin = 10 - remainder;
      // jeÅ›li jesteÅ›my idealnie na kwadransie, przejdÅº do nastÄ™pnego
      if (remainder === 0 && s === 0 && ms === 0) addMin = 10;
      const nextMs = now.getTime() + addMin*60*1000 - s*1000 - ms;
      return nextMs;
    }

    function updateCountdown(){
      if (!nextRunAt){
        if (refreshTimerEl) refreshTimerEl.textContent = '--:--';
        return;
      }
      const now = Date.now();
      let diffSec = Math.floor((nextRunAt - now) / 1000);
      if (diffSec < 0) diffSec = 0;
      if (refreshTimerEl) refreshTimerEl.textContent = formatMMSS(diffSec);
      // Po dojÅ›ciu do zera: zawsze przeskocz na kolejne okno odliczania,
      // aby licznik nie "staÅ‚" na 00:00 (nawet gdy trwa generowanie).
      if (diffSec === 0){
        nextRunAt = calcNextDecaminTimestamp();
        // Uruchom generowanie tylko raz, gdy nie trwa aktywny cykl
        if (!autoGenActive && !autoTriggerStarted){
          autoTriggerGeneration();
        }
      }
    }

    function startCountdown(){
      if (countdownTimerId) clearInterval(countdownTimerId);
      updateCountdown();
      countdownTimerId = setInterval(updateCountdown, 1000);
    }

    async function checkReadyOnce(){
      if (readyFetchLock) return false;
      readyFetchLock = true;
      try{
        const rr = await fetch('/api/report-ready');
        const rj = await rr.json();
        return !!(rj && rj.ready);
      }catch(e){ return false; }
      finally { readyFetchLock = false; }
    }

    function stopAutoGenerationPolling(){
      autoGenActive = false;
      if (autoGenPollId){ clearInterval(autoGenPollId); autoGenPollId = null; }
      if (autoGenReadyPollId){ clearInterval(autoGenReadyPollId); autoGenReadyPollId = null; }
    }

    // Kick: status polling i Å‚adowanie raportu po gotowoÅ›ci
    function startKickStatusPolling(fromUserClick){
      console.log(`[Kick] startKickStatusPolling fromUserClick=${!!fromUserClick}`);
      // natychmiastowy odczyt
      (async ()=>{
        try{
          const r0 = await fetch('/api/report-kick-status', { cache: 'no-store' });
          const d0 = await r0.json();
          const p0 = d0 && d0.progress ? d0.progress : {};
          console.log('[Kick] immediate status:', p0);
          updateKickProgressUI(p0);
        }catch{}
      })();
      // cykliczny status
      if (kickStatusPollId) clearInterval(kickStatusPollId);
      kickStatusPollId = setInterval(async ()=>{
        try{
          const r = await fetch('/api/report-kick-status', { cache: 'no-store' });
          const d = await r.json();
          const p = d && d.progress ? d.progress : {};
          console.log('[Kick] status tick:', p);
          updateKickProgressUI(p);
          if (p.status === 'finished'){
            clearInterval(kickStatusPollId); kickStatusPollId = null;
            console.log('[Kick] status finished â†’ pollKick');
            try{ await pollKick(); }catch{}
          }
        }catch{}
      }, 2000);
      // gotowoÅ›Ä‡ co kilka sekund
      if (kickReadyPollId) clearInterval(kickReadyPollId);
      kickReadyPollId = setInterval(async ()=>{
        try{
          const rk = await fetch('/api/report-kick-ready', { cache: 'no-store' }).then(r=>r.json());
          console.log('[Kick] ready tick:', rk);
          if (rk && rk.ready){
            clearInterval(kickReadyPollId); kickReadyPollId = null;
            console.log('[Kick] ready=true â†’ pollKick');
            try{ await pollKick(); }catch{}
          }
        }catch{}
      }, fromUserClick ? 3000 : 5000);
    }

    function updateKickProgressUI(p){
      const st = p && p.status ? p.status : 'idle';
      const total = Number(p && p.total || 0);
      let label = 'â€”'; let pct = 0;
      if (st === 'scraping'){
        label = 'â³ Skrobanie klipÃ³wâ€¦'; pct = 5;
        if (kickProgressContainer) kickProgressContainer.style.display = 'block';
        if (kickProgressBar) kickProgressBar.style.display = 'block';
      } else if (st === 'generating'){
        label = total>0 ? `ğŸ”§ Generowanieâ€¦ (klipy: ${total})` : 'ğŸ”§ Generowanieâ€¦';
        pct = total>0 ? 70 : 50;
        if (kickProgressContainer) kickProgressContainer.style.display = 'block';
        if (kickProgressBar) kickProgressBar.style.display = 'block';
      } else if (st === 'finished'){
        label = 'âœ… Gotowe'; pct = 100;
        if (kickProgressBar) kickProgressBar.style.display = 'none';
        if (kickProgressContainer) kickProgressContainer.style.display = 'block';
        if (kickFinishedHideTimeoutId) { clearTimeout(kickFinishedHideTimeoutId); }
        kickFinishedHideTimeoutId = setTimeout(()=>{
          if (kickProgressContainer) kickProgressContainer.style.display = 'none';
        }, 4000);
      } else {
        label = 'â€”'; pct = 0;
        if (kickProgressContainer) kickProgressContainer.style.display = 'none';
        if (kickProgressBar) kickProgressBar.style.display = 'none';
      }
      if (progressCounterKick) progressCounterKick.textContent = label;
      if (progressFillElKick) progressFillElKick.style.width = pct + '%';
    }

    async function autoTriggerGeneration(){
      autoGenActive = true;
      autoTriggerStarted = true;
      autoGenSeenActive = false; // reset global straÅ¼nika aktywnoÅ›ci dla nowego cyklu
      // Reset guardÃ³w fragmentu na nowy cykl
      window.twitchFragmentLoaded = false;
      window.twitchFragmentLoading = false;
      // Przed startem nowego cyklu wyczyÅ›Ä‡ ewentualne stare interwaÅ‚y pollowania
      try { stopAllIntervals(); } catch{}
      // Start generowania Twitch
      try { await fetch('/api/generate-raport'); } catch{}
      try { await fetch('/api/generate-raport-kick'); } catch(e) { console.warn('[Kick][auto] generate error:', e); }
      // Uruchom pollowanie postÄ™pu Twitch
      if (twitchProgressBar) twitchProgressBar.style.display = 'block';
      if (progressCounter) { progressCounter.style.display = 'block'; progressCounter.textContent = 'â³ Przetworzono: 0 / 0'; }
      startAutoGenerationPolling();
      // Pollowanie Kick uruchamiaj zawsze z auto-triggera
      try{ console.log('[Kick][auto] start status polling'); startKickStatusPolling(false); }catch(e){ console.warn('[Kick][auto] status polling start error:', e); }
    }

    async function startAutoGenerationPolling(){
      autoGenActive = true;
      autoGenSeenActive = false; // reset na poczÄ…tku cyklu auto-pollowania
      // Pollowanie postÄ™pu tylko w trakcie generowania (co 3s)
      if (autoGenPollId) clearInterval(autoGenPollId);
      autoGenPollId = setInterval(pollStatus, 3000);
      // Pollowanie gotowoÅ›ci raportu (co 3s)
      if (autoGenReadyPollId) clearInterval(autoGenReadyPollId);
      autoGenReadyPollId = setInterval(async ()=>{
        try{
          // Korzystaj z ostatniego statusu z pollStatus(), aby uniknÄ…Ä‡ podwÃ³jnych wywoÅ‚aÅ„
          const p = latestStatus || {};
          if (p && p.status && p.status !== 'finished') { autoGenSeenActive = true; }
          if (p && p.status === 'finished' && autoGenSeenActive){
            const ready = await checkReadyOnce();
            if (ready){
              await loadTwitchFragmentOnce();
            }
          }
        }catch{}
      }, 3000);
      // Kick: bez pollowania w stanie idle â€“ wznowienie tylko po starcie cyklu
    }

    // Aktualizacja UI Twitch na podstawie statusu (bez fetch)
    function updateTwitchProgressFromStatus(p){
      try{
        const processed = Number(p && p.processed || 0);
        const total = Number(p && p.total || 0);
        const st = p && p.status ? p.status : 'idle';
        latestStatus = p || {};
        if (progressCounter){
          if (st === 'scraping' || st === 'generating' || st === 'running'){
            progressCounter.style.display = 'block';
            progressCounter.textContent = total>0 ? `â³ Przetworzono: ${processed} / ${total}` : 'â³ Generowanieâ€¦';
          } else {
            progressCounter.style.display = 'none';
            progressCounter.textContent = '';
          }
        }
        if (progressFillEl){
          if (twitchProgressBar) twitchProgressBar.style.display = (st==='finished' || st==='idle') ? 'none' : 'block';
          const pct = total>0 ? Math.floor(processed*100/total) : 0;
          progressFillEl.style.width = pct + '%';
        }
        if (st && st !== 'finished') { autoGenSeenActive = true; }
      }catch{}
    }

    async function pollStatus(){
      // Nie pollowaÄ‡ poza aktywnym cyklem
      if (!autoGenActive) return;
      // Guard przed rÃ³wnolegÅ‚ymi wywoÅ‚aniami /api/report-status
      if (statusFetchLock) return;
      statusFetchLock = true;
      try{
        const rs = await fetch('/api/report-status');
        const data = await rs.json();
        const p = (data && data.progress) ? data.progress : {};
        latestStatus = p;
        writeLatest(p);
        updateTwitchProgressFromStatus(p);
        // Oznacz aktywnoÅ›Ä‡ cyklu gdy status jest inny niÅ¼ 'finished'
        if (p && p.status && p.status !== 'finished') {
          autoGenSeenActive = true;
        }
        // JeÅ›li status zakoÅ„czony i wczeÅ›niej widziano aktywnoÅ›Ä‡ â€” wstrzyknij fragment bez rÄ™cznego odÅ›wieÅ¼ania
        if ((p.status === 'finished') && autoGenSeenActive) {
          try {
            const ready = await checkReadyOnce();
            if (ready) {
              await loadTwitchFragmentOnce();
            }
          } catch{}
        }
      }catch(e){ /* ignore */ }
      finally { statusFetchLock = false; }
    }

    document.getElementById('btn-kick').onclick = async () => {
      if (btnKick.disabled) return;
      btnKick.disabled = true;
      const prevTxt = btnKick.textContent;
      btnKick.textContent = 'GenerujÄ™â€¦';
      spinner.style.display = 'inline-block';
      // Wyzeruj pasek postÄ™pu Kick i uruchom pollowanie statusu
      if (progressCounterKick) { progressCounterKick.textContent = 'â³ Generowanieâ€¦'; }
      if (progressFillElKick) { progressFillElKick.style.width = '0%'; }
      if (kickProgressContainer) kickProgressContainer.style.display = 'block';
      if (kickProgressBar) kickProgressBar.style.display = 'block';
      try {
        await fetch('/api/generate-raport-kick');
        startKickStatusPolling(true);
      } finally {
        btnKick.disabled = false;
        btnKick.textContent = prevTxt;
        spinner.style.display = 'none';
      }
    };

function pollKick() {
  return fetch('/api/report-kick-ready', { cache: 'no-store' })
    .then(r=>r.json())
    .then(async (j) => {
      if (j && j.ready) {
        const bust = Date.now();
        const html = await fetch(`/raport-kick-fragment?v=${bust}`, { cache: 'no-store' }).then(r=>r.text());
        const kc = document.getElementById('kick-report-container');
        if (kc) {
          kc.innerHTML = html;
          try { kc.style.display = 'block'; } catch{}
          try { markNewRowsAfterInject(kc); } catch{}
          initReportFiltersAndStats(kc);
          // Reset calendar button text when showing kick report
          try { 
            const btnCalendar = document.getElementById('btn-calendar');
            if (btnCalendar) btnCalendar.textContent = 'ğŸ“… Terminarz';
          } catch{}
          // Zatrzymaj animacjÄ™ i pokaÅ¼ 100%
          if (kickProgressInterval) { clearInterval(kickProgressInterval); kickProgressInterval = null; }
          if (progressFillElKick) { progressFillElKick.style.width = '100%'; }
          if (progressCounterKick) { progressCounterKick.textContent = 'âœ… Gotowe'; }
          try { updateGlobalCounters(); } catch{}
          if (kickProgressBar) kickProgressBar.style.display = 'none';
          if (kickFinishedHideTimeoutId) { clearTimeout(kickFinishedHideTimeoutId); }
          kickFinishedHideTimeoutId = setTimeout(()=>{
            if (kickProgressContainer) kickProgressContainer.style.display = 'none';
          }, 4000);
          // Proaktywnie zatrzymaj pollowanie Kick po wstrzykniÄ™ciu raportu
          if (kickStatusPollId) { clearInterval(kickStatusPollId); kickStatusPollId = null; }
          if (kickReadyPollId) { clearInterval(kickReadyPollId); kickReadyPollId = null; }
          if (ensureKickMountPollId) { clearInterval(ensureKickMountPollId); ensureKickMountPollId = null; }
          return true;
        }
      }
      return false;
    })
    .catch(()=>false);
}

    // 1) OdÃ…â€ºwieÃ…Â¼ streamerÃƒÂ³w
    async function runUpdate() {
      const btn = document.getElementById('btn-update');
      if (btn.disabled) return;
      btn.disabled = true;
      const prev = btn.textContent;
      btn.textContent = 'OdÃ…â€ºwieÃ…Â¼amÃ¢â‚¬Â¦';
      statusEl.textContent = 'ğŸ”„ OdÅ›wieÅ¼anie streamerÃ³wâ€¦';
      try {
        const res = await fetch('/api/update-streamers');
        const obj = await res.json();
        statusEl.textContent = obj.message || obj.error;
      } catch (e) {
        statusEl.textContent = 'BÃ…â€šÃ„â€¦d: ' + e;
      } finally {
        btn.disabled = false;
        btn.textContent = prev;
      }
    }

    // 2) Generowanie raportu i pollowanie gotowoÃ…â€ºci
    async function runReport() {
      const btn = btnReport;
      if (btn.disabled) return;
      // Przed rÄ™cznym startem wyczyÅ›Ä‡ wszystkie interwaÅ‚y pollowania
      try { stopTwitchIntervalsOnly(); } catch{}
      // Reset guardÃ³w fragmentu przy rÄ™cznym starcie cyklu
      window.twitchFragmentLoaded = false;
      window.twitchFragmentLoading = false;
      btn.disabled = true;
      const prev = btn.textContent;
      // Zabezpieczenie przed podwÃ³jnym uruchomieniem (zbieg z autoTriggerem)
      autoGenActive = true;
      autoTriggerStarted = true;
      autoGenSeenActive = false; // wyzeruj globalny straÅ¼nik dla rÄ™cznego cyklu
      let hasSeenActive = false; // lokalny straÅ¼nik dla tego cyklu
      btn.textContent = 'GenerujÄ™â€¦';
      statusEl.textContent = 'ğŸ•’ Rozpoczynam generowanieâ€¦';
      spinner.style.display = 'inline-block';
      if (progressCounter) {


      progressCounter.style.display = 'block';
      progressCounter.textContent = 'â³ Przetworzono: 0 / 0';
      }
      if (progressFillEl){ progressFillEl.style.width = '0%'; }
      try {
        await fetch('/api/generate-raport');
        statusEl.textContent = 'âŒ› Czekam na raportâ€¦';
        // UÅ¼ywaj wyÅ‚Ä…cznie wspÃ³lnego mechanizmu auto-pollowania
        startAutoGenerationPolling();
        // Upewnij siÄ™, Å¼e Kick dalej pollowany podczas rÄ™cznego cyklu Twitch
        try { startKickStatusPolling(true); } catch(e) { console.warn('[Kick][manual] status polling start error:', e); }
      } catch (e) {
        statusEl.textContent = 'BÃ…â€šÃ„â€¦d: ' + e;
        btn.disabled = false;
        btn.textContent = prev;
        spinner.style.display = 'none';
        if (progressCounter) {
          progressCounter.style.display = 'none';
          progressCounter.textContent = '';
        }
        if (progressFillEl){ progressFillEl.style.width = '0%'; }
        if (twitchProgressBar){ twitchProgressBar.style.display = 'none'; }
        if (reportReadyPoll) { clearInterval(reportReadyPoll); reportReadyPoll = null; }
        if (reportStatusPoll) { clearInterval(reportStatusPoll); reportStatusPoll = null; }
      }
    }

    // 3) Pobranie i wstrzykniÃ„â„¢cie fragmentu raportu
    async function loadReportFragment() {
      const html = await fetch('/raport-fragment').then(r => r.text());
      // StraÅ¼nik: wstrzyknij raport tylko, jeÅ›li sÄ… wiersze tabeli (realne dane)
      try {
        const tmp = document.createElement('div');
        tmp.innerHTML = html;
        const hasRows = tmp.querySelectorAll('#report-table tbody tr').length > 0;
        if (!hasRows) {
          // Nie pokazuj pustego raportu
          return false;
        }
      } catch {}
      raportContainer.innerHTML = html;
      try { raportContainer.style.display = 'block'; } catch{}
      try { initReportFiltersAndStats(raportContainer); } catch{}
      // Reset calendar button text when showing report
      try { 
        const btnCalendar = document.getElementById('btn-calendar');
        if (btnCalendar) btnCalendar.textContent = 'ğŸ“… Terminarz';
      } catch{}
      // UsuniÄ™to lokalne przyciski; uÅ¼ywamy globalnego paska i overlayu zapisanych
      (function bindGlobalEditorButtons(){
        const proceedFixed = document.getElementById('fallback-proceed-editor');
        const viewSavedFixed = document.getElementById('fallback-view-saved');
        if (proceedFixed && !proceedFixed.dataset.bound){
          proceedFixed.dataset.bound = '1';
          proceedFixed.addEventListener('click', (e)=>{
            e.preventDefault();
            if (proceedFixed.disabled) return;
            const selected = savedAll();
            try {
              localStorage.setItem('pendingSelection', JSON.stringify({ clips: selected }));
              window.location.assign('/editor');
            } catch (e) {
              alert('Nie udaÅ‚o siÄ™ zapisaÄ‡ wyboru: ' + e);
            }
          });
        }
        if (viewSavedFixed && !viewSavedFixed.dataset.bound){
          viewSavedFixed.dataset.bound = '1';
          viewSavedFixed.addEventListener('click', (e)=>{
            e.preventDefault();
            let panel = document.getElementById('saved-clips-panel');
            if (!panel){
              panel = document.createElement('div');
              panel.id = 'saved-clips-panel';
              panel.className = 'saved-panel';
              panel.style.display = 'none';
              panel.style.position = 'fixed';
              panel.style.right = '16px';
              panel.style.bottom = '64px';
              panel.style.background = '#fafafa';
              panel.style.border = '1px solid #ddd';
              panel.style.borderRadius = '6px';
              panel.style.padding = '8px';
              panel.style.maxWidth = '360px';
              panel.style.zIndex = '9998';
              document.body.appendChild(panel);
            }
            if (panel.style.display === 'none' || !panel.style.display){ renderSavedPanel(panel); panel.style.display = 'block'; }
            else { panel.style.display = 'none'; }
          });
        }
        updateProceedState();
      })();
      initReportFiltersAndStats(raportContainer);
      // Po wstrzykniÄ™ciu: oznacz NOWE (trwaÅ‚e do klikniÄ™cia) i aktualizuj pamiÄ™Ä‡
      markNewRowsAfterInject(raportContainer);
      try { updateGlobalCounters(); } catch{}
    }

    // WstrzykniÄ™cie fragmentu Twitch tylko raz i zatrzymanie caÅ‚ego pollowania
    async function loadTwitchFragmentOnce(){
      if (window.twitchFragmentLoaded || window.twitchFragmentLoading) return false;
      window.twitchFragmentLoading = true;
      let ok = false;
      try {
        if (typeof window.loadReportFragment === 'function'){
          ok = await window.loadReportFragment();
        } else {
          ok = await loadReportFragment();
        }
      } catch(e){ ok = false; }
      // NiezaleÅ¼nie od powodzenia wstrzykniÄ™cia â€” zakoÅ„cz cykl i zatrzymaj pollowanie
      try { stopTwitchIntervalsOnly(); } catch{}
      autoGenActive = false;
      autoTriggerStarted = false;
      autoGenSeenActive = false;
      try{ if (twitchProgressBar) twitchProgressBar.style.display = 'none'; }catch{}
      try{ if (progressCounter) { progressCounter.style.display = 'none'; progressCounter.textContent = ''; } }catch{}
      try{ if (progressFillEl) progressFillEl.style.width = '0%'; }catch{}
      nextRunAt = calcNextDecaminTimestamp();
      startCountdown();
      window.twitchFragmentLoading = false;
      window.twitchFragmentLoaded = (ok !== false);
      return window.twitchFragmentLoaded;
    }

    // Oznaczanie nowych i obejrzanych po wstrzykniÄ™ciu fragmentu
    function markNewRowsAfterInject(root){
      if (!root) return;
      // Odczytaj dotychczasowe zbiory
      let known = [];
      let newPending = [];
      let viewed = [];
      try { known = JSON.parse(localStorage.getItem('knownClipIds')||'[]')||[]; } catch{}
      try { newPending = JSON.parse(localStorage.getItem('newPendingClipIds')||'[]')||[]; } catch{}
      try { viewed = JSON.parse(localStorage.getItem('viewedClips')||'[]')||[]; } catch{}
      const knownSet = new Set(known);
      const newPendingSet = new Set(newPending);
      const viewedSetLocal = new Set(viewed);

      const rows = Array.from(root.querySelectorAll('#report-table tbody tr'));
      const currentIds = [];
      rows.forEach(tr=>{
        const cb = tr.querySelector('.clip-select');
        const url = cb ? cb.dataset.url : (tr.querySelector('a[href]')?.getAttribute('href')||'');
        const id = window.clipIdFrom ? window.clipIdFrom(url) : url;
        currentIds.push(id);
      });
      // Zaktualizuj known (dodaj bieÅ¼Ä…ce id)
      const updatedKnown = Array.from(new Set([...knownSet, ...currentIds]));
      // NOWE = wszystkie nieobejrzane z bieÅ¼Ä…cego widoku + poprzednie, po odfiltrowaniu obejrzanych
      const perContainerNew = currentIds.filter(id => !viewedSetLocal.has(id));
      const updatedNewPending = Array.from(new Set([...newPendingSet, ...perContainerNew])).filter(id=>!viewedSetLocal.has(id));
      try { localStorage.setItem('knownClipIds', JSON.stringify(updatedKnown)); } catch{}
      try { localStorage.setItem('newPendingClipIds', JSON.stringify(updatedNewPending)); } catch{}

      // Zastosuj klasy CSS w zaleÅ¼noÅ›ci od stanu
      const updatedNewSet = new Set(updatedNewPending);
      rows.forEach(tr=>{
        const cb = tr.querySelector('.clip-select');
        const url = cb ? cb.dataset.url : (tr.querySelector('a[href]')?.getAttribute('href')||'');
        const id = window.clipIdFrom ? window.clipIdFrom(url) : url;
        const isViewed = viewedSetLocal.has(id);
        const isNewPending = updatedNewSet.has(id);
        tr.classList.toggle('viewed-row', isViewed);
        tr.classList.toggle('new-row', isNewPending && !isViewed);
        tr.classList.toggle('new-unviewed', isNewPending && !isViewed);
      });
    }

    // 4) Inicjalizacja dropdownÃƒÂ³w i aplikacja filtrÃƒÂ³w
function initReportFiltersAndStats(root) {
  if (!root) return;

  // Globalny stan obejrzanych i filtra
  const hideViewedBtn = document.getElementById('btn-hide-viewed');
  const globalCountEl = document.getElementById('global-count');
  let viewedSet = new Set();
  try { viewedSet = new Set(JSON.parse(localStorage.getItem('viewedClips')||'[]').filter(x=>typeof x==='string')); } catch(e){ viewedSet = new Set(); }
  let hideViewed = false;
  try { hideViewed = JSON.parse(localStorage.getItem('hideViewed')||'false'); } catch(e){}
  if (hideViewedBtn){ hideViewedBtn.textContent = hideViewed ? 'PokaÅ¼ obejrzane' : 'Ukryj obejrzane'; }

  // 1. Toggle dropdownÃ³w tylko wewnÄ…trz root
  root.querySelectorAll('.dropdown').forEach(dd => {
    const btn = dd.querySelector('button');
    if (btn) {
      btn.addEventListener('click', () => {
        dd.classList.toggle('open');
      });
    }
  });

  // 2. Pobierz wszystkie wiersze tabeli wewnÄ…trz root
  const rows = Array.from(root.querySelectorAll('#report-table tbody tr'));

  // --- SORTOWANIE: WyÅ›wietlenia (domyÅ›lnie) lub Czas (najnowsze) ---
  const tbody = root.querySelector('#report-table tbody');
  let sortKey = 'views';
  function parseRelativeTime(rel){
    if (!rel || typeof rel !== 'string') return null;
    const m = rel.match(/(\d+)\s*(d|h|m|s)/i);
    if (!m) return null;
    const val = parseInt(m[1], 10);
    const unit = m[2].toLowerCase();
    const now = Date.now();
    const ms = unit==='d'?val*24*3600*1000: unit==='h'?val*3600*1000: unit==='m'?val*60*1000: unit==='s'?val*1000: 0;
    return new Date(now - ms).getTime();
  }
  function createdTs(row){
    const iso = row.dataset.createdAt || '';
    const rel = (row.querySelector('td:nth-child(5)')?.textContent || '').trim();
    let t = iso ? Date.parse(iso) : NaN;
    if (isNaN(t)) { const approx = parseRelativeTime(rel); t = approx ?? 0; }
    return t;
  }
  function viewsVal(row){
    const attr = row.dataset.views;
    if (attr !== undefined){ const n = parseInt(attr, 10); if (!isNaN(n)) return n; }
    const txt = (row.querySelector('td:nth-child(4)')?.textContent || '').replace(/[^0-9]/g,'');
    const n2 = parseInt(txt, 10);
    return isNaN(n2) ? 0 : n2;
  }
  function applySort(){
    if (!tbody) return;
    const arr = Array.from(tbody.querySelectorAll('tr'));
    arr.sort((a,b)=> sortKey==='time' ? (createdTs(b)-createdTs(a)) : (viewsVal(b)-viewsVal(a)) );
    arr.forEach(tr=> tbody.appendChild(tr));
    // PodÅ›wietl aktywnÄ… kolumnÄ™ sortowania
    if (thViews) thViews.classList.toggle('active-sort', sortKey==='views');
    if (thTime)  thTime.classList.toggle('active-sort',  sortKey==='time');
  }
  const thViews = root.querySelector('#report-table thead th.col-views') || root.querySelector('#report-table thead th:nth-child(4)');
  const thTime  = root.querySelector('#report-table thead th.col-time')  || root.querySelector('#report-table thead th:nth-child(5)');
  if (thViews) thViews.classList.add('sortable');
  if (thTime)  thTime.classList.add('sortable');
  if (thViews && !thViews.dataset.bound){ thViews.dataset.bound='1'; thViews.style.cursor='pointer'; thViews.title = thViews.title||'Kliknij, aby sortowaÄ‡ po wyÅ›wietleniach'; thViews.addEventListener('click', ()=>{ sortKey='views'; applySort(); }); }
  if (thTime && !thTime.dataset.bound){ thTime.dataset.bound='1'; thTime.style.cursor='pointer'; thTime.title = thTime.title||'Kliknij, aby sortowaÄ‡ po czasie (najnowsze)'; thTime.addEventListener('click', ()=>{ sortKey='time'; applySort(); }); }
  applySort();

  // Zaznacz jako obejrzany po klikniÄ™ciu linku
  root.addEventListener('click', (e)=>{
    const a = e.target.closest('a[href]');
    if (!a) return;
    if (!root.contains(a)) return;
    const tr = a.closest('tr');
    if (!tr) return;
    const cb = tr.querySelector('.clip-select');
    const url = cb ? cb.dataset.url : a.getAttribute('href');
    const id = clipIdFromUrl(url);
    if (!viewedSet.has(id)){
      viewedSet.add(id);
      try { localStorage.setItem('viewedClips', JSON.stringify(Array.from(viewedSet))); } catch(e){}
    }
    // UsuÅ„ z pending nowych jeÅ›li zostaÅ‚ obejrzany
    try {
      const pending = JSON.parse(localStorage.getItem('newPendingClipIds')||'[]')||[];
      const updated = pending.filter(x=>x!==id);
      localStorage.setItem('newPendingClipIds', JSON.stringify(updated));
    } catch(e){}
    // Re-render bez reloadu (po klikniÄ™ciu i tak otwiera siÄ™ karta, ale UI odÅ›wieÅ¼amy natychmiast)
    applyFiltersAndStats();
    try { updateGlobalCounters(); } catch{}
  }, true);

  // Czy w tym widoku istnieje filtrowanie po kategoriach?
  const hasCategoryFiltering = root.querySelectorAll('.filter-category').length > 0;

  // Pomocnicze: id klipu z data-url (deklaracja funkcji hoistowana)
  function clipIdFromUrl(url){
    try{
      const u = new URL(url);
      let last = u.pathname.split('/').filter(Boolean).pop()||'clip';
      last = last.split('?')[0];
      return last.replace(/[^a-zA-Z0-9_-]/g,'')||'clip';
    }catch{ return 'clip'; }
  }

  // 3. Funkcja filtrujÄ…ca + aktualizujÄ…ca statystyki
  function applyFiltersAndStats() {
    // a) streamerzy
    const ignoredStreamers = new Set(
      Array.from(root.querySelectorAll('.filter-streamer'))
        .filter(cb => !cb.checked).map(cb => cb.value)
    );
    // b) kategorie (opcjonalne)
    const ignoredCategories = new Set(
      hasCategoryFiltering
        ? Array.from(root.querySelectorAll('.filter-category'))
            .filter(cb => !cb.checked).map(cb => cb.value)
        : []
    );

    let newCount = 0;
    // Odczytaj bieÅ¼Ä…ce newPending (NOWE)
    let newPendingArr = [];
    try { newPendingArr = JSON.parse(localStorage.getItem('newPendingClipIds')||'[]')||[]; } catch{}
    const newPendingSet = new Set(newPendingArr);
    // Tryb pokazywania tylko nowych
    const visible = [];
    rows.forEach(row => {
      const st = row.dataset.streamer;
      const ct = row.dataset.category;
      // Å¹rÃ³dÅ‚o URL klipu: preferuj przycisk .add-to-editor, inaczej fallback do linku w tytule
      const btn = row.querySelector('.add-to-editor');
      const hrefLink = row.querySelector('a[href]');
      const url = (btn && btn.dataset.url) ? btn.dataset.url : (hrefLink ? hrefLink.getAttribute('href') || '' : '');
      const id = clipIdFromUrl(url);
      const isViewed = viewedSet.has(id);
      const hideByStreamer = ignoredStreamers.has(st);
      const hideByCategory = hasCategoryFiltering ? ignoredCategories.has(ct) : false;
      const hideByViewed = hideViewed && isViewed === true;
      // Stylowanie: obejrzane i nowe
      if (isViewed){
        row.classList.add('viewed-row');
        row.classList.remove('new-unviewed');
      } else {
        row.classList.remove('viewed-row');
        if (row.classList.contains('new-row')) row.classList.add('new-unviewed');
      }
      const isNewPending = newPendingSet.has(id);
      const hide = hideByStreamer || hideByCategory || hideByViewed;
      row.style.display = hide ? 'none' : '';
      if (isNewPending && !isViewed) newCount++;
      if (!hide) visible.push(row);
      // Oznaczenie NOWE w tytule
      const titleLink = row.querySelector('a[title]');
      if (titleLink){
        const baseTitle = titleLink.getAttribute('title') || '';
        const badge = ' [NOWE]';
        if (!isViewed && !baseTitle.includes(' [NOWE]')){
          titleLink.setAttribute('title', baseTitle + badge);
        } else if (isViewed && baseTitle.includes(' [NOWE]')){
          titleLink.setAttribute('title', baseTitle.replace(' [NOWE]',''));
        }
      }
    });

    // c) oblicz statystyki
    const total = visible.length;
    const catCounts = {}, strCounts = {};
    visible.forEach(r => {
      const st = r.dataset.streamer;
      strCounts[st] = (strCounts[st]||0)+1;
      if (hasCategoryFiltering) {
        const ct = r.dataset.category;
        if (ct !== undefined) {
          catCounts[ct] = (catCounts[ct]||0)+1;
        }
      }
    });
    const topCats = hasCategoryFiltering
      ? Object.entries(catCounts).sort((a,b)=>b[1]-a[1]).slice(0,3)
      : [];
    const topStr = Object.entries(strCounts)
      .sort((a,b)=>b[1]-a[1]).slice(0,3);

    // d) wstaw do root, nie do document (i tylko jeÅ›li elementy istniejÄ…)
    const totalEl = root.querySelector('#stats-total');
    if (totalEl) totalEl.textContent = total;

    const catsEl = root.querySelector('#stats-categories');
    if (catsEl) catsEl.textContent = topCats.map(([c,n])=>`${c} (${n})`).join(', ');

    const strEl = root.querySelector('#stats-streamers');
    if (strEl) strEl.textContent = topStr.map(([s,n])=>`${s} (${n})`).join(', ');

    applySort();
    // e) lokalne liczniki zostawiamy, globalny licznik zsumujemy poniÅ¼ej
  }

  // 4. PodÅ‚Ä…cz przyciski filtrÃ³w tylko wewnÄ…trz root (z guardami)
  const applyStreamersBtn = root.querySelector('#apply-streamers');
  if (applyStreamersBtn) {
    applyStreamersBtn.addEventListener('click', ()=>{
      applyFiltersAndStats();
      const ddS = root.querySelector('#dd-streamers');
      if (ddS) ddS.classList.remove('open');
      try { updateGlobalCounters(); } catch{}
    });
  }

  const applyCategoriesBtn = root.querySelector('#apply-categories');
  if (applyCategoriesBtn) {
    applyCategoriesBtn.addEventListener('click', ()=>{
      applyFiltersAndStats();
      const ddC = root.querySelector('#dd-categories');
      if (ddC) ddC.classList.remove('open');
      try { updateGlobalCounters(); } catch{}
    });
  }

  // 5. Kolejka edytora: dodawanie per klip, zapisane i przejÅ›cie
  const proceedBtn = root.querySelector('#twitch-proceed-editor') || root.querySelector('#kick-proceed-editor');
  const viewSavedBtn = root.querySelector('#twitch-view-saved') || root.querySelector('#kick-view-saved');
  const isTwitch = !!root.querySelector('#twitch-report-root');
  const currentSource = isTwitch ? 'Twitch' : 'Kick';
  // Lekki, estetyczny popup (toast) przy gÃ³rze ekranu
  function showToast(message, type='info'){
    try{
      let rootEl = document.getElementById('toast-root');
      if (!rootEl){
        rootEl = document.createElement('div');
        rootEl.id = 'toast-root';
        rootEl.style.cssText = 'position:fixed;top:12px;left:50%;transform:translateX(-50%);z-index:9999;display:flex;flex-direction:column;gap:8px;';
        document.body.appendChild(rootEl);
      }
      const t = document.createElement('div');
      t.textContent = message;
      t.style.cssText = 'background:#1f2937;color:#fff;padding:8px 12px;border-radius:8px;box-shadow:0 8px 20px rgba(0,0,0,0.20);border:1px solid rgba(255,255,255,0.08);font-size:14px;opacity:0;transform:translateY(-6px);transition:opacity .25s ease, transform .25s ease;';
      if (type==='success'){ t.style.background = '#14532d'; t.style.borderColor = '#166534'; }
      if (type==='error'){ t.style.background = '#7f1d1d'; t.style.borderColor = '#991b1b'; }
      rootEl.appendChild(t);
      requestAnimationFrame(()=>{ t.style.opacity = '1'; t.style.transform = 'translateY(0)'; });
      setTimeout(()=>{
        t.style.opacity = '0';
        t.style.transform = 'translateY(-6px)';
        setTimeout(()=>{ try{ t.remove(); }catch{} }, 300);
      }, 2500);
    }catch{}
  }
  const readSavedClips = () => { try { return JSON.parse(localStorage.getItem('savedClips')||'[]')||[]; } catch { return []; } };
  const writeSavedClips = (arr) => { try { localStorage.setItem('savedClips', JSON.stringify(arr)); } catch {} };
  // WspÃ³lna kolejka klipÃ³w (Twitch + Kick)
  // Zapisy pozostajÄ… z polem source, ale operacje UI dziaÅ‚ajÄ… na caÅ‚ej liÅ›cie
    const savedAll = () => readSavedClips();
    const clipIdFrom = (url)=>{ try{ const u = new URL(url); let last = u.pathname.split('/').filter(Boolean).pop()||url; return last.split('?')[0]; }catch{ return url; } };
    const getProceedBtn = () => document.querySelector('#raport-container #twitch-proceed-editor');
    const updateProceedState = () => {
      const disabled = savedAll().length===0;
      const localProceed = getProceedBtn();
      if (localProceed) localProceed.disabled = disabled;
      const fab = document.getElementById('proceed-fab');
      if (fab) { fab.disabled = disabled; }
      const proceedFixed = document.getElementById('proceed-editor-fixed');
      if (proceedFixed) proceedFixed.disabled = disabled;
      const proceedFallback = document.getElementById('fallback-proceed-editor');
      if (proceedFallback) proceedFallback.disabled = disabled;
    };

    // Global: panel zapisanych (uÅ¼ywany przez fallback i lokalny panel)
    function renderSavedPanel(panel){
      if (!panel) return;
      const clips = savedAll();
      if (!clips.length){
        panel.innerHTML = '<div class="hint">Brak zapisanych klipÃ³w.</div>';
      } else {
        const items = clips.map(c=>`<li data-url="${c.url}"><a href="${c.url}" target="_blank">${(c.title||c.url).replace(/"/g,'&quot;')}</a> <span class="hint">(${c.broadcaster||'?'}${c.source?' â€¢ '+c.source:''})</span> <button class="btn btn-small remove-saved" data-url="${c.url}">UsuÅ„</button></li>`).join('');
        panel.innerHTML = `<div style="margin-bottom:6px;"><strong>Zapisane klipy (${clips.length}):</strong></div><ul style="margin:0; padding-left:20px;">${items}</ul>`;
      }
    }
    // UczyÅ„ najwaÅ¼niejsze funkcje dostÄ™pne globalnie, aby uniknÄ…Ä‡ ReferenceError
    try {
      window.readSavedClips = readSavedClips;
      window.writeSavedClips = writeSavedClips;
      window.savedAll = savedAll;
      window.renderSavedPanel = renderSavedPanel;
      window.clipIdFrom = clipIdFrom;
    } catch {}

    

    // Global fallback: oznaczanie obejrzanych po klikniÄ™ciu linku w tabeli
    document.addEventListener('click', (e)=>{
      const a = e.target.closest('#raport-container #report-table a[href], #kick-report-container #report-table a[href]');
      if (!a) return;
      const href = a.getAttribute('href')||'';
      const id = (window.clipIdFrom ? window.clipIdFrom(href) : href);
      let viewedSet = new Set();
      try{ viewedSet = new Set(JSON.parse(localStorage.getItem('viewedClips')||'[]')); }catch{}
      if (!viewedSet.has(id)){
        viewedSet.add(id);
        try{ localStorage.setItem('viewedClips', JSON.stringify(Array.from(viewedSet))); }catch{}
      }
      try { if (typeof applyFiltersAndStats === 'function') applyFiltersAndStats(); } catch {}
      try { markViewedRowsGeneric(); } catch{}
      try { updateGlobalCounters(); } catch{}
    }, true);

    // Uniwersalne odÅ›wieÅ¼enie klas obejrzanych dla Twitch i Kick
    function markViewedRowsGeneric(){
      // Odczyt aktualnego stanu
      let viewedArr = [];
      try { viewedArr = JSON.parse(localStorage.getItem('viewedClips')||'[]')||[]; } catch {}
      const viewedSet = new Set(viewedArr);
      let newPendingArr = [];
      try { newPendingArr = JSON.parse(localStorage.getItem('newPendingClipIds')||'[]')||[]; } catch{}
      const newPendingSet = new Set(newPendingArr);
      let hideViewed = false;
      try { hideViewed = JSON.parse(localStorage.getItem('hideViewed')||'false'); } catch{}
      let showOnlyNew = false;
      try { showOnlyNew = JSON.parse(localStorage.getItem('showOnlyNew')||'false'); } catch{}
      ['#raport-container', '#kick-report-container'].forEach(rootSel=>{
        const root = document.querySelector(rootSel);
        if (!root) return;
        const rows = root.querySelectorAll('#report-table tbody tr');
        rows.forEach(row=>{
          const btn = row.querySelector('.add-to-editor');
          const hrefLink = row.querySelector('a[href]');
          const url = (btn && btn.dataset.url) ? btn.dataset.url : (hrefLink ? hrefLink.getAttribute('href')||'' : '');
          const id = window.clipIdFrom ? window.clipIdFrom(url) : url;
          const isViewed = viewedSet.has(id);
          const isNewPending = newPendingSet.has(id);
          // Aktualizuj klasy, bez ingerencji w display (logikÄ™ ukrywania robi applyFiltersAndStats)
          row.classList.toggle('viewed-row', isViewed);
          row.classList.toggle('new-row', isNewPending && !isViewed);
          row.classList.toggle('new-unviewed', isNewPending && !isViewed);
          // Nie zmieniaj bezpoÅ›rednio row.style.display tutaj, aby nie nadpisaÄ‡ filtrÃ³w streamer/kategoria
        });
      });
    }

    // Fallback: pokaÅ¼/ukryj globalne przyciski, gdy nie ma lokalnego przycisku w raporcie
    function toggleFallbackControls(show){
      const fc = document.getElementById('fallback-editor-controls');
      if (!fc) return;
      fc.style.display = show ? 'flex' : 'none';
      updateProceedState();
    }

    // PodpiÄ™cie zdarzeÅ„ dla fallback przyciskÃ³w
    (function bindFallbackControls(){
      const proceedFallback = document.getElementById('fallback-proceed-editor');
      const viewSavedFallback = document.getElementById('fallback-view-saved');
      if (proceedFallback && !proceedFallback.dataset.bound){
        proceedFallback.dataset.bound = '1';
        proceedFallback.addEventListener('click', (e)=>{
          e.preventDefault();
          if (proceedFallback.disabled) return;
          const selected = savedAll();
          try {
            localStorage.setItem('pendingSelection', JSON.stringify({ clips: selected }));
            window.location.assign('/editor');
          } catch (e) {
            alert('Nie udaÅ‚o siÄ™ zapisaÄ‡ wyboru: ' + e);
          }
        });
      }
      if (viewSavedFallback && !viewSavedFallback.dataset.bound){
        viewSavedFallback.dataset.bound = '1';
        viewSavedFallback.addEventListener('click', (e)=>{
          e.preventDefault();
          let panel = document.getElementById('saved-clips-panel');
          if (!panel){
            panel = document.createElement('div');
            panel.id = 'saved-clips-panel';
            panel.className = 'saved-panel';
            panel.style.display = 'none';
            panel.style.position = 'fixed';
            panel.style.right = '16px';
            panel.style.bottom = '64px';
            panel.style.background = '#fafafa';
            panel.style.border = '1px solid #ddd';
            panel.style.borderRadius = '6px';
            panel.style.padding = '8px';
            panel.style.maxWidth = '360px';
            panel.style.zIndex = '9998';
            document.body.appendChild(panel);
          }
          if (panel.style.display === 'none' || !panel.style.display){ renderSavedPanel(panel); panel.style.display = 'block'; }
          else { panel.style.display = 'none'; }
        });
      }
      updateProceedState();
    })();
    // JeÅ›li globalny pasek istnieje, upewnij siÄ™, Å¼e ma podpiÄ™te zdarzenia
    (function ensureFixedBarEvents(){
      const proceedFixed = document.getElementById('proceed-editor-fixed');
      const viewSavedFixed = document.getElementById('view-saved-fixed');
      if (proceedFixed && !proceedFixed.dataset.bound){
        proceedFixed.dataset.bound = '1';
        proceedFixed.addEventListener('click', (e)=>{
          e.preventDefault();
          if (proceedFixed.disabled) return;
          const selected = savedAll();
          try { localStorage.setItem('pendingSelection', JSON.stringify({ clips: selected })); window.location.assign('/editor'); }
          catch (e) { alert('Nie udaÅ‚o siÄ™ zapisaÄ‡ wyboru: ' + e); }
        });
      }
      if (viewSavedFixed && !viewSavedFixed.dataset.bound){
        viewSavedFixed.dataset.bound = '1';
        viewSavedFixed.addEventListener('click', (e)=>{
          e.preventDefault();
          let panel = document.querySelector('#raport-container #saved-clips-panel') || document.getElementById('saved-clips-panel');
          if (!panel){
            panel = document.createElement('div');
            panel.id = 'saved-clips-panel';
            panel.className = 'saved-panel';
            panel.style.display = 'none';
            panel.style.position = 'fixed';
            panel.style.right = '16px';
            panel.style.bottom = '64px';
            panel.style.background = '#fafafa';
            panel.style.border = '1px solid #ddd';
            panel.style.borderRadius = '6px';
            panel.style.padding = '8px';
            panel.style.maxWidth = '360px';
            panel.style.zIndex = '9998';
            document.body.appendChild(panel);
          }
          if (panel.style.display === 'none' || !panel.style.display){ renderSavedPanel(panel); panel.style.display = 'block'; }
          else { panel.style.display = 'none'; }
        });
      }
      updateProceedState();
    })();

    // Nowy globalny handler: przyciski â•/âœ– w kolumnie â€Akcjaâ€ (Twitch + Kick)
    (function bindGlobalAddRemove(){
      function detectSource(url){
        try {
          const u = new URL(url, window.location.origin);
          const h = (u.hostname||'').toLowerCase();
          if (h.includes('kick.com')) return 'Kick';
          if (h.includes('twitch.tv') || h.includes('clips.twitch.tv')) return 'Twitch';
        } catch {}
        return '';
      }
      function syncButtons(url, added){
        try{
          document.querySelectorAll(`.add-to-editor[data-url="${url}"]`).forEach(b=>{
            b.classList.toggle('added', !!added);
            b.textContent = added ? 'âœ–' : 'â•';
            b.style.minWidth = '28px';
            b.style.textAlign = 'center';
          });
        }catch{}
      }
      function refreshSavedPanelIfOpen(){
        try{
          const panel = document.getElementById('saved-clips-panel');
          if (panel && panel.style.display !== 'none'){ renderSavedPanel(panel); }
        }catch{}
      }
      // Guard: nie dopuszczaj do wielokrotnego bindowania handlera
      if (!window.__queueToggleBound){
        window.__queueToggleBound = true;
        const onDocClickToggle = (e)=>{
          const btn = e.target.closest('.add-to-editor');
          if (!btn) return;
          e.preventDefault();
          // zatrzymaj propagacjÄ™, aby uniknÄ…Ä‡ ewentualnych dubli
          if (typeof e.stopImmediatePropagation === 'function') e.stopImmediatePropagation();
          // Globalny deduplikator: ignoruj kolejne klikniÄ™cie tego samego klipu w krÃ³tkim oknie czasowym
          const urlGuard = btn.dataset.url || '';
          const idGuard = clipIdFrom(urlGuard);
          try{
            if (!window.__toggleGuard) window.__toggleGuard = new Map();
            const last = window.__toggleGuard.get(idGuard) || 0;
            const now = performance.now ? performance.now() : Date.now();
            if (now - last < 300) return; // zbyt szybko â€“ potraktuj jako duplikat
            window.__toggleGuard.set(idGuard, now);
          }catch{}
          // Lokalny busy-guard na sam przycisk (dla bezpieczeÅ„stwa)
          if (btn.dataset.busy) return;
          btn.dataset.busy = '1';
          setTimeout(()=>{ try { delete btn.dataset.busy; } catch{} }, 150);

          const url = btn.dataset.url || '';
          const broadcaster = btn.dataset.broadcaster || '';
          const title = btn.dataset.title || '';
          const id = clipIdFrom(url);
          let saved = readSavedClips();
          const exists = saved.some(x=> clipIdFrom(x.url)===id);
          if (exists){
            saved = saved.filter(x=> clipIdFrom(x.url)!==id);
            writeSavedClips(saved);
            syncButtons(url, false);
            try{ showToast('UsuniÄ™to z kolejki', 'success'); }catch{}
          } else {
            const source = detectSource(url);
            saved.push({ url, broadcaster, title, source });
            writeSavedClips(saved);
            syncButtons(url, true);
            try{ showToast('Dodano do kolejki edytora', 'success'); }catch{}
          }
          refreshSavedPanelIfOpen();
          updateProceedState();
        };
        document.addEventListener('click', onDocClickToggle);
        // Silny guard: usuwaj i ponownie podpinaj handler przy kaÅ¼dej peÅ‚nej wymianie fragmentu raportu,
        // aby uniknÄ…Ä‡ dublowania w sytuacjach dynamicznego montowania (generowanie raportu Twitch/Kick)
        const originalLoadReportFragment = window.loadReportFragment;
        if (typeof originalLoadReportFragment === 'function'){
          window.loadReportFragment = async function(){
            // Zdejmij nasÅ‚uch przed peÅ‚nÄ… wymianÄ… fragmentu
            try{ document.removeEventListener('click', onDocClickToggle); }catch{}
            let res;
            try{
              res = await originalLoadReportFragment();
            } finally {
              // PrzywrÃ³Ä‡ nasÅ‚uch ZAWSZE, nawet jeÅ›li wystÄ…pi bÅ‚Ä…d/abort
              try{ document.addEventListener('click', onDocClickToggle); }catch{}
            }
            return res;
          };
        }
        const originalPollKick = window.pollKick;
        if (typeof originalPollKick === 'function'){
          window.pollKick = async function(){
            try{ document.removeEventListener('click', onDocClickToggle); }catch{}
            let v;
            try{
              v = await originalPollKick();
            } finally {
              try{ document.addEventListener('click', onDocClickToggle); }catch{}
            }
            return v;
          };
        }
      }
    })();
  // Pasywna synchronizacja UI dla nieliderÃ³w: nasÅ‚uch zmian latestStatus w localStorage
  try{
    window.addEventListener('storage', (e)=>{
      try{
        if (e && e.key === LATEST_STATUS_KEY){
          const p = JSON.parse(e.newValue||'{}');
          updateTwitchProgressFromStatus(p);
        }
      }catch{}
    });
    // Jednorazowa aktualizacja z ostatniego stanu (jeÅ›li istnieje)
    try{ const p0 = readLatest(); if (p0 && p0.status){ updateTwitchProgressFromStatus(p0); } }catch{}
  }catch{}
  // Inicjalna synchronizacja ikon +/âœ– z zapisanymi klipami
  (function initAddButtons(){
    try{
      const saved = savedAll();
      document.querySelectorAll('.add-to-editor').forEach(b=>{
        const id = clipIdFrom(b.dataset.url);
        const exists = saved.some(x=>clipIdFrom(x.url)===id);
        if (exists){ b.classList.add('added'); b.textContent = 'âœ–'; }
        else { b.classList.remove('added'); b.textContent = 'â•'; }
      });
    }catch{}
  })();
  // Podpinanie lokalnego przycisku po wstrzykniÄ™ciu fragmentu Twitch

  // 5b. Panel zapisanych + usuwanie (panel lokalny w Twitch fragmencie)
  // Dodawanie pojedynczego klipu z wiersza tabeli
  // (usuniÄ™to: lokalny handler klikniÄ™Ä‡ .add-to-editor)

  // (usuniÄ™to: efekty hover dla .add-to-editor)
  // Usuwanie z panelu zapisanych
  root.addEventListener('click', (e)=>{
    const rm = e.target.closest('.remove-saved');
    if (!rm) return;
    e.preventDefault();
    const url = rm.dataset.url;
    const all = readSavedClips();
    // Usuwamy po id klipu (niezaleÅ¼nie od ÅºrÃ³dÅ‚a), aby kolejka byÅ‚a globalna
    const filtered = all.filter(c=>clipIdFrom(c.url) !== clipIdFrom(url));
    writeSavedClips(filtered);
    // OdÅ›wieÅ¼ panel tylko jeÅ›li jest widoczny
    try{
      const panel = document.getElementById('saved-clips-panel');
      if (panel && panel.style.display !== 'none'){ renderSavedPanel(panel); }
    }catch{}
    updateProceedState();
    try{
      // Odblokuj wszystkie odpowiadajÄ…ce przyciski w obu raportach
      document.querySelectorAll(`.add-to-editor[data-url="${url}"]`).forEach(rowBtn=>{
        rowBtn.classList.remove('added');
        rowBtn.textContent = 'â•';
      });
    }catch{}
  });
  // Globalny overlay: obsÅ‚uga usuwania zapisanych poza raportem Twitch/Kick
  document.addEventListener('click', (e)=>{
    const rm = e.target.closest('.remove-saved');
    if (!rm) return;
    // jeÅ›li klik byÅ‚ wewnÄ…trz root, zostaÅ‚ juÅ¼ obsÅ‚uÅ¼ony powyÅ¼ej
    if (root.contains(rm)) return;
    e.preventDefault();
    const url = rm.dataset.url;
    const all = readSavedClips();
    const filtered = all.filter(c=>clipIdFrom(c.url) !== clipIdFrom(url));
    writeSavedClips(filtered);
    showToast('UsuniÄ™to z kolejki', 'success');
    try{
      document.querySelectorAll(`.add-to-editor[data-url="${url}"]`).forEach(rowBtn=>{
        rowBtn.classList.remove('added');
        rowBtn.textContent = 'â•';
      });
    }catch{}
    try{
      const panel = document.getElementById('saved-clips-panel');
      if (panel && panel.style.display !== 'none'){ renderSavedPanel(panel); }
    }catch{}
    updateProceedState();
  });
  // Przycisk "PokaÅ¼ zapisane" lokalny bÄ™dzie podpinany po wstrzykniÄ™ciu

  // 6. Reakcja na przycisk Ukryj/PokaÅ¼ obejrzane
  if (hideViewedBtn){
    hideViewedBtn.addEventListener('click', ()=>{
      hideViewed = !hideViewed;
      try{ localStorage.setItem('hideViewed', JSON.stringify(hideViewed)); }catch(e){}
      hideViewedBtn.textContent = hideViewed ? 'PokaÅ¼ obejrzane' : 'Ukryj obejrzane';
      try { if (typeof applyFiltersAndStats === 'function') applyFiltersAndStats(); } catch{}
      try { markViewedRowsGeneric(); } catch{}
      try { updateGlobalCounters(); } catch{}
    });
  }

  // 7. ObsÅ‚uga dropdown dla otwierania nieobejrzanych klipÃ³w
  const openUnviewedBtn = document.getElementById('btn-open-unviewed');
  const unviewedDropdown = document.getElementById('unviewed-dropdown');
  const dropdownContainer = openUnviewedBtn?.parentElement;

  if (openUnviewedBtn && unviewedDropdown && !openUnviewedBtn.hasAttribute('data-listeners-added')) {
    // Oznacz, Å¼e event listenery zostaÅ‚y dodane
    openUnviewedBtn.setAttribute('data-listeners-added', 'true');
    
    // Toggle dropdown
    openUnviewedBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      dropdownContainer.classList.toggle('open');
    });

    // Zamknij dropdown po klikniÄ™ciu poza nim
    const closeDropdown = () => {
      dropdownContainer.classList.remove('open');
    };
    document.addEventListener('click', closeDropdown);

    // ObsÅ‚uga opcji dropdown
    unviewedDropdown.addEventListener('click', (e) => {
      e.stopPropagation();
      const limit = e.target.dataset.limit;
      if (limit) {
        openUnviewedClips(limit);
        dropdownContainer.classList.remove('open');
      }
    });
  }

  // Funkcja otwierania nieobejrzanych klipÃ³w
  let isOpeningClips = false;
  function openUnviewedClips(limit) {
    try {
      // Zabezpieczenie przed wielokrotnym wywoÅ‚aniem
      if (isOpeningClips) {
        console.log('openUnviewedClips already in progress, ignoring call');
        return;
      }
      isOpeningClips = true;
      
      // Pobierz listÄ™ obejrzanych klipÃ³w
      const viewedSet = new Set(JSON.parse(localStorage.getItem('viewedClips') || '[]'));
      console.log('Viewed clips:', Array.from(viewedSet));
      
      // ZnajdÅº wszystkie nieobejrzane klipy z aktualnie widocznej tabeli
      const unviewedClips = [];
      const rows = document.querySelectorAll('tbody tr');
      console.log('Total rows found:', rows.length);
      
      rows.forEach((row, index) => {
        // SprawdÅº czy wiersz jest ukryty
        const isHidden = row.style.display === 'none';
        if (isHidden) {
          console.log(`Row ${index} is hidden, skipping`);
          return;
        }
        
        // ZnajdÅº link do klipu w wierszu (trzecia kolumna z tytuÅ‚em)
        const clipLink = row.querySelector('td:nth-child(3) a[target="_blank"]');
        if (!clipLink) {
          console.log(`Row ${index}: No clip link found`);
          return;
        }
        
        const clipUrl = clipLink.href;
        const clipId = clipIdFromUrl(clipUrl);
        console.log(`Row ${index}: URL=${clipUrl}, ID=${clipId}, viewed=${viewedSet.has(clipId)}`);
        
        if (clipId && !viewedSet.has(clipId)) {
          unviewedClips.push({ id: clipId, url: clipUrl });
          console.log(`Added clip ${clipId} to unviewed list`);
        }
      });

      console.log('Total unviewed clips found:', unviewedClips.length);
      if (unviewedClips.length === 0) {
        alert('Brak nieobejrzanych klipÃ³w do otwarcia!');
        return;
      }

      // OkreÅ›l liczbÄ™ klipÃ³w do otwarcia
      let clipsToOpen = unviewedClips;
      if (limit !== 'all') {
        const limitNum = parseInt(limit);
        clipsToOpen = unviewedClips.slice(0, limitNum);
        console.log(`Limiting to ${limitNum} clips from ${unviewedClips.length} total`);
      }
      console.log('Clips to open:', clipsToOpen.length);

      // Potwierdzenie dla duÅ¼ej liczby kart
      if (clipsToOpen.length > 20) {
        const confirmed = confirm(`Czy na pewno chcesz otworzyÄ‡ ${clipsToOpen.length} kart? To moÅ¼e spowolniÄ‡ przeglÄ…darkÄ™.`);
        if (!confirmed) return;
      }

      // OtwÃ³rz klipy w nowych kartach i oznacz jako obejrzane
      clipsToOpen.forEach((clip, index) => {
        console.log(`Scheduling clip ${index + 1}/${clipsToOpen.length}: ${clip.url}`);
        setTimeout(() => {
          console.log(`Opening clip ${index + 1}: ${clip.url}`);
          // OtwÃ³rz prawdziwy URL klipu (Kick/Twitch)
          window.open(clip.url, '_blank');
          
          // Oznacz jako obejrzany
          viewedSet.add(clip.id);
          try {
            localStorage.setItem('viewedClips', JSON.stringify(Array.from(viewedSet)));
            console.log(`Marked clip ${clip.id} as viewed`);
          } catch(e) {
            console.error('Error saving to localStorage:', e);
          }
        }, index * 100); // OpÃ³Åºnienie 100ms miÄ™dzy otwieraniem kart
      });

      // OdÅ›wieÅ¼ widok po oznaczeniu jako obejrzane
      setTimeout(() => {
        try {
          if (typeof markViewedRowsGeneric === 'function') markViewedRowsGeneric();
          if (typeof updateGlobalCounters === 'function') updateGlobalCounters();
        } catch(e) {}
      }, clipsToOpen.length * 100 + 500);

      alert(`Otwarto ${clipsToOpen.length} klipÃ³w w nowych kartach!`);
      
      // Resetuj flagÄ™ po zakoÅ„czeniu
      setTimeout(() => {
        isOpeningClips = false;
      }, clipsToOpen.length * 100 + 1000);
      
    } catch (error) {
      console.error('BÅ‚Ä…d podczas otwierania klipÃ³w:', error);
      alert('WystÄ…piÅ‚ bÅ‚Ä…d podczas otwierania klipÃ³w.');
      isOpeningClips = false; // Resetuj flagÄ™ w przypadku bÅ‚Ä™du
    }
  }

  // Przycisk "PokaÅ¼ tylko nowe" / "PokaÅ¼ wszystkie"
  // usuniÄ™to przycisk trybu â€tylko nowe", pozostaje filtr obejrzanych

  // Floating FAB: pokaÅ¼ przycisk "Dalej do edytora" w prawym dolnym rogu, gdy lokalny przycisk niewidoczny
  function setupProceedFabFor(localBtn){
    let fab = document.getElementById('proceed-fab');
    if (!fab){
      fab = document.createElement('button');
      fab.id = 'proceed-fab';
      fab.className = 'btn fab-proceed';
      fab.textContent = 'â¡ï¸ Dalej do edytora';
      fab.style.display = 'none';
      document.body.appendChild(fab);
      fab.addEventListener('click', (e)=>{
        e.preventDefault();
        if (fab.disabled) return;
        const selected = savedAll();
        try {
          localStorage.setItem('pendingSelection', JSON.stringify({ clips: selected }));
          window.location.assign('/editor');
        } catch (e) {
          alert('Nie udaÅ‚o siÄ™ zapisaÄ‡ wyboru: ' + e);
        }
      });
    }
    if (!localBtn){ fab.style.display = 'none'; return; }
    try { if (window._fabObserver) { window._fabObserver.disconnect(); } } catch{}
    const io = new IntersectionObserver((entries)=>{
      const visible = entries.some(en=>en.isIntersecting);
      fab.style.display = (!visible) ? 'block' : 'none';
      fab.disabled = savedAll().length===0;
    }, { threshold: 0.3 });
    io.observe(localBtn);
    window._fabObserver = io;
    updateProceedState();
  }

  // 7. Pierwsze wyliczenie
  applyFiltersAndStats();
  updateGlobalCounters();
}

  // (usuniÄ™to zduplikowanÄ… definicjÄ™ updateGlobalCounters; funkcja jest zdefiniowana na gÃ³rze skryptu)

    // PodÃ…â€šÃ„â€¦czamy eventy do przyciskÃƒÂ³w
    document.getElementById('btn-update').addEventListener('click', runUpdate);
    document.getElementById('btn-report').addEventListener('click', runReport);
    // Auto-odÅ›wieÅ¼anie: caÅ‚kowicie lokalny timer bez zapytaÅ„ do backendu
    window.addEventListener('load', async ()=>{
      console.log('[Kick] window.load: start');
      nextRunAt = calcNextDecaminTimestamp();
      startCountdown();
      // Nie sprawdzaj gotowoÅ›ci Twitch na starcie; ograniczamy wywoÅ‚ania API
      // (fragment Twitch zostanie zaÅ‚adowany dopiero po generowaniu)
      // UWAGA: Na starcie nie odpytywaÄ‡ Kick (status/ready). Uruchamiamy tylko
      // lokalny licznik i Twitch fragment (jeÅ›li gotowy). Kick odpytujemy dopiero
      // gdy uÅ¼ytkownik kliknie lub gdy timer dojdzie do zera (autoTriggerGeneration).
      // WymuÅ› ukrycie UI Kick na starcie (bez generowania)
      try{
        if (kickProgressContainer) kickProgressContainer.style.display = 'none';
        if (kickProgressBar) kickProgressBar.style.display = 'none';
        if (progressCounterKick) progressCounterKick.textContent = 'â€”';
      }catch{}
      // Zaktualizuj globalny licznik po starcie (guard na istnienie funkcji)
      try { if (typeof updateGlobalCounters === 'function') updateGlobalCounters(); } catch {}
      // PrzywrÃ³Ä‡ pasek postÄ™pu po odÅ›wieÅ¼eniu na podstawie ostatniego statusu
      try {
        const persisted = readLatest();
        const st = persisted && persisted.status ? persisted.status : 'idle';
        if (st === 'scraping' || st === 'generating' || st === 'running'){
          // Wznowienie cyklu: pokaÅ¼ pasek i uruchom wspÃ³lne pollowanie
          autoGenActive = true;
          autoTriggerStarted = true; // zapobiegaj podwÃ³jnemu startowi
          autoGenSeenActive = true;
          try { updateTwitchProgressFromStatus(persisted); } catch{}
          try{ if (twitchProgressBar) twitchProgressBar.style.display = 'block'; }catch{}
          if (autoGenPollId) clearInterval(autoGenPollId);
          if (autoGenReadyPollId) clearInterval(autoGenReadyPollId);
          startAutoGenerationPolling();
        } else if (st === 'finished') {
          // JeÅ›li zakoÅ„czone: sprÃ³buj wstrzyknÄ…Ä‡ utrwalony raport bez pollowania
          try {
            const isReady = await checkReadyOnce();
            if (isReady) { await loadTwitchFragmentOnce(); }
          } catch{}
          autoGenActive = false;
          autoTriggerStarted = false;
          autoGenSeenActive = false;
          try{ if (twitchProgressBar) twitchProgressBar.style.display = 'none'; }catch{}
          try{ if (progressCounter) { progressCounter.style.display = 'none'; progressCounter.textContent = ''; } }catch{}
          try{ if (progressFillEl) progressFillEl.style.width = '0%'; }catch{}
        } else {
          // Idle: licz wyÅ‚Ä…cznie lokalny countdown, bez pollowania backendu
          autoGenActive = false;
          autoTriggerStarted = false;
          autoGenSeenActive = false;
          try{ if (twitchProgressBar) twitchProgressBar.style.display = 'none'; }catch{}
          try{ if (progressCounter) { progressCounter.style.display = 'none'; progressCounter.textContent = ''; } }catch{}
          try{ if (progressFillEl) progressFillEl.style.width = '0%'; }catch{}
        }
      } catch {}
      // Fallback: jeÅ›li lokalny przycisk Twitch nie istnieje â†’ pokaÅ¼ globalne przyciski
      try{
        const hasLocalProceed = !!document.querySelector('#raport-container #twitch-proceed-editor');
        toggleFallbackControls(true);
      }catch{}
      // StraÅ¼nik po reloadzie: jeÅ›li raport Twitch jest gotowy, a kontener pusty â€” dociÄ…gnij fragment
      try {
        if (ensureTwitchMountPollId) clearInterval(ensureTwitchMountPollId);
        ensureTwitchMountPollId = setInterval(async ()=>{
          try {
            const tc = document.getElementById('raport-container');
            const hasContent = !!(tc && tc.innerHTML && tc.innerHTML.trim().length);
            if (!autoGenActive && !hasContent) {
              const isReady = await checkReadyOnce();
              if (isReady) {
                const injected = await loadTwitchFragmentOnce();
                if (injected && ensureTwitchMountPollId) { clearInterval(ensureTwitchMountPollId); ensureTwitchMountPollId = null; }
              }
            }
          } catch {}
        }, 3000);
      } catch {}
      // StraÅ¼nik po reloadzie: Kick â€“ jeÅ›li gotowy i kontener pusty, dociÄ…gnij fragment bez rÄ™cznego odÅ›wieÅ¼ania
      try {
        if (ensureKickMountPollId) clearInterval(ensureKickMountPollId);
        ensureKickMountPollId = setInterval(async ()=>{
          try {
            const kc = document.getElementById('kick-report-container');
            const hasKickContent = !!(kc && kc.innerHTML && kc.innerHTML.trim().length);
            if (!hasKickContent) {
              const rk = await fetch('/api/report-kick-ready', { cache: 'no-store' }).then(r=>r.json());
              if (rk && rk.ready) {
                const bust = Date.now();
                const htmlK = await fetch(`/raport-kick-fragment?v=${bust}`, { cache: 'no-store' }).then(r=>r.text());
                // PokaÅ¼ tylko jeÅ›li sÄ… wiersze z danymi
                let canShowKick = false;
                try {
                  const tmpK = document.createElement('div');
                  tmpK.innerHTML = htmlK;
                  canShowKick = tmpK.querySelectorAll('#report-table tbody tr').length > 0;
                } catch {}
                if (kc && canShowKick) {
                  kc.innerHTML = htmlK;
                  try { kc.style.display = 'block'; } catch{}
                  try { markNewRowsAfterInject(kc); } catch{}
                  initReportFiltersAndStats(kc);
                  try { updateGlobalCounters(); } catch{}
                  if (ensureKickMountPollId) { clearInterval(ensureKickMountPollId); ensureKickMountPollId = null; }
                }
              }
            }
          } catch {}
        }, 3000);
      } catch {}
      try {
        // Kick: po zaÅ‚adowaniu strony uruchom tylko pollowanie statusu,
        // bez natychmiastowego wstrzykiwania starego raportu.
        try { startKickStatusPolling(false); } catch{}
        
      } catch {}
      // UsuniÄ™to fallback staÅ‚ego paska; wykorzystujemy tylko lokalny przycisk + FAB
    });
  </script>
  <script>
    // Logika lidera wyÅ‚Ä…czona â€” wszystkie karty dziaÅ‚ajÄ… samodzielnie
  </script>
  
  <script>
    // Calendar/Scheduler functionality
    let calendarData = [];
    let selectedPosts = new Set();
    
    // SPA Navigation State
    let currentPage = 'main'; // 'main' or 'calendar'
    let savedReportsState = {
      twitchVisible: false,
      kickVisible: false,
      twitchContent: '',
      kickContent: ''
    };

    // SPA Navigation Functions
    function showMainPage() {
      document.getElementById('main-page').style.display = 'block';
      document.getElementById('calendar-page').style.display = 'none';
      currentPage = 'main';
      
      // Restore reports state
      const raportContainer = document.getElementById('raport-container');
      const kickReportContainer = document.getElementById('kick-report-container');
      
      if (savedReportsState.twitchContent) {
        raportContainer.innerHTML = savedReportsState.twitchContent;
      }
      if (savedReportsState.kickContent) {
        kickReportContainer.innerHTML = savedReportsState.kickContent;
      }
      
      if (savedReportsState.twitchVisible && savedReportsState.twitchContent) {
        raportContainer.style.display = 'block';
      }
      if (savedReportsState.kickVisible && savedReportsState.kickContent) {
        kickReportContainer.style.display = 'block';
      }
      
      // Check if we should resume polling based on last known status
      try {
        const persisted = readLatest();
        const st = persisted && persisted.status ? persisted.status : 'idle';
        if (st === 'scraping' || st === 'generating' || st === 'running') {
          // Resume polling if report generation is in progress
          autoGenActive = true;
          startAutoGenerationPolling();
        }
      } catch(e) {
        console.warn('Error checking status for polling resume:', e);
      }
    }

    function showCalendarPage() {
      // Save current reports state
      const raportContainer = document.getElementById('raport-container');
      const kickReportContainer = document.getElementById('kick-report-container');
      
      savedReportsState.twitchVisible = raportContainer.style.display === 'block';
      savedReportsState.kickVisible = kickReportContainer.style.display === 'block';
      savedReportsState.twitchContent = raportContainer.innerHTML;
      savedReportsState.kickContent = kickReportContainer.innerHTML;
      
      // Stop any active polling when showing calendar
      try {
        stopAutoGenerationPolling();
      } catch(e) {
        console.warn('Error stopping polling:', e);
      }
      
      // Switch to calendar page
      document.getElementById('main-page').style.display = 'none';
      document.getElementById('calendar-page').style.display = 'block';
      currentPage = 'calendar';
      
      // Load calendar data
      loadCalendarData().catch(console.error);
    }

    // Initialize SPA navigation
    document.addEventListener('DOMContentLoaded', function() {
      const btnCalendar = document.getElementById('btn-calendar');
      const btnBackToMain = document.getElementById('btn-back-to-main');
      
      // Calendar button click handler
      btnCalendar.addEventListener('click', function() {
        showCalendarPage();
      });
      
      // Back button click handler
      btnBackToMain.addEventListener('click', function() {
        showMainPage();
      });
      
      // Calendar controls
      document.getElementById('btn-select-all').addEventListener('click', selectAllPosts);
      document.getElementById('btn-deselect-all').addEventListener('click', deselectAllPosts);
      document.getElementById('btn-push-selected').addEventListener('click', pushSelectedToPubler);
      document.getElementById('btn-refresh-calendar').addEventListener('click', loadCalendarData);
      
      // Filter checkboxes
      document.getElementById('filter-scheduled').addEventListener('change', filterCalendarData);
      document.getElementById('filter-published').addEventListener('change', filterCalendarData);
      document.getElementById('filter-failed').addEventListener('change', filterCalendarData);
    });
    
    async function loadCalendarData() {
      try {
        const response = await fetch('/api/internal-scheduler/posts');
        const data = await response.json();
        
        calendarData = [
          ...data.posts.scheduled.map(post => ({...post, status: 'scheduled'})),
          ...data.posts.published.map(post => ({...post, status: 'published'})),
          ...data.posts.failed.map(post => ({...post, status: 'failed'}))
        ];
        
        await renderCalendar();
      } catch (error) {
        console.error('Error loading calendar data:', error);
        document.getElementById('calendar-content').innerHTML = 
          '<div class="loading">BÅ‚Ä…d Å‚adowania danych terminarza</div>';
      }
    }
    
    async function renderCalendar() {
      const content = document.getElementById('calendar-content');
      const scheduledFilter = document.getElementById('filter-scheduled').checked;
      const publishedFilter = document.getElementById('filter-published').checked;
      const failedFilter = document.getElementById('filter-failed').checked;
      
      let filteredData = calendarData.filter(post => {
        if (post.status === 'scheduled' && !scheduledFilter) return false;
        if (post.status === 'published' && !publishedFilter) return false;
        if (post.status === 'failed' && !failedFilter) return false;
        return true;
      });
      
      if (filteredData.length === 0) {
        content.innerHTML = '<div class="loading">Brak postÃ³w do wyÅ›wietlenia</div>';
        return;
      }
      
      // Pobierz dane klipÃ³w dla wszystkich postÃ³w
      const clipDataPromises = filteredData.map(async post => {
        try {
          const response = await fetch(`/api/clip-data/${post.clip_id}`);
          const data = await response.json();
          return { ...post, clipData: data.ok ? data : null };
        } catch (error) {
          console.error(`BÅ‚Ä…d pobierania danych klipu ${post.clip_id}:`, error);
          return { ...post, clipData: null };
        }
      });
      
      const postsWithClipData = await Promise.all(clipDataPromises);
      
      const html = postsWithClipData.map(post => {
        const isSelected = selectedPosts.has(post.id || post.clip_id);
        const postId = post.id || post.clip_id;
        
        // WyÅ›wietl nazwÄ™ streamera i tytuÅ‚ klipu jeÅ›li dostÄ™pne
        let title = post.caption || `Post ${postId}`;
        if (post.clipData && post.clipData.broadcaster && post.clipData.title) {
          title = `${post.clipData.broadcaster} - ${post.clipData.title}`;
        }
        
        const date = post.scheduled_at || post.published_at || post.created_at || 'Brak daty';
        // Poprawka strefy czasowej - parsuj datÄ™ jako UTC i wyÅ›wietl w czasie lokalnym
        const utcDate = new Date(date);
        const formattedDate = utcDate.toLocaleString('pl-PL');
        
        return `
          <div class="calendar-post" style="cursor:pointer;" 
               onclick="window.open('/editor?clip=${encodeURIComponent(post.clip_id)}', '_blank')">
            <input type="checkbox" class="calendar-post-checkbox" 
                   data-post-id="${postId}" ${isSelected ? 'checked' : ''} 
                   onclick="event.stopPropagation();">
            <div class="calendar-post-info">
              <div class="calendar-post-title">${title}</div>
              <div class="calendar-post-date">${formattedDate}</div>
              <div class="calendar-post-status status-${post.status}">${getStatusText(post.status)}</div>
              <div class="calendar-post-actions" onclick="event.stopPropagation();">
                ${post.status === 'scheduled' ? 
                  `<button class="btn btn-sm" onclick="editPostTime('${postId}', '${date}')">Edytuj czas</button>
                   <button class="btn btn-sm" onclick="pushSinglePost('${postId}')">Push</button>
                   <button class="btn btn-sm btn-danger" onclick="deleteScheduledPost('${postId}')">UsuÅ„</button>` : 
                  ''}
              </div>
            </div>
          </div>
        `;
      }).join('');
      
      content.innerHTML = html;
      
      // Add event listeners to checkboxes
      content.querySelectorAll('.calendar-post-checkbox').forEach(checkbox => {
        checkbox.addEventListener('change', function() {
          const postId = this.dataset.postId;
          if (this.checked) {
            selectedPosts.add(postId);
          } else {
            selectedPosts.delete(postId);
          }
          updatePushButton();
        });
      });
    }
    
    function getStatusText(status) {
      switch(status) {
        case 'scheduled': return 'Zaplanowany';
        case 'published': return 'Opublikowany';
        case 'failed': return 'Nieudany';
        default: return status;
      }
    }
    
    function selectAllPosts() {
      const checkboxes = document.querySelectorAll('.calendar-post-checkbox');
      checkboxes.forEach(checkbox => {
        checkbox.checked = true;
        selectedPosts.add(checkbox.dataset.postId);
      });
      updatePushButton();
    }
    
    function deselectAllPosts() {
      const checkboxes = document.querySelectorAll('.calendar-post-checkbox');
      checkboxes.forEach(checkbox => {
        checkbox.checked = false;
        selectedPosts.delete(checkbox.dataset.postId);
      });
      updatePushButton();
    }
    
    function updatePushButton() {
      const pushButton = document.getElementById('btn-push-selected');
      const hasScheduledSelected = Array.from(selectedPosts).some(postId => {
        const post = calendarData.find(p => (p.id || p.clip_id) === postId);
        return post && post.status === 'scheduled';
      });
      
      pushButton.disabled = !hasScheduledSelected;
      pushButton.textContent = `ğŸš€ Push do Publera (${selectedPosts.size})`;
    }
    
    async function pushSelectedToPubler() {
      const scheduledSelected = Array.from(selectedPosts).filter(postId => {
        const post = calendarData.find(p => (p.id || p.clip_id) === postId);
        return post && post.status === 'scheduled';
      });
      
      if (scheduledSelected.length === 0) {
        alert('Nie wybrano Å¼adnych zaplanowanych postÃ³w');
        return;
      }
      
      try {
        const pushButton = document.getElementById('btn-push-selected');
        pushButton.disabled = true;
        pushButton.textContent = 'Szukam wolnych slotÃ³w...';
        
        // Pobierz dostÄ™pne sloty czasowe
        const slotsResponse = await fetch(`/api/publer/available-slots?count=${scheduledSelected.length}`);
        const slotsData = await slotsResponse.json();
        
        if (!slotsData.ok || !slotsData.available_slots || slotsData.available_slots.length < scheduledSelected.length) {
          alert(`Nie znaleziono wystarczajÄ…cej liczby wolnych slotÃ³w. Potrzeba: ${scheduledSelected.length}, dostÄ™pne: ${slotsData.available_slots?.length || 0}`);
          return;
        }
        
        pushButton.textContent = 'PrzypisujÄ™ sloty i przesyÅ‚am...';
        
        // Przypisz sloty i przeÅ›lij posty
        let successCount = 0;
        let errorCount = 0;
        
        for (let i = 0; i < scheduledSelected.length; i++) {
          const postId = scheduledSelected[i];
          const slot = slotsData.available_slots[i];
          
          try {
            // Najpierw zaktualizuj czas w schedulerze
            const updateResponse = await fetch(`/api/internal-scheduler/posts/${postId}`, {
              method: 'PUT',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                scheduled_at: slot.datetime
              })
            });
            
            if (updateResponse.ok) {
              // NastÄ™pnie przeÅ›lij do Publera
              const pushResponse = await fetch(`/api/internal-scheduler/push-to-publer/post/${postId}`, {
                method: 'POST'
              });
              
              if (pushResponse.ok) {
                successCount++;
              } else {
                errorCount++;
                console.error(`BÅ‚Ä…d przesyÅ‚ania posta ${postId}:`, await pushResponse.text());
              }
            } else {
              errorCount++;
              console.error(`BÅ‚Ä…d aktualizacji czasu posta ${postId}:`, await updateResponse.text());
            }
          } catch (error) {
            errorCount++;
            console.error(`BÅ‚Ä…d przetwarzania posta ${postId}:`, error);
          }
        }
        
        if (successCount > 0) {
          alert(`PrzesÅ‚ano ${successCount} postÃ³w do Publera z automatycznie przypisanymi slotami czasowymi.${errorCount > 0 ? ` BÅ‚Ä™dÃ³w: ${errorCount}` : ''}`);
        } else {
          alert('Nie udaÅ‚o siÄ™ przesÅ‚aÄ‡ Å¼adnego posta');
        }
        
        selectedPosts.clear();
        loadCalendarData().catch(console.error); // Refresh calendar
        
      } catch (error) {
        console.error('Error pushing posts:', error);
        alert('BÅ‚Ä…d podczas przesyÅ‚ania postÃ³w');
      } finally {
        updatePushButton();
      }
    }
    
    async function pushSinglePost(postId) {
      try {
        const response = await fetch(`/api/internal-scheduler/push-to-publer/post/${postId}`, {
          method: 'POST'
        });
        
        if (response.ok) {
          alert('Post przesÅ‚any do Publera');
          loadCalendarData().catch(console.error); // Refresh calendar
        } else {
          alert('BÅ‚Ä…d podczas przesyÅ‚ania posta');
        }
      } catch (error) {
        console.error('Error pushing post:', error);
        alert('BÅ‚Ä…d podczas przesyÅ‚ania posta');
      }
    }
    
    async function editPostTime(postId, currentTime) {
      try {
        // Konwertuj aktualny czas na format datetime-local
        const currentDate = new Date(currentTime);
        const localDateTime = new Date(currentDate.getTime() - currentDate.getTimezoneOffset() * 60000)
          .toISOString().slice(0, 16);
        
        // PokaÅ¼ dialog z inputem datetime-local
        const newTime = prompt(`Podaj nowy czas publikacji (format: YYYY-MM-DD HH:MM):\n\nAktualny czas: ${currentDate.toLocaleString('pl-PL')}`, 
          localDateTime.replace('T', ' '));
        
        if (!newTime) return; // UÅ¼ytkownik anulowaÅ‚
        
        // Walidacja formatu
        let newDate;
        try {
          // SprÃ³buj parsowaÄ‡ w formacie "YYYY-MM-DD HH:MM"
          if (newTime.includes(' ')) {
            const [datePart, timePart] = newTime.split(' ');
            newDate = new Date(`${datePart}T${timePart}:00`);
          } else {
            newDate = new Date(newTime);
          }
          
          if (isNaN(newDate.getTime())) {
            throw new Error('Invalid date');
          }
        } catch (error) {
          alert('NieprawidÅ‚owy format daty. UÅ¼yj formatu: YYYY-MM-DD HH:MM (np. 2024-12-25 14:30)');
          return;
        }
        
        // Konwertuj na ISO string z poprawnÄ… strefÄ… czasowÄ…
        // UÅ¼ytkownik wprowadza czas lokalny, wiÄ™c traktujemy go jako lokalny czas
        // Tworzymy nowy obiekt Date z wprowadzonÄ… datÄ… jako lokalnÄ… datÄ…
        // JavaScript automatycznie obsÅ‚uÅ¼y konwersjÄ™ na UTC uwzglÄ™dniajÄ…c czas letni/zimowy
        const localDate = new Date(newDate.getFullYear(), newDate.getMonth(), newDate.getDate(), 
                                   newDate.getHours(), newDate.getMinutes(), newDate.getSeconds());
        const isoString = localDate.toISOString();
        
        // WyÅ›lij Å¼Ä…danie aktualizacji
        const response = await fetch(`/api/internal-scheduler/posts/${postId}`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            scheduled_at: isoString
          })
        });
        
        if (response.ok) {
          alert(`Czas publikacji zostaÅ‚ zmieniony na: ${newDate.toLocaleString('pl-PL')}`);
          loadCalendarData().catch(console.error); // Refresh calendar
        } else {
          const errorData = await response.json();
          alert(`BÅ‚Ä…d podczas aktualizacji czasu: ${errorData.error || 'Nieznany bÅ‚Ä…d'}`);
        }
      } catch (error) {
        console.error('Error editing post time:', error);
        alert('BÅ‚Ä…d podczas edycji czasu posta');
      }
    }
    
    async function deleteScheduledPost(postId) {
      if (!confirm('Czy na pewno chcesz usunÄ…Ä‡ ten zaplanowany post?')) {
        return;
      }
      
      try {
        const response = await fetch(`/api/internal-scheduler/posts/${postId}`, {
          method: 'DELETE'
        });
        
        if (response.ok) {
          alert('Post zostaÅ‚ usuniÄ™ty z harmonogramu');
          loadCalendarData().catch(console.error); // Refresh calendar
        } else {
          const errorData = await response.json();
          alert(`BÅ‚Ä…d podczas usuwania posta: ${errorData.error || 'Nieznany bÅ‚Ä…d'}`);
        }
      } catch (error) {
        console.error('Error deleting post:', error);
        alert('BÅ‚Ä…d podczas usuwania posta');
      }
    }
    
    async function filterCalendarData() {
      await renderCalendar();
    }
  </script>
  
  </body>
  </html>
